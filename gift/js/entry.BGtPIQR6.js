var e, t = Object.defineProperty; function n(e, t) { const n = Object.create(null), r = e.split(","); for (let o = 0; o < r.length; o++)n[r[o]] = !0; return t ? e => !!n[e.toLowerCase()] : e => !!n[e] } const r = () => { }, o = Object.prototype.hasOwnProperty, s = (e, t) => o.call(e, t), i = Array.isArray, a = e => "[object Map]" === p(e), c = e => "function" == typeof e, l = e => "symbol" == typeof e, u = e => null !== e && "object" == typeof e, d = Object.prototype.toString, p = e => d.call(e), f = e => p(e).slice(8, -1), h = e => "string" == typeof e && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e, m = (e, t) => !Object.is(e, t), g = (e, t, n) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: n }) }; let y; class _ { constructor(e = !1) { this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = y, !e && y && (this.index = (y.scopes || (y.scopes = [])).push(this) - 1) } get active() { return this._active } run(e) { if (this._active) { const t = y; try { return y = this, e() } finally { y = t } } } on() { y = this } off() { y = this.parent } stop(e) { if (this._active) { let t, n; for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].stop(); for (t = 0, n = this.cleanups.length; t < n; t++)this.cleanups[t](); if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].stop(!0); if (!this.detached && this.parent && !e) { const e = this.parent.scopes.pop(); e && e !== this && (this.parent.scopes[this.index] = e, e.index = this.index) } this.parent = void 0, this._active = !1 } } } function v(e) { return new _(e) } function b() { return y } function w(e) { y && y.cleanups.push(e) } const S = e => { const t = new Set(e); return t.w = 0, t.n = 0, t }, k = e => (e.w & C) > 0, E = e => (e.n & C) > 0, T = new WeakMap; let x = 0, C = 1; const O = 30; let A; const R = Symbol(""), I = Symbol(""); class $ { constructor(e, t = null, n) { this.fn = e, this.scheduler = t, this.active = !0, this.deps = [], this.parent = void 0, function (e, t = y) { t && t.active && t.effects.push(e) }(this, n) } run() { if (!this.active) return this.fn(); let e = A, t = j; for (; e;) { if (e === this) return; e = e.parent } try { return this.parent = A, A = this, j = !0, C = 1 << ++x, x <= O ? (({ deps: e }) => { if (e.length) for (let t = 0; t < e.length; t++)e[t].w |= C })(this) : P(this), this.fn() } finally { x <= O && (e => { const { deps: t } = e; if (t.length) { let n = 0; for (let r = 0; r < t.length; r++) { const o = t[r]; k(o) && !E(o) ? o.delete(e) : t[n++] = o, o.w &= ~C, o.n &= ~C } t.length = n } })(this), C = 1 << --x, A = this.parent, j = t, this.parent = void 0, this.deferStop && this.stop() } } stop() { A === this ? this.deferStop = !0 : this.active && (P(this), this.onStop && this.onStop(), this.active = !1) } } function P(e) { const { deps: t } = e; if (t.length) { for (let n = 0; n < t.length; n++)t[n].delete(e); t.length = 0 } } let j = !0; const L = []; function D() { L.push(j), j = !1 } function N() { const e = L.pop(); j = void 0 === e || e } function M(e, t, n) { if (j && A) { let t = T.get(e); t || T.set(e, t = new Map); let r = t.get(n); r || t.set(n, r = S()), F(r) } } function F(e, t) { let n = !1; x <= O ? E(e) || (e.n |= C, n = !k(e)) : n = !e.has(A), n && (e.add(A), A.deps.push(e)) } function U(e, t, n, r, o, s) { const c = T.get(e); if (!c) return; let u = []; if ("clear" === t) u = [...c.values()]; else if ("length" === n && i(e)) { const e = Number(r); c.forEach(((t, n) => { ("length" === n || !l(n) && n >= e) && u.push(t) })) } else switch (void 0 !== n && u.push(c.get(n)), t) { case "add": i(e) ? h(n) && u.push(c.get("length")) : (u.push(c.get(R)), a(e) && u.push(c.get(I))); break; case "delete": i(e) || (u.push(c.get(R)), a(e) && u.push(c.get(I))); break; case "set": a(e) && u.push(c.get(R)) }if (1 === u.length) u[0] && H(u[0]); else { const e = []; for (const t of u) t && e.push(...t); H(S(e)) } } function H(e, t) { const n = i(e) ? e : [...e]; for (const r of n) r.computed && B(r); for (const r of n) r.computed || B(r) } function B(e, t) { (e !== A || e.allowRecurse) && (e.scheduler ? e.scheduler() : e.run()) } const q = n("__proto__,__v_isRef,__isVue"), V = new Set(Object.getOwnPropertyNames(Symbol).filter((e => "arguments" !== e && "caller" !== e)).map((e => Symbol[e])).filter(l)), W = z(); function z() { const e = {}; return ["includes", "indexOf", "lastIndexOf"].forEach((t => { e[t] = function (...e) { const n = Pe(this); for (let t = 0, o = this.length; t < o; t++)M(n, 0, t + ""); const r = n[t](...e); return -1 === r || !1 === r ? n[t](...e.map(Pe)) : r } })), ["push", "pop", "shift", "unshift", "splice"].forEach((t => { e[t] = function (...e) { D(); const n = Pe(this)[t].apply(this, e); return N(), n } })), e } function G(e) { const t = Pe(this); return M(t, 0, e), t.hasOwnProperty(e) } class J { constructor(e = !1, t = !1) { this._isReadonly = e, this._shallow = t } get(e, t, n) { const r = this._isReadonly, o = this._shallow; if ("__v_isReactive" === t) return !r; if ("__v_isReadonly" === t) return r; if ("__v_isShallow" === t) return o; if ("__v_raw" === t) return n === (r ? o ? Ee : ke : o ? Se : we).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0; const a = i(e); if (!r) { if (a && s(W, t)) return Reflect.get(W, t, n); if ("hasOwnProperty" === t) return G } const c = Reflect.get(e, t, n); return (l(t) ? V.has(t) : q(t)) ? c : (r || M(e, 0, t), o ? c : Fe(c) ? a && h(t) ? c : c.value : u(c) ? r ? Ce(c) : Te(c) : c) } } class K extends J { constructor(e = !1) { super(!1, e) } set(e, t, n, r) { let o = e[t]; if (!this._shallow) { const t = Re(o); if (Ie(n) || Re(n) || (o = Pe(o), n = Pe(n)), !i(e) && Fe(o) && !Fe(n)) return !t && (o.value = n, !0) } const a = i(e) && h(t) ? Number(t) < e.length : s(e, t), c = Reflect.set(e, t, n, r); return e === Pe(r) && (a ? m(n, o) && U(e, "set", t, n) : U(e, "add", t, n)), c } deleteProperty(e, t) { const n = s(e, t); e[t]; const r = Reflect.deleteProperty(e, t); return r && n && U(e, "delete", t, void 0), r } has(e, t) { const n = Reflect.has(e, t); return l(t) && V.has(t) || M(e, 0, t), n } ownKeys(e) { return M(e, 0, i(e) ? "length" : R), Reflect.ownKeys(e) } } class Y extends J { constructor(e = !1) { super(!0, e) } set(e, t) { return !0 } deleteProperty(e, t) { return !0 } } const Q = new K, X = new Y, Z = new K(!0), ee = e => e, te = e => Reflect.getPrototypeOf(e); function ne(e, t, n = !1, r = !1) { const o = Pe(e = e.__v_raw), s = Pe(t); n || (m(t, s) && M(o, 0, t), M(o, 0, s)); const { has: i } = te(o), a = r ? ee : n ? De : Le; return i.call(o, t) ? a(e.get(t)) : i.call(o, s) ? a(e.get(s)) : void (e !== o && e.get(t)) } function re(e, t = !1) { const n = this.__v_raw, r = Pe(n), o = Pe(e); return t || (m(e, o) && M(r, 0, e), M(r, 0, o)), e === o ? n.has(e) : n.has(e) || n.has(o) } function oe(e, t = !1) { return e = e.__v_raw, !t && M(Pe(e), 0, R), Reflect.get(e, "size", e) } function se(e) { e = Pe(e); const t = Pe(this); return te(t).has.call(t, e) || (t.add(e), U(t, "add", e, e)), this } function ie(e, t) { t = Pe(t); const n = Pe(this), { has: r, get: o } = te(n); let s = r.call(n, e); s || (e = Pe(e), s = r.call(n, e)); const i = o.call(n, e); return n.set(e, t), s ? m(t, i) && U(n, "set", e, t) : U(n, "add", e, t), this } function ae(e) { const t = Pe(this), { has: n, get: r } = te(t); let o = n.call(t, e); o || (e = Pe(e), o = n.call(t, e)), r && r.call(t, e); const s = t.delete(e); return o && U(t, "delete", e, void 0), s } function ce() { const e = Pe(this), t = 0 !== e.size, n = e.clear(); return t && U(e, "clear", void 0, void 0), n } function le(e, t) { return function (n, r) { const o = this, s = o.__v_raw, i = Pe(s), a = t ? ee : e ? De : Le; return !e && M(i, 0, R), s.forEach(((e, t) => n.call(r, a(e), a(t), o))) } } function ue(e, t, n) { return function (...r) { const o = this.__v_raw, s = Pe(o), i = a(s), c = "entries" === e || e === Symbol.iterator && i, l = "keys" === e && i, u = o[e](...r), d = n ? ee : t ? De : Le; return !t && M(s, 0, l ? I : R), { next() { const { value: e, done: t } = u.next(); return t ? { value: e, done: t } : { value: c ? [d(e[0]), d(e[1])] : d(e), done: t } }, [Symbol.iterator]() { return this } } } } function de(e) { return function (...t) { return "delete" !== e && ("clear" === e ? void 0 : this) } } function pe() { const e = { get(e) { return ne(this, e) }, get size() { return oe(this) }, has: re, add: se, set: ie, delete: ae, clear: ce, forEach: le(!1, !1) }, t = { get(e) { return ne(this, e, !1, !0) }, get size() { return oe(this) }, has: re, add: se, set: ie, delete: ae, clear: ce, forEach: le(!1, !0) }, n = { get(e) { return ne(this, e, !0) }, get size() { return oe(this, !0) }, has(e) { return re.call(this, e, !0) }, add: de("add"), set: de("set"), delete: de("delete"), clear: de("clear"), forEach: le(!0, !1) }, r = { get(e) { return ne(this, e, !0, !0) }, get size() { return oe(this, !0) }, has(e) { return re.call(this, e, !0) }, add: de("add"), set: de("set"), delete: de("delete"), clear: de("clear"), forEach: le(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach((o => { e[o] = ue(o, !1, !1), n[o] = ue(o, !0, !1), t[o] = ue(o, !1, !0), r[o] = ue(o, !0, !0) })), [e, n, t, r] } const [fe, he, me, ge] = pe(); function ye(e, t) { const n = t ? e ? ge : me : e ? he : fe; return (t, r, o) => "__v_isReactive" === r ? !e : "__v_isReadonly" === r ? e : "__v_raw" === r ? t : Reflect.get(s(n, r) && r in t ? n : t, r, o) } const _e = { get: ye(!1, !1) }, ve = { get: ye(!1, !0) }, be = { get: ye(!0, !1) }, we = new WeakMap, Se = new WeakMap, ke = new WeakMap, Ee = new WeakMap; function Te(e) { return Re(e) ? e : Oe(e, !1, Q, _e, we) } function xe(e) { return Oe(e, !1, Z, ve, Se) } function Ce(e) { return Oe(e, !0, X, be, ke) } function Oe(e, t, n, r, o) { if (!u(e)) return e; if (e.__v_raw && (!t || !e.__v_isReactive)) return e; const s = o.get(e); if (s) return s; const i = (a = e).__v_skip || !Object.isExtensible(a) ? 0 : function (e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } }(f(a)); var a; if (0 === i) return e; const c = new Proxy(e, 2 === i ? r : n); return o.set(e, c), c } function Ae(e) { return Re(e) ? Ae(e.__v_raw) : !(!e || !e.__v_isReactive) } function Re(e) { return !(!e || !e.__v_isReadonly) } function Ie(e) { return !(!e || !e.__v_isShallow) } function $e(e) { return Ae(e) || Re(e) } function Pe(e) { const t = e && e.__v_raw; return t ? Pe(t) : e } function je(e) { return g(e, "__v_skip", !0), e } const Le = e => u(e) ? Te(e) : e, De = e => u(e) ? Ce(e) : e; function Ne(e) { j && A && F((e = Pe(e)).dep || (e.dep = S())) } function Me(e, t) { const n = (e = Pe(e)).dep; n && H(n) } function Fe(e) { return !(!e || !0 !== e.__v_isRef) } function Ue(e) { return Be(e, !1) } function He(e) { return Be(e, !0) } function Be(e, t) { return Fe(e) ? e : new qe(e, t) } class qe { constructor(e, t) { this.__v_isShallow = t, this.dep = void 0, this.__v_isRef = !0, this._rawValue = t ? e : Pe(e), this._value = t ? e : Le(e) } get value() { return Ne(this), this._value } set value(e) { const t = this.__v_isShallow || Ie(e) || Re(e); e = t ? e : Pe(e), m(e, this._rawValue) && (this._rawValue = e, this._value = t ? e : Le(e), Me(this)) } } function Ve(e) { return Fe(e) ? e.value : e } const We = { get: (e, t, n) => Ve(Reflect.get(e, t, n)), set: (e, t, n, r) => { const o = e[t]; return Fe(o) && !Fe(n) ? (o.value = n, !0) : Reflect.set(e, t, n, r) } }; function ze(e) { return Ae(e) ? e : new Proxy(e, We) } function Ge(e) { const t = i(e) ? new Array(e.length) : {}; for (const n in e) t[n] = Ye(e, n); return t } class Je { constructor(e, t, n) { this._object = e, this._key = t, this._defaultValue = n, this.__v_isRef = !0 } get value() { const e = this._object[this._key]; return void 0 === e ? this._defaultValue : e } set value(e) { this._object[this._key] = e } get dep() { return e = Pe(this._object), t = this._key, null == (n = T.get(e)) ? void 0 : n.get(t); var e, t, n } } class Ke { constructor(e) { this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0 } get value() { return this._getter() } } function Ye(e, t, n) { const r = e[t]; return Fe(r) ? r : new Je(e, t, n) } class Qe { constructor(e, t, n, r) { this._setter = t, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new $(e, (() => { this._dirty || (this._dirty = !0, Me(this)) })), this.effect.computed = this, this.effect.active = this._cacheable = !r, this.__v_isReadonly = n } get value() { const e = Pe(this); return Ne(e), !e._dirty && e._cacheable || (e._dirty = !1, e._value = e.effect.run()), e._value } set value(e) { this._setter(e) } } function Xe(e, t) { const n = Object.create(null), r = e.split(","); for (let o = 0; o < r.length; o++)n[r[o]] = !0; return t ? e => !!n[e.toLowerCase()] : e => !!n[e] } const Ze = {}, et = [], tt = () => { }, nt = () => !1, rt = e => 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), ot = e => e.startsWith("onUpdate:"), st = Object.assign, it = (e, t) => { const n = e.indexOf(t); n > -1 && e.splice(n, 1) }, at = Object.prototype.hasOwnProperty, ct = (e, t) => at.call(e, t), lt = Array.isArray, ut = e => "[object Map]" === _t(e), dt = e => "[object Set]" === _t(e), pt = e => "function" == typeof e, ft = e => "string" == typeof e, ht = e => "symbol" == typeof e, mt = e => null !== e && "object" == typeof e, gt = e => (mt(e) || pt(e)) && pt(e.then) && pt(e.catch), yt = Object.prototype.toString, _t = e => yt.call(e), vt = e => "[object Object]" === _t(e), bt = Xe(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), wt = e => { const t = Object.create(null); return n => t[n] || (t[n] = e(n)) }, St = /-(\w)/g, kt = wt((e => e.replace(St, ((e, t) => t ? t.toUpperCase() : "")))), Et = /\B([A-Z])/g, Tt = wt((e => e.replace(Et, "-$1").toLowerCase())), xt = wt((e => e.charAt(0).toUpperCase() + e.slice(1))), Ct = wt((e => e ? `on${xt(e)}` : "")), Ot = (e, t) => !Object.is(e, t), At = (e, t) => { for (let n = 0; n < e.length; n++)e[n](t) }, Rt = (e, t, n) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: n }) }, It = e => { const t = parseFloat(e); return isNaN(t) ? e : t }, $t = e => { const t = ft(e) ? Number(e) : NaN; return isNaN(t) ? e : t }; let Pt; const jt = () => Pt || (Pt = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {}); function Lt(e) { if (lt(e)) { const t = {}; for (let n = 0; n < e.length; n++) { const r = e[n], o = ft(r) ? Ft(r) : Lt(r); if (o) for (const e in o) t[e] = o[e] } return t } if (ft(e) || mt(e)) return e } const Dt = /;(?![^(]*\))/g, Nt = /:([^]+)/, Mt = /\/\*[^]*?\*\//g; function Ft(e) { const t = {}; return e.replace(Mt, "").split(Dt).forEach((e => { if (e) { const n = e.split(Nt); n.length > 1 && (t[n[0].trim()] = n[1].trim()) } })), t } function Ut(e) { let t = ""; if (ft(e)) t = e; else if (lt(e)) for (let n = 0; n < e.length; n++) { const r = Ut(e[n]); r && (t += r + " ") } else if (mt(e)) for (const n in e) e[n] && (t += n + " "); return t.trim() } function Ht(e) { if (!e) return null; let { class: t, style: n } = e; return t && !ft(t) && (e.class = Ut(t)), n && (e.style = Lt(n)), e } const Bt = e => ft(e) ? e : null == e ? "" : lt(e) || mt(e) && (e.toString === yt || !pt(e.toString)) ? JSON.stringify(e, qt, 2) : String(e), qt = (e, t) => t && t.__v_isRef ? qt(e, t.value) : ut(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce(((e, [t, n], r) => (e[Vt(t, r) + " =>"] = n, e)), {}) } : dt(t) ? { [`Set(${t.size})`]: [...t.values()].map((e => Vt(e))) } : ht(t) ? Vt(t) : !mt(t) || lt(t) || vt(t) ? t : String(t), Vt = (e, t = "") => { var n; return ht(e) ? `Symbol(${null != (n = e.description) ? n : t})` : e }; function Wt(e, t, n, r) { let o; try { o = r ? e(...r) : e() } catch (s) { Gt(s, t, n) } return o } function zt(e, t, n, r) { if (pt(e)) { const o = Wt(e, t, n, r); return o && gt(o) && o.catch((e => { Gt(e, t, n) })), o } const o = []; for (let s = 0; s < e.length; s++)o.push(zt(e[s], t, n, r)); return o } function Gt(e, t, n, r = !0) { t && t.vnode; if (t) { let r = t.parent; const o = t.proxy, s = n; for (; r;) { const t = r.ec; if (t) for (let n = 0; n < t.length; n++)if (!1 === t[n](e, o, s)) return; r = r.parent } const i = t.appContext.config.errorHandler; if (i) return void Wt(i, null, 10, [e, o, s]) } !function (e, t, n, r = !0) { console.error(e) }(e, 0, 0, r) } let Jt = !1, Kt = !1; const Yt = []; let Qt = 0; const Xt = []; let Zt = null, en = 0; const tn = Promise.resolve(); let nn = null; function rn(e) { const t = nn || tn; return e ? t.then(this ? e.bind(this) : e) : t } function on(e) { Yt.length && Yt.includes(e, Jt && e.allowRecurse ? Qt + 1 : Qt) || (null == e.id ? Yt.push(e) : Yt.splice(function (e) { let t = Qt + 1, n = Yt.length; for (; t < n;) { const r = t + n >>> 1, o = Yt[r], s = un(o); s < e || s === e && o.pre ? t = r + 1 : n = r } return t }(e.id), 0, e), sn()) } function sn() { Jt || Kt || (Kt = !0, nn = tn.then(pn)) } function an(e) { lt(e) ? Xt.push(...e) : Zt && Zt.includes(e, e.allowRecurse ? en + 1 : en) || Xt.push(e), sn() } function cn(e, t, n = (Jt ? Qt + 1 : 0)) { for (; n < Yt.length; n++) { const t = Yt[n]; if (t && t.pre) { if (e && t.id !== e.uid) continue; Yt.splice(n, 1), n--, t() } } } function ln(e) { if (Xt.length) { const e = [...new Set(Xt)]; if (Xt.length = 0, Zt) return void Zt.push(...e); for (Zt = e, Zt.sort(((e, t) => un(e) - un(t))), en = 0; en < Zt.length; en++)Zt[en](); Zt = null, en = 0 } } const un = e => null == e.id ? 1 / 0 : e.id, dn = (e, t) => { const n = un(e) - un(t); if (0 === n) { if (e.pre && !t.pre) return -1; if (t.pre && !e.pre) return 1 } return n }; function pn(e) { Kt = !1, Jt = !0, Yt.sort(dn); try { for (Qt = 0; Qt < Yt.length; Qt++) { const e = Yt[Qt]; e && !1 !== e.active && Wt(e, null, 14) } } finally { Qt = 0, Yt.length = 0, ln(), Jt = !1, nn = null, (Yt.length || Xt.length) && pn() } } function fn(e, t, ...n) { if (e.isUnmounted) return; const r = e.vnode.props || Ze; let o = n; const s = t.startsWith("update:"), i = s && t.slice(7); if (i && i in r) { const e = `${"modelValue" === i ? "model" : i}Modifiers`, { number: t, trim: s } = r[e] || Ze; s && (o = n.map((e => ft(e) ? e.trim() : e))), t && (o = n.map(It)) } let a, c = r[a = Ct(t)] || r[a = Ct(kt(t))]; !c && s && (c = r[a = Ct(Tt(t))]), c && zt(c, e, 6, o); const l = r[a + "Once"]; if (l) { if (e.emitted) { if (e.emitted[a]) return } else e.emitted = {}; e.emitted[a] = !0, zt(l, e, 6, o) } } function hn(e, t, n = !1) { const r = t.emitsCache, o = r.get(e); if (void 0 !== o) return o; const s = e.emits; let i = {}, a = !1; if (!pt(e)) { const r = e => { const n = hn(e, t, !0); n && (a = !0, st(i, n)) }; !n && t.mixins.length && t.mixins.forEach(r), e.extends && r(e.extends), e.mixins && e.mixins.forEach(r) } return s || a ? (lt(s) ? s.forEach((e => i[e] = null)) : st(i, s), mt(e) && r.set(e, i), i) : (mt(e) && r.set(e, null), null) } function mn(e, t) { return !(!e || !rt(t)) && (t = t.slice(2).replace(/Once$/, ""), ct(e, t[0].toLowerCase() + t.slice(1)) || ct(e, Tt(t)) || ct(e, t)) } let gn = null, yn = null; function _n(e) { const t = gn; return gn = e, yn = e && e.type.__scopeId || null, t } function vn(e) { yn = e } function bn() { yn = null } const wn = e => Sn; function Sn(e, t = gn, n) { if (!t) return e; if (e._n) return e; const r = (...n) => { r._d && Qo(-1); const o = _n(t); let s; try { s = e(...n) } finally { _n(o), r._d && Qo(1) } return s }; return r._n = !0, r._c = !0, r._d = !0, r } function kn(e) { const { type: t, vnode: n, proxy: r, withProxy: o, props: s, propsOptions: [i], slots: a, attrs: c, emit: l, render: u, renderCache: d, data: p, setupState: f, ctx: h, inheritAttrs: m } = e; let g, y; const _ = _n(e); try { if (4 & n.shapeFlag) { const e = o || r, t = e; g = ps(u.call(t, e, d, s, f, p, h)), y = c } else { const e = t; 0, g = ps(e.length > 1 ? e(s, { attrs: c, slots: a, emit: l }) : e(s, null)), y = t.props ? c : En(c) } } catch (b) { zo.length = 0, Gt(b, e, 1), g = as(Vo) } let v = g; if (y && !1 !== m) { const e = Object.keys(y), { shapeFlag: t } = v; e.length && 7 & t && (i && e.some(ot) && (y = Tn(y, i)), v = cs(v, y)) } return n.dirs && (v = cs(v), v.dirs = v.dirs ? v.dirs.concat(n.dirs) : n.dirs), n.transition && (v.transition = n.transition), g = v, _n(_), g } const En = e => { let t; for (const n in e) ("class" === n || "style" === n || rt(n)) && ((t || (t = {}))[n] = e[n]); return t }, Tn = (e, t) => { const n = {}; for (const r in e) ot(r) && r.slice(9) in t || (n[r] = e[r]); return n }; function xn(e, t, n) { const r = Object.keys(t); if (r.length !== Object.keys(e).length) return !0; for (let o = 0; o < r.length; o++) { const s = r[o]; if (t[s] !== e[s] && !mn(n, s)) return !0 } return !1 } function Cn({ vnode: e, parent: t }, n) { for (; t && t.subTree === e;)(e = t.vnode).el = n, t = t.parent } const On = "components"; function An(e, t) { return $n(On, e, !0, t) || e } const Rn = Symbol.for("v-ndc"); function In(e) { return ft(e) ? $n(On, e, !1) || e : e || Rn } function $n(e, t, n = !0, r = !1) { const o = gn || vs; if (o) { const n = o.type; if (e === On) { const e = Ps(n, !1); if (e && (e === t || e === kt(t) || e === xt(kt(t)))) return n } const s = Pn(o[e] || n[e], t) || Pn(o.appContext[e], t); return !s && r ? n : s } } function Pn(e, t) { return e && (e[t] || e[kt(t)] || e[xt(kt(t))]) } const jn = e => e.__isSuspense, Ln = { name: "Suspense", __isSuspense: !0, process(e, t, n, r, o, s, i, a, c, l) { null == e ? function (e, t, n, r, o, s, i, a, c) { const { p: l, o: { createElement: u } } = c, d = u("div"), p = e.suspense = Nn(e, o, r, t, d, n, s, i, a, c); l(null, p.pendingBranch = e.ssContent, d, null, r, p, s, i), p.deps > 0 ? (Dn(e, "onPending"), Dn(e, "onFallback"), l(null, e.ssFallback, t, n, r, null, s, i), Un(p, e.ssFallback)) : p.resolve(!1, !0) }(t, n, r, o, s, i, a, c, l) : function (e, t, n, r, o, s, i, a, { p: c, um: l, o: { createElement: u } }) { const d = t.suspense = e.suspense; d.vnode = t, t.el = e.el; const p = t.ssContent, f = t.ssFallback, { activeBranch: h, pendingBranch: m, isInFallback: g, isHydrating: y } = d; if (m) d.pendingBranch = p, ns(p, m) ? (c(m, p, d.hiddenContainer, null, o, d, s, i, a), d.deps <= 0 ? d.resolve() : g && (c(h, f, n, r, o, null, s, i, a), Un(d, f))) : (d.pendingId++, y ? (d.isHydrating = !1, d.activeBranch = m) : l(m, o, d), d.deps = 0, d.effects.length = 0, d.hiddenContainer = u("div"), g ? (c(null, p, d.hiddenContainer, null, o, d, s, i, a), d.deps <= 0 ? d.resolve() : (c(h, f, n, r, o, null, s, i, a), Un(d, f))) : h && ns(p, h) ? (c(h, p, n, r, o, d, s, i, a), d.resolve(!0)) : (c(null, p, d.hiddenContainer, null, o, d, s, i, a), d.deps <= 0 && d.resolve())); else if (h && ns(p, h)) c(h, p, n, r, o, d, s, i, a), Un(d, p); else if (Dn(t, "onPending"), d.pendingBranch = p, d.pendingId++, c(null, p, d.hiddenContainer, null, o, d, s, i, a), d.deps <= 0) d.resolve(); else { const { timeout: e, pendingId: t } = d; e > 0 ? setTimeout((() => { d.pendingId === t && d.fallback(f) }), e) : 0 === e && d.fallback(f) } }(e, t, n, r, o, i, a, c, l) }, hydrate: function (e, t, n, r, o, s, i, a, c) { const l = t.suspense = Nn(t, r, n, e.parentNode, document.createElement("div"), null, o, s, i, a, !0), u = c(e, l.pendingBranch = t.ssContent, n, l, s, i); 0 === l.deps && l.resolve(!1, !0); return u }, create: Nn, normalize: function (e) { const { shapeFlag: t, children: n } = e, r = 32 & t; e.ssContent = Mn(r ? n.default : n), e.ssFallback = r ? Mn(n.fallback) : as(Vo) } }; function Dn(e, t) { const n = e.props && e.props[t]; pt(n) && n() } function Nn(e, t, n, r, o, s, i, a, c, l, u = !1) { const { p: d, m: p, um: f, n: h, o: { parentNode: m, remove: g } } = l; let y; const _ = function (e) { var t; return null != (null == (t = e.props) ? void 0 : t.suspensible) && !1 !== e.props.suspensible }(e); _ && (null == t ? void 0 : t.pendingBranch) && (y = t.pendingId, t.deps++); const v = e.props ? $t(e.props.timeout) : void 0, b = { vnode: e, parent: t, parentComponent: n, isSVG: i, container: r, hiddenContainer: o, anchor: s, deps: 0, pendingId: 0, timeout: "number" == typeof v ? v : -1, activeBranch: null, pendingBranch: null, isInFallback: !u, isHydrating: u, isUnmounted: !1, effects: [], resolve(e = !1, n = !1) { const { vnode: r, activeBranch: o, pendingBranch: s, pendingId: i, effects: a, parentComponent: c, container: l } = b; let u = !1; if (b.isHydrating) b.isHydrating = !1; else if (!e) { u = o && s.transition && "out-in" === s.transition.mode, u && (o.transition.afterLeave = () => { i === b.pendingId && (p(s, l, h(o), 0), an(a)) }); let { anchor: e } = b; o && (e = h(o), f(o, c, b, !0)), u || p(s, l, e, 0) } Un(b, s), b.pendingBranch = null, b.isInFallback = !1; let d = b.parent, m = !1; for (; d;) { if (d.pendingBranch) { d.effects.push(...a), m = !0; break } d = d.parent } m || u || an(a), b.effects = [], _ && t && t.pendingBranch && y === t.pendingId && (t.deps--, 0 !== t.deps || n || t.resolve()), Dn(r, "onResolve") }, fallback(e) { if (!b.pendingBranch) return; const { vnode: t, activeBranch: n, parentComponent: r, container: o, isSVG: s } = b; Dn(t, "onFallback"); const i = h(n), l = () => { b.isInFallback && (d(null, e, o, i, r, null, s, a, c), Un(b, e)) }, u = e.transition && "out-in" === e.transition.mode; u && (n.transition.afterLeave = l), b.isInFallback = !0, f(n, r, null, !0), u || l() }, move(e, t, n) { b.activeBranch && p(b.activeBranch, e, t, n), b.container = e }, next: () => b.activeBranch && h(b.activeBranch), registerDep(e, t) { const n = !!b.pendingBranch; n && b.deps++; const r = e.vnode.el; e.asyncDep.catch((t => { Gt(t, e, 0) })).then((o => { if (e.isUnmounted || b.isUnmounted || b.pendingId !== e.suspenseId) return; e.asyncResolved = !0; const { vnode: s } = e; As(e, o, !1), r && (s.el = r); const a = !r && e.subTree.el; t(e, s, m(r || e.subTree.el), r ? null : h(e.subTree), b, i, c), a && g(a), Cn(e, s.el), n && 0 == --b.deps && b.resolve() })) }, unmount(e, t) { b.isUnmounted = !0, b.activeBranch && f(b.activeBranch, n, e, t), b.pendingBranch && f(b.pendingBranch, n, e, t) } }; return b } function Mn(e) { let t; if (pt(e)) { const n = Yo && e._c; n && (e._d = !1, Jo()), e = e(), n && (e._d = !0, t = Go, Ko()) } if (lt(e)) { const t = function (e) { let t; for (let n = 0; n < e.length; n++) { const r = e[n]; if (!ts(r)) return; if (r.type !== Vo || "v-if" === r.children) { if (t) return; t = r } } return t }(e); e = t } return e = ps(e), t && !e.dynamicChildren && (e.dynamicChildren = t.filter((t => t !== e))), e } function Fn(e, t) { t && t.pendingBranch ? lt(e) ? t.effects.push(...e) : t.effects.push(e) : an(e) } function Un(e, t) { e.activeBranch = t; const { vnode: n, parentComponent: r } = e, o = n.el = t.el; r && r.subTree === n && (r.vnode.el = o, Cn(r, o)) } function Hn(e, t) { return Vn(e, null, t) } const Bn = {}; function qn(e, t, n) { return Vn(e, t, n) } function Vn(e, t, { immediate: n, deep: r, flush: o, onTrack: s, onTrigger: i } = Ze) { var a; const c = b() === (null == (a = vs) ? void 0 : a.scope) ? vs : null; let l, u, d = !1, p = !1; if (Fe(e) ? (l = () => e.value, d = Ie(e)) : Ae(e) ? (l = () => e, r = !0) : lt(e) ? (p = !0, d = e.some((e => Ae(e) || Ie(e))), l = () => e.map((e => Fe(e) ? e.value : Ae(e) ? Gn(e) : pt(e) ? Wt(e, c, 2) : void 0))) : l = pt(e) ? t ? () => Wt(e, c, 2) : () => { if (!c || !c.isUnmounted) return u && u(), zt(e, c, 3, [h]) } : tt, t && r) { const e = l; l = () => Gn(e()) } let f, h = e => { u = _.onStop = () => { Wt(e, c, 4), u = _.onStop = void 0 } }; if (Os) { if (h = tt, t ? n && zt(t, c, 3, [l(), p ? [] : void 0, h]) : l(), "sync" !== o) return tt; { const e = Ns(); f = e.__watcherHandles || (e.__watcherHandles = []) } } let m = p ? new Array(e.length).fill(Bn) : Bn; const g = () => { if (_.active) if (t) { const e = _.run(); (r || d || (p ? e.some(((e, t) => Ot(e, m[t]))) : Ot(e, m))) && (u && u(), zt(t, c, 3, [e, m === Bn ? void 0 : p && m[0] === Bn ? [] : m, h]), m = e) } else _.run() }; let y; g.allowRecurse = !!t, "sync" === o ? y = g : "post" === o ? y = () => Io(g, c && c.suspense) : (g.pre = !0, c && (g.id = c.uid), y = () => on(g)); const _ = new $(l, y); t ? n ? g() : m = _.run() : "post" === o ? Io(_.run.bind(_), c && c.suspense) : _.run(); const v = () => { _.stop(), c && c.scope && it(c.scope.effects, _) }; return f && f.push(v), v } function Wn(e, t, n) { const r = this.proxy, o = ft(e) ? e.includes(".") ? zn(r, e) : () => r[e] : e.bind(r, r); let s; pt(t) ? s = t : (s = t.handler, n = t); const i = vs; Es(this); const a = Vn(o, s.bind(r), n); return i ? Es(i) : Ts(), a } function zn(e, t) { const n = t.split("."); return () => { let t = e; for (let e = 0; e < n.length && t; e++)t = t[n[e]]; return t } } function Gn(e, t) { if (!mt(e) || e.__v_skip) return e; if ((t = t || new Set).has(e)) return e; if (t.add(e), Fe(e)) Gn(e.value, t); else if (lt(e)) for (let n = 0; n < e.length; n++)Gn(e[n], t); else if (dt(e) || ut(e)) e.forEach((e => { Gn(e, t) })); else if (vt(e)) for (const n in e) Gn(e[n], t); return e } function Jn(e, t) { const n = gn; if (null === n) return e; const r = $s(n) || n.proxy, o = e.dirs || (e.dirs = []); for (let s = 0; s < t.length; s++) { let [e, n, i, a = Ze] = t[s]; e && (pt(e) && (e = { mounted: e, updated: e }), e.deep && Gn(n), o.push({ dir: e, instance: r, value: n, oldValue: void 0, arg: i, modifiers: a })) } return e } function Kn(e, t, n, r) { const o = e.dirs, s = t && t.dirs; for (let i = 0; i < o.length; i++) { const a = o[i]; s && (a.oldValue = s[i].value); let c = a.dir[r]; c && (D(), zt(c, n, 8, [e.el, a, e, t]), N()) } } const Yn = Symbol("_leaveCb"), Qn = Symbol("_enterCb"); const Xn = [Function, Array], Zn = { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: Xn, onEnter: Xn, onAfterEnter: Xn, onEnterCancelled: Xn, onBeforeLeave: Xn, onLeave: Xn, onAfterLeave: Xn, onLeaveCancelled: Xn, onBeforeAppear: Xn, onAppear: Xn, onAfterAppear: Xn, onAppearCancelled: Xn }, er = { name: "BaseTransition", props: Zn, setup(e, { slots: t }) { const n = bs(), r = function () { const e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map }; return Tr((() => { e.isMounted = !0 })), Or((() => { e.isUnmounting = !0 })), e }(); let o; return () => { const s = t.default && ar(t.default(), !0); if (!s || !s.length) return; let i = s[0]; if (s.length > 1) for (const e of s) if (e.type !== Vo) { i = e; break } const a = Pe(e), { mode: c } = a; if (r.isLeaving) return or(i); const l = sr(i); if (!l) return or(i); const u = rr(l, a, r, n); ir(l, u); const d = n.subTree, p = d && sr(d); let f = !1; const { getTransitionKey: h } = l.type; if (h) { const e = h(); void 0 === o ? o = e : e !== o && (o = e, f = !0) } if (p && p.type !== Vo && (!ns(l, p) || f)) { const e = rr(p, a, r, n); if (ir(p, e), "out-in" === c) return r.isLeaving = !0, e.afterLeave = () => { r.isLeaving = !1, !1 !== n.update.active && n.update() }, or(i); "in-out" === c && l.type !== Vo && (e.delayLeave = (e, t, n) => { nr(r, p)[String(p.key)] = p, e[Yn] = () => { t(), e[Yn] = void 0, delete u.delayedLeave }, u.delayedLeave = n }) } return i } } }, tr = er; function nr(e, t) { const { leavingVNodes: n } = e; let r = n.get(t.type); return r || (r = Object.create(null), n.set(t.type, r)), r } function rr(e, t, n, r) { const { appear: o, mode: s, persisted: i = !1, onBeforeEnter: a, onEnter: c, onAfterEnter: l, onEnterCancelled: u, onBeforeLeave: d, onLeave: p, onAfterLeave: f, onLeaveCancelled: h, onBeforeAppear: m, onAppear: g, onAfterAppear: y, onAppearCancelled: _ } = t, v = String(e.key), b = nr(n, e), w = (e, t) => { e && zt(e, r, 9, t) }, S = (e, t) => { const n = t[1]; w(e, t), lt(e) ? e.every((e => e.length <= 1)) && n() : e.length <= 1 && n() }, k = { mode: s, persisted: i, beforeEnter(t) { let r = a; if (!n.isMounted) { if (!o) return; r = m || a } t[Yn] && t[Yn](!0); const s = b[v]; s && ns(e, s) && s.el[Yn] && s.el[Yn](), w(r, [t]) }, enter(e) { let t = c, r = l, s = u; if (!n.isMounted) { if (!o) return; t = g || c, r = y || l, s = _ || u } let i = !1; const a = e[Qn] = t => { i || (i = !0, w(t ? s : r, [e]), k.delayedLeave && k.delayedLeave(), e[Qn] = void 0) }; t ? S(t, [e, a]) : a() }, leave(t, r) { const o = String(e.key); if (t[Qn] && t[Qn](!0), n.isUnmounting) return r(); w(d, [t]); let s = !1; const i = t[Yn] = n => { s || (s = !0, r(), w(n ? h : f, [t]), t[Yn] = void 0, b[o] === e && delete b[o]) }; b[o] = e, p ? S(p, [t, i]) : i() }, clone: e => rr(e, t, n, r) }; return k } function or(e) { if (pr(e)) return (e = cs(e)).children = null, e } function sr(e) { return pr(e) ? e.children ? e.children[0] : void 0 : e } function ir(e, t) { 6 & e.shapeFlag && e.component ? ir(e.component.subTree, t) : 128 & e.shapeFlag ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t } function ar(e, t = !1, n) { let r = [], o = 0; for (let s = 0; s < e.length; s++) { let i = e[s]; const a = null == n ? i.key : String(n) + String(null != i.key ? i.key : s); i.type === Bo ? (128 & i.patchFlag && o++, r = r.concat(ar(i.children, t, a))) : (t || i.type !== Vo) && r.push(null != a ? cs(i, { key: a }) : i) } if (o > 1) for (let s = 0; s < r.length; s++)r[s].patchFlag = -2; return r }
/*! #__NO_SIDE_EFFECTS__ */function cr(e, t) { return pt(e) ? (() => st({ name: e.name }, t, { setup: e }))() : e } const lr = e => !!e.type.__asyncLoader
/*! #__NO_SIDE_EFFECTS__ */; function ur(e) { pt(e) && (e = { loader: e }); const { loader: t, loadingComponent: n, errorComponent: r, delay: o = 200, timeout: s, suspensible: i = !0, onError: a } = e; let c, l = null, u = 0; const d = () => { let e; return l || (e = l = t().catch((e => { if (e = e instanceof Error ? e : new Error(String(e)), a) return new Promise(((t, n) => { a(e, (() => t((u++, l = null, d()))), (() => n(e)), u + 1) })); throw e })).then((t => e !== l && l ? l : (t && (t.__esModule || "Module" === t[Symbol.toStringTag]) && (t = t.default), c = t, t)))) }; return cr({ name: "AsyncComponentWrapper", __asyncLoader: d, get __asyncResolved() { return c }, setup() { const e = vs; if (c) return () => dr(c, e); const t = t => { l = null, Gt(t, e, 13, !r) }; if (i && e.suspense || Os) return d().then((t => () => dr(t, e))).catch((e => (t(e), () => r ? as(r, { error: e }) : null))); const a = Ue(!1), u = Ue(), p = Ue(!!o); return o && setTimeout((() => { p.value = !1 }), o), null != s && setTimeout((() => { if (!a.value && !u.value) { const e = new Error(`Async component timed out after ${s}ms.`); t(e), u.value = e } }), s), d().then((() => { a.value = !0, e.parent && pr(e.parent.vnode) && on(e.parent.update) })).catch((e => { t(e), u.value = e })), () => a.value && c ? dr(c, e) : u.value && r ? as(r, { error: u.value }) : n && !p.value ? as(n) : void 0 } }) } function dr(e, t) { const { ref: n, props: r, children: o, ce: s } = t.vnode, i = as(e, r, o); return i.ref = n, i.ce = s, delete t.vnode.ce, i } const pr = e => e.type.__isKeepAlive, fr = { name: "KeepAlive", __isKeepAlive: !0, props: { include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] }, setup(e, { slots: t }) { const n = bs(), r = n.ctx; if (!r.renderer) return () => { const e = t.default && t.default(); return e && 1 === e.length ? e[0] : e }; const o = new Map, s = new Set; let i = null; const a = n.suspense, { renderer: { p: c, m: l, um: u, o: { createElement: d } } } = r, p = d("div"); function f(e) { br(e), u(e, n, a, !0) } function h(e) { o.forEach(((t, n) => { const r = Ps(t.type); !r || e && e(r) || m(n) })) } function m(e) { const t = o.get(e); i && ns(t, i) ? i && br(i) : f(t), o.delete(e), s.delete(e) } r.activate = (e, t, n, r, o) => { const s = e.component; l(e, t, n, 0, a), c(s.vnode, e, t, n, s, a, r, e.slotScopeIds, o), Io((() => { s.isDeactivated = !1, s.a && At(s.a); const t = e.props && e.props.onVnodeMounted; t && gs(t, s.parent, e) }), a) }, r.deactivate = e => { const t = e.component; l(e, p, null, 1, a), Io((() => { t.da && At(t.da); const n = e.props && e.props.onVnodeUnmounted; n && gs(n, t.parent, e), t.isDeactivated = !0 }), a) }, qn((() => [e.include, e.exclude]), (([e, t]) => { e && h((t => mr(e, t))), t && h((e => !mr(t, e))) }), { flush: "post", deep: !0 }); let g = null; const y = () => { null != g && o.set(g, wr(n.subTree)) }; return Tr(y), Cr(y), Or((() => { o.forEach((e => { const { subTree: t, suspense: r } = n, o = wr(t); if (e.type !== o.type || e.key !== o.key) f(e); else { br(o); const e = o.component.da; e && Io(e, r) } })) })), () => { if (g = null, !t.default) return null; const n = t.default(), r = n[0]; if (n.length > 1) return i = null, n; if (!(ts(r) && (4 & r.shapeFlag || 128 & r.shapeFlag))) return i = null, r; let a = wr(r); const c = a.type, l = Ps(lr(a) ? a.type.__asyncResolved || {} : c), { include: u, exclude: d, max: p } = e; if (u && (!l || !mr(u, l)) || d && l && mr(d, l)) return i = a, r; const f = null == a.key ? c : a.key, h = o.get(f); return a.el && (a = cs(a), 128 & r.shapeFlag && (r.ssContent = a)), g = f, h ? (a.el = h.el, a.component = h.component, a.transition && ir(a, a.transition), a.shapeFlag |= 512, s.delete(f), s.add(f)) : (s.add(f), p && s.size > parseInt(p, 10) && m(s.values().next().value)), a.shapeFlag |= 256, i = a, jn(r.type) ? r : a } } }, hr = fr; function mr(e, t) { return lt(e) ? e.some((e => mr(e, t))) : ft(e) ? e.split(",").includes(t) : "[object RegExp]" === _t(e) && e.test(t) } function gr(e, t) { _r(e, "a", t) } function yr(e, t) { _r(e, "da", t) } function _r(e, t, n = vs) { const r = e.__wdc || (e.__wdc = () => { let t = n; for (; t;) { if (t.isDeactivated) return; t = t.parent } return e() }); if (Sr(t, r, n), n) { let e = n.parent; for (; e && e.parent;)pr(e.parent.vnode) && vr(r, t, n, e), e = e.parent } } function vr(e, t, n, r) { const o = Sr(t, e, r, !0); Ar((() => { it(r[t], o) }), n) } function br(e) { e.shapeFlag &= -257, e.shapeFlag &= -513 } function wr(e) { return 128 & e.shapeFlag ? e.ssContent : e } function Sr(e, t, n = vs, r = !1) { if (n) { const o = n[e] || (n[e] = []), s = t.__weh || (t.__weh = (...r) => { if (n.isUnmounted) return; D(), Es(n); const o = zt(t, n, e, r); return Ts(), N(), o }); return r ? o.unshift(s) : o.push(s), s } } const kr = e => (t, n = vs) => (!Os || "sp" === e) && Sr(e, ((...e) => t(...e)), n), Er = kr("bm"), Tr = kr("m"), xr = kr("bu"), Cr = kr("u"), Or = kr("bum"), Ar = kr("um"), Rr = kr("sp"), Ir = kr("rtg"), $r = kr("rtc"); function Pr(e, t = vs) { Sr("ec", e, t) } function jr(e, t, n, r) { let o; const s = n && n[r]; if (lt(e) || ft(e)) { o = new Array(e.length); for (let n = 0, r = e.length; n < r; n++)o[n] = t(e[n], n, void 0, s && s[n]) } else if ("number" == typeof e) { o = new Array(e); for (let n = 0; n < e; n++)o[n] = t(n + 1, n, void 0, s && s[n]) } else if (mt(e)) if (e[Symbol.iterator]) o = Array.from(e, ((e, n) => t(e, n, void 0, s && s[n]))); else { const n = Object.keys(e); o = new Array(n.length); for (let r = 0, i = n.length; r < i; r++) { const i = n[r]; o[r] = t(e[i], i, r, s && s[r]) } } else o = []; return n && (n[r] = o), o } function Lr(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; if (lt(r)) for (let t = 0; t < r.length; t++)e[r[t].name] = r[t].fn; else r && (e[r.name] = r.key ? (...e) => { const t = r.fn(...e); return t && (t.key = r.key), t } : r.fn) } return e } function Dr(e, t, n = {}, r, o) { if (gn.isCE || gn.parent && lr(gn.parent) && gn.parent.isCE) return "default" !== t && (n.name = t), as("slot", n, r && r()); let s = e[t]; s && s._c && (s._d = !1), Jo(); const i = s && Nr(s(n)), a = es(Bo, { key: n.key || i && i.key || `_${t}` }, i || (r ? r() : []), i && 1 === e._ ? 64 : -2); return !o && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), s && s._c && (s._d = !0), a } function Nr(e) { return e.some((e => !ts(e) || e.type !== Vo && !(e.type === Bo && !Nr(e.children)))) ? e : null } function Mr(e, t) { const n = {}; for (const r in e) n[t && /[A-Z]/.test(r) ? `on:${r}` : Ct(r)] = e[r]; return n } const Fr = e => e ? xs(e) ? $s(e) || e.proxy : Fr(e.parent) : null, Ur = st(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => Fr(e.parent), $root: e => Fr(e.root), $emit: e => e.emit, $options: e => Yr(e), $forceUpdate: e => e.f || (e.f = () => on(e.update)), $nextTick: e => e.n || (e.n = rn.bind(e.proxy)), $watch: e => Wn.bind(e) }), Hr = (e, t) => e !== Ze && !e.__isScriptSetup && ct(e, t), Br = { get({ _: e }, t) { const { ctx: n, setupState: r, data: o, props: s, accessCache: i, type: a, appContext: c } = e; let l; if ("$" !== t[0]) { const a = i[t]; if (void 0 !== a) switch (a) { case 1: return r[t]; case 2: return o[t]; case 4: return n[t]; case 3: return s[t] } else { if (Hr(r, t)) return i[t] = 1, r[t]; if (o !== Ze && ct(o, t)) return i[t] = 2, o[t]; if ((l = e.propsOptions[0]) && ct(l, t)) return i[t] = 3, s[t]; if (n !== Ze && ct(n, t)) return i[t] = 4, n[t]; zr && (i[t] = 0) } } const u = Ur[t]; let d, p; return u ? ("$attrs" === t && M(e, 0, t), u(e)) : (d = a.__cssModules) && (d = d[t]) ? d : n !== Ze && ct(n, t) ? (i[t] = 4, n[t]) : (p = c.config.globalProperties, ct(p, t) ? p[t] : void 0) }, set({ _: e }, t, n) { const { data: r, setupState: o, ctx: s } = e; return Hr(o, t) ? (o[t] = n, !0) : r !== Ze && ct(r, t) ? (r[t] = n, !0) : !ct(e.props, t) && (("$" !== t[0] || !(t.slice(1) in e)) && (s[t] = n, !0)) }, has({ _: { data: e, setupState: t, accessCache: n, ctx: r, appContext: o, propsOptions: s } }, i) { let a; return !!n[i] || e !== Ze && ct(e, i) || Hr(t, i) || (a = s[0]) && ct(a, i) || ct(r, i) || ct(Ur, i) || ct(o.config.globalProperties, i) }, defineProperty(e, t, n) { return null != n.get ? e._.accessCache[t] = 0 : ct(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n) } }; function qr() { return function () { const e = bs(); return e.setupContext || (e.setupContext = Is(e)) }().slots } function Vr(e) { return lt(e) ? e.reduce(((e, t) => (e[t] = null, e)), {}) : e } function Wr(e) { const t = bs(); let n = e(); return Ts(), gt(n) && (n = n.catch((e => { throw Es(t), e }))), [n, () => Es(t)] } let zr = !0; function Gr(e) { const t = Yr(e), n = e.proxy, r = e.ctx; zr = !1, t.beforeCreate && Jr(t.beforeCreate, e, "bc"); const { data: o, computed: s, methods: i, watch: a, provide: c, inject: l, created: u, beforeMount: d, mounted: p, beforeUpdate: f, updated: h, activated: m, deactivated: g, beforeDestroy: y, beforeUnmount: _, destroyed: v, unmounted: b, render: w, renderTracked: S, renderTriggered: k, errorCaptured: E, serverPrefetch: T, expose: x, inheritAttrs: C, components: O, directives: A, filters: R } = t; if (l && function (e, t, n = tt) { lt(e) && (e = eo(e)); for (const r in e) { const n = e[r]; let o; o = mt(n) ? "default" in n ? lo(n.from || r, n.default, !0) : lo(n.from || r) : lo(n), Fe(o) ? Object.defineProperty(t, r, { enumerable: !0, configurable: !0, get: () => o.value, set: e => o.value = e }) : t[r] = o } }(l, r, null), i) for (const $ in i) { const e = i[$]; pt(e) && (r[$] = e.bind(n)) } if (o) { const t = o.call(n, n); mt(t) && (e.data = Te(t)) } if (zr = !0, s) for (const $ in s) { const e = s[$], t = pt(e) ? e.bind(n, n) : pt(e.get) ? e.get.bind(n, n) : tt, o = !pt(e) && pt(e.set) ? e.set.bind(n) : tt, i = js({ get: t, set: o }); Object.defineProperty(r, $, { enumerable: !0, configurable: !0, get: () => i.value, set: e => i.value = e }) } if (a) for (const $ in a) Kr(a[$], r, n, $); if (c) { const e = pt(c) ? c.call(n) : c; Reflect.ownKeys(e).forEach((t => { co(t, e[t]) })) } function I(e, t) { lt(t) ? t.forEach((t => e(t.bind(n)))) : t && e(t.bind(n)) } if (u && Jr(u, e, "c"), I(Er, d), I(Tr, p), I(xr, f), I(Cr, h), I(gr, m), I(yr, g), I(Pr, E), I($r, S), I(Ir, k), I(Or, _), I(Ar, b), I(Rr, T), lt(x)) if (x.length) { const t = e.exposed || (e.exposed = {}); x.forEach((e => { Object.defineProperty(t, e, { get: () => n[e], set: t => n[e] = t }) })) } else e.exposed || (e.exposed = {}); w && e.render === tt && (e.render = w), null != C && (e.inheritAttrs = C), O && (e.components = O), A && (e.directives = A) } function Jr(e, t, n) { zt(lt(e) ? e.map((e => e.bind(t.proxy))) : e.bind(t.proxy), t, n) } function Kr(e, t, n, r) { const o = r.includes(".") ? zn(n, r) : () => n[r]; if (ft(e)) { const n = t[e]; pt(n) && qn(o, n) } else if (pt(e)) qn(o, e.bind(n)); else if (mt(e)) if (lt(e)) e.forEach((e => Kr(e, t, n, r))); else { const r = pt(e.handler) ? e.handler.bind(n) : t[e.handler]; pt(r) && qn(o, r, e) } } function Yr(e) { const t = e.type, { mixins: n, extends: r } = t, { mixins: o, optionsCache: s, config: { optionMergeStrategies: i } } = e.appContext, a = s.get(t); let c; return a ? c = a : o.length || n || r ? (c = {}, o.length && o.forEach((e => Qr(c, e, i, !0))), Qr(c, t, i)) : c = t, mt(t) && s.set(t, c), c } function Qr(e, t, n, r = !1) { const { mixins: o, extends: s } = t; s && Qr(e, s, n, !0), o && o.forEach((t => Qr(e, t, n, !0))); for (const i in t) if (r && "expose" === i); else { const r = Xr[i] || n && n[i]; e[i] = r ? r(e[i], t[i]) : t[i] } return e } const Xr = { data: Zr, props: ro, emits: ro, methods: no, computed: no, beforeCreate: to, created: to, beforeMount: to, mounted: to, beforeUpdate: to, updated: to, beforeDestroy: to, beforeUnmount: to, destroyed: to, unmounted: to, activated: to, deactivated: to, errorCaptured: to, serverPrefetch: to, components: no, directives: no, watch: function (e, t) { if (!e) return t; if (!t) return e; const n = st(Object.create(null), e); for (const r in t) n[r] = to(e[r], t[r]); return n }, provide: Zr, inject: function (e, t) { return no(eo(e), eo(t)) } }; function Zr(e, t) { return t ? e ? function () { return st(pt(e) ? e.call(this, this) : e, pt(t) ? t.call(this, this) : t) } : t : e } function eo(e) { if (lt(e)) { const t = {}; for (let n = 0; n < e.length; n++)t[e[n]] = e[n]; return t } return e } function to(e, t) { return e ? [...new Set([].concat(e, t))] : t } function no(e, t) { return e ? st(Object.create(null), e, t) : t } function ro(e, t) { return e ? lt(e) && lt(t) ? [...new Set([...e, ...t])] : st(Object.create(null), Vr(e), Vr(null != t ? t : {})) : t } function oo() { return { app: null, config: { isNativeTag: nt, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let so = 0; function io(e, t) { return function (n, r = null) { pt(n) || (n = st({}, n)), null == r || mt(r) || (r = null); const o = oo(), s = new WeakSet; let i = !1; const a = o.app = { _uid: so++, _component: n, _props: r, _container: null, _context: o, _instance: null, version: Ms, get config() { return o.config }, set config(e) { }, use: (e, ...t) => (s.has(e) || (e && pt(e.install) ? (s.add(e), e.install(a, ...t)) : pt(e) && (s.add(e), e(a, ...t))), a), mixin: e => (o.mixins.includes(e) || o.mixins.push(e), a), component: (e, t) => t ? (o.components[e] = t, a) : o.components[e], directive: (e, t) => t ? (o.directives[e] = t, a) : o.directives[e], mount(s, c, l) { if (!i) { const u = as(n, r); return u.appContext = o, c && t ? t(u, s) : e(u, s, l), i = !0, a._container = s, s.__vue_app__ = a, $s(u.component) || u.component.proxy } }, unmount() { i && (e(null, a._container), delete a._container.__vue_app__) }, provide: (e, t) => (o.provides[e] = t, a), runWithContext(e) { ao = a; try { return e() } finally { ao = null } } }; return a } } let ao = null; function co(e, t) { if (vs) { let n = vs.provides; const r = vs.parent && vs.parent.provides; r === n && (n = vs.provides = Object.create(r)), n[e] = t } else; } function lo(e, t, n = !1) { const r = vs || gn; if (r || ao) { const o = r ? null == r.parent ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : ao._context.provides; if (o && e in o) return o[e]; if (arguments.length > 1) return n && pt(t) ? t.call(r && r.proxy) : t } } function uo() { return !!(vs || gn || ao) } function po(e, t, n, r) { const [o, s] = e.propsOptions; let i, a = !1; if (t) for (let c in t) { if (bt(c)) continue; const l = t[c]; let u; o && ct(o, u = kt(c)) ? s && s.includes(u) ? (i || (i = {}))[u] = l : n[u] = l : mn(e.emitsOptions, c) || c in r && l === r[c] || (r[c] = l, a = !0) } if (s) { const t = Pe(n), r = i || Ze; for (let i = 0; i < s.length; i++) { const a = s[i]; n[a] = fo(o, t, a, r[a], e, !ct(r, a)) } } return a } function fo(e, t, n, r, o, s) { const i = e[n]; if (null != i) { const e = ct(i, "default"); if (e && void 0 === r) { const e = i.default; if (i.type !== Function && !i.skipFactory && pt(e)) { const { propsDefaults: s } = o; n in s ? r = s[n] : (Es(o), r = s[n] = e.call(null, t), Ts()) } else r = e } i[0] && (s && !e ? r = !1 : !i[1] || "" !== r && r !== Tt(n) || (r = !0)) } return r } function ho(e, t, n = !1) { const r = t.propsCache, o = r.get(e); if (o) return o; const s = e.props, i = {}, a = []; let c = !1; if (!pt(e)) { const r = e => { c = !0; const [n, r] = ho(e, t, !0); st(i, n), r && a.push(...r) }; !n && t.mixins.length && t.mixins.forEach(r), e.extends && r(e.extends), e.mixins && e.mixins.forEach(r) } if (!s && !c) return mt(e) && r.set(e, et), et; if (lt(s)) for (let u = 0; u < s.length; u++) { const e = kt(s[u]); mo(e) && (i[e] = Ze) } else if (s) for (const u in s) { const e = kt(u); if (mo(e)) { const t = s[u], n = i[e] = lt(t) || pt(t) ? { type: t } : st({}, t); if (n) { const t = _o(Boolean, n.type), r = _o(String, n.type); n[0] = t > -1, n[1] = r < 0 || t < r, (t > -1 || ct(n, "default")) && a.push(e) } } } const l = [i, a]; return mt(e) && r.set(e, l), l } function mo(e) { return "$" !== e[0] } function go(e) { const t = e && e.toString().match(/^\s*(function|class) (\w+)/); return t ? t[2] : null === e ? "null" : "" } function yo(e, t) { return go(e) === go(t) } function _o(e, t) { return lt(t) ? t.findIndex((t => yo(t, e))) : pt(t) && yo(t, e) ? 0 : -1 } const vo = e => "_" === e[0] || "$stable" === e, bo = e => lt(e) ? e.map(ps) : [ps(e)], wo = (e, t, n) => { if (t._n) return t; const r = Sn(((...e) => bo(t(...e))), n); return r._c = !1, r }, So = (e, t, n) => { const r = e._ctx; for (const o in e) { if (vo(o)) continue; const n = e[o]; if (pt(n)) t[o] = wo(0, n, r); else if (null != n) { const e = bo(n); t[o] = () => e } } }, ko = (e, t) => { const n = bo(t); e.slots.default = () => n }, Eo = (e, t) => { if (32 & e.vnode.shapeFlag) { const n = t._; n ? (e.slots = Pe(t), Rt(t, "_", n)) : So(t, e.slots = {}) } else e.slots = {}, t && ko(e, t); Rt(e.slots, rs, 1) }, To = (e, t, n) => { const { vnode: r, slots: o } = e; let s = !0, i = Ze; if (32 & r.shapeFlag) { const e = t._; e ? n && 1 === e ? s = !1 : (st(o, t), n || 1 !== e || delete o._) : (s = !t.$stable, So(t, o)), i = t } else t && (ko(e, t), i = { default: 1 }); if (s) for (const a in o) vo(a) || null != i[a] || delete o[a] }; function xo(e, t, n, r, o = !1) { if (lt(e)) return void e.forEach(((e, s) => xo(e, t && (lt(t) ? t[s] : t), n, r, o))); if (lr(r) && !o) return; const s = 4 & r.shapeFlag ? $s(r.component) || r.component.proxy : r.el, i = o ? null : s, { i: a, r: c } = e, l = t && t.r, u = a.refs === Ze ? a.refs = {} : a.refs, d = a.setupState; if (null != l && l !== c && (ft(l) ? (u[l] = null, ct(d, l) && (d[l] = null)) : Fe(l) && (l.value = null)), pt(c)) Wt(c, a, 12, [i, u]); else { const t = ft(c), r = Fe(c); if (t || r) { const a = () => { if (e.f) { const n = t ? ct(d, c) ? d[c] : u[c] : c.value; o ? lt(n) && it(n, s) : lt(n) ? n.includes(s) || n.push(s) : t ? (u[c] = [s], ct(d, c) && (d[c] = u[c])) : (c.value = [s], e.k && (u[e.k] = c.value)) } else t ? (u[c] = i, ct(d, c) && (d[c] = i)) : r && (c.value = i, e.k && (u[e.k] = i)) }; i ? (a.id = -1, Io(a, n)) : a() } } } let Co = !1; const Oo = e => /svg/.test(e.namespaceURI) && "foreignObject" !== e.tagName, Ao = e => 8 === e.nodeType; function Ro(e) { const { mt: t, p: n, o: { patchProp: r, createText: o, nextSibling: s, parentNode: i, remove: a, insert: c, createComment: l } } = e, u = (n, r, a, l, _, v = !1) => { const b = Ao(n) && "[" === n.data, w = () => h(n, r, a, l, _, b), { type: S, ref: k, shapeFlag: E, patchFlag: T } = r; let x = n.nodeType; r.el = n, -2 === T && (v = !1, r.dynamicChildren = null); let C = null; switch (S) { case qo: 3 !== x ? "" === r.children ? (c(r.el = o(""), i(n), n), C = n) : C = w() : (n.data !== r.children && (Co = !0, n.data = r.children), C = s(n)); break; case Vo: y(n) ? (C = s(n), g(r.el = n.content.firstChild, n, a)) : C = 8 !== x || b ? w() : s(n); break; case Wo: if (b && (x = (n = s(n)).nodeType), 1 === x || 3 === x) { C = n; const e = !r.children.length; for (let t = 0; t < r.staticCount; t++)e && (r.children += 1 === C.nodeType ? C.outerHTML : C.data), t === r.staticCount - 1 && (r.anchor = C), C = s(C); return b ? s(C) : C } w(); break; case Bo: C = b ? f(n, r, a, l, _, v) : w(); break; default: if (1 & E) C = 1 === x && r.type.toLowerCase() === n.tagName.toLowerCase() || y(n) ? d(n, r, a, l, _, v) : w(); else if (6 & E) { r.slotScopeIds = _; const e = i(n); if (C = b ? m(n) : Ao(n) && "teleport start" === n.data ? m(n, n.data, "teleport end") : s(n), t(r, e, null, a, l, Oo(e), v), lr(r)) { let t; b ? (t = as(Bo), t.anchor = C ? C.previousSibling : e.lastChild) : t = 3 === n.nodeType ? ls("") : as("div"), t.el = n, r.component.subTree = t } } else 64 & E ? C = 8 !== x ? w() : r.type.hydrate(n, r, a, l, _, v, e, p) : 128 & E && (C = r.type.hydrate(n, r, a, l, Oo(i(n)), _, v, e, u)) }return null != k && xo(k, null, l, r), C }, d = (e, t, n, o, s, i) => { i = i || !!t.dynamicChildren; const { type: c, props: l, patchFlag: u, shapeFlag: d, dirs: f, transition: h } = t, m = "input" === c || "option" === c; if (m || -1 !== u) { f && Kn(t, null, n, "created"); let c, _ = !1; if (y(e)) { _ = jo(o, h) && n && n.vnode.props && n.vnode.props.appear; const r = e.content.firstChild; _ && h.beforeEnter(r), g(r, e, n), t.el = e = r } if (l) if (m || !i || 48 & u) for (const t in l) (m && (t.endsWith("value") || "indeterminate" === t) || rt(t) && !bt(t) || "." === t[0]) && r(e, t, null, l[t], !1, void 0, n); else l.onClick && r(e, "onClick", null, l.onClick, !1, void 0, n); if ((c = l && l.onVnodeBeforeMount) && gs(c, n, t), f && Kn(t, null, n, "beforeMount"), ((c = l && l.onVnodeMounted) || f || _) && Fn((() => { c && gs(c, n, t), _ && h.enter(e), f && Kn(t, null, n, "mounted") }), o), 16 & d && (!l || !l.innerHTML && !l.textContent)) { let r = p(e.firstChild, t, e, n, o, s, i); for (; r;) { Co = !0; const e = r; r = r.nextSibling, a(e) } } else 8 & d && e.textContent !== t.children && (Co = !0, e.textContent = t.children) } return e.nextSibling }, p = (e, t, r, o, s, i, a) => { a = a || !!t.dynamicChildren; const c = t.children, l = c.length; for (let d = 0; d < l; d++) { const t = a ? c[d] : c[d] = ps(c[d]); if (e) e = u(e, t, o, s, i, a); else { if (t.type === qo && !t.children) continue; Co = !0, n(null, t, r, null, o, s, Oo(r), i) } } return e }, f = (e, t, n, r, o, a) => { const { slotScopeIds: u } = t; u && (o = o ? o.concat(u) : u); const d = i(e), f = p(s(e), t, d, n, r, o, a); return f && Ao(f) && "]" === f.data ? s(t.anchor = f) : (Co = !0, c(t.anchor = l("]"), d, f), f) }, h = (e, t, r, o, c, l) => { if (Co = !0, t.el = null, l) { const t = m(e); for (; ;) { const n = s(e); if (!n || n === t) break; a(n) } } const u = s(e), d = i(e); return a(e), n(null, t, d, u, r, o, Oo(d), c), u }, m = (e, t = "[", n = "]") => { let r = 0; for (; e;)if ((e = s(e)) && Ao(e) && (e.data === t && r++, e.data === n)) { if (0 === r) return s(e); r-- } return e }, g = (e, t, n) => { const r = t.parentNode; r && r.replaceChild(e, t); let o = n; for (; o;)o.vnode.el === t && (o.vnode.el = o.subTree.el = e), o = o.parent }, y = e => 1 === e.nodeType && "template" === e.tagName.toLowerCase(); return [(e, t) => { if (!t.hasChildNodes()) return n(null, e, t), ln(), void (t._vnode = e); Co = !1, u(t.firstChild, e, null, null, null), ln(), t._vnode = e, Co && console.error("Hydration completed but contains mismatches.") }, u] } const Io = Fn; function $o(e, t) { jt().__VUE__ = !0; const { insert: n, remove: r, patchProp: o, createElement: s, createText: i, createComment: a, setText: c, setElementText: l, parentNode: u, nextSibling: d, setScopeId: p = tt, insertStaticContent: f } = e, h = (e, t, n, r = null, o = null, s = null, i = !1, a = null, c = !!t.dynamicChildren) => { if (e === t) return; e && !ns(e, t) && (r = W(e), F(e, o, s, !0), e = null), -2 === t.patchFlag && (c = !1, t.dynamicChildren = null); const { type: l, ref: u, shapeFlag: d } = t; switch (l) { case qo: m(e, t, n, r); break; case Vo: g(e, t, n, r); break; case Wo: null == e && y(t, n, r, i); break; case Bo: x(e, t, n, r, o, s, i, a, c); break; default: 1 & d ? v(e, t, n, r, o, s, i, a, c) : 6 & d ? C(e, t, n, r, o, s, i, a, c) : (64 & d || 128 & d) && l.process(e, t, n, r, o, s, i, a, c, G) }null != u && o && xo(u, e && e.ref, s, t || e, !t) }, m = (e, t, r, o) => { if (null == e) n(t.el = i(t.children), r, o); else { const n = t.el = e.el; t.children !== e.children && c(n, t.children) } }, g = (e, t, r, o) => { null == e ? n(t.el = a(t.children || ""), r, o) : t.el = e.el }, y = (e, t, n, r) => { [e.el, e.anchor] = f(e.children, t, n, r, e.el, e.anchor) }, v = (e, t, n, r, o, s, i, a, c) => { i = i || "svg" === t.type, null == e ? b(t, n, r, o, s, i, a, c) : k(e, t, o, s, i, a, c) }, b = (e, t, r, i, a, c, u, d) => { let p, f; const { type: h, props: m, shapeFlag: g, transition: y, dirs: _ } = e; if (p = e.el = s(e.type, c, m && m.is, m), 8 & g ? l(p, e.children) : 16 & g && S(e.children, p, null, i, a, c && "foreignObject" !== h, u, d), _ && Kn(e, null, i, "created"), w(p, e, e.scopeId, u, i), m) { for (const t in m) "value" === t || bt(t) || o(p, t, null, m[t], c, e.children, i, a, V); "value" in m && o(p, "value", null, m.value), (f = m.onVnodeBeforeMount) && gs(f, i, e) } _ && Kn(e, null, i, "beforeMount"); const v = jo(a, y); v && y.beforeEnter(p), n(p, t, r), ((f = m && m.onVnodeMounted) || v || _) && Io((() => { f && gs(f, i, e), v && y.enter(p), _ && Kn(e, null, i, "mounted") }), a) }, w = (e, t, n, r, o) => { if (n && p(e, n), r) for (let s = 0; s < r.length; s++)p(e, r[s]); if (o) { if (t === o.subTree) { const t = o.vnode; w(e, t, t.scopeId, t.slotScopeIds, o.parent) } } }, S = (e, t, n, r, o, s, i, a, c = 0) => { for (let l = c; l < e.length; l++) { const c = e[l] = a ? fs(e[l]) : ps(e[l]); h(null, c, t, n, r, o, s, i, a) } }, k = (e, t, n, r, s, i, a) => { const c = t.el = e.el; let { patchFlag: u, dynamicChildren: d, dirs: p } = t; u |= 16 & e.patchFlag; const f = e.props || Ze, h = t.props || Ze; let m; n && Po(n, !1), (m = h.onVnodeBeforeUpdate) && gs(m, n, t, e), p && Kn(t, e, n, "beforeUpdate"), n && Po(n, !0); const g = s && "foreignObject" !== t.type; if (d ? E(e.dynamicChildren, d, c, n, r, g, i) : a || P(e, t, c, null, n, r, g, i, !1), u > 0) { if (16 & u) T(c, t, f, h, n, r, s); else if (2 & u && f.class !== h.class && o(c, "class", null, h.class, s), 4 & u && o(c, "style", f.style, h.style, s), 8 & u) { const i = t.dynamicProps; for (let t = 0; t < i.length; t++) { const a = i[t], l = f[a], u = h[a]; u === l && "value" !== a || o(c, a, l, u, s, e.children, n, r, V) } } 1 & u && e.children !== t.children && l(c, t.children) } else a || null != d || T(c, t, f, h, n, r, s); ((m = h.onVnodeUpdated) || p) && Io((() => { m && gs(m, n, t, e), p && Kn(t, e, n, "updated") }), r) }, E = (e, t, n, r, o, s, i) => { for (let a = 0; a < t.length; a++) { const c = e[a], l = t[a], d = c.el && (c.type === Bo || !ns(c, l) || 70 & c.shapeFlag) ? u(c.el) : n; h(c, l, d, null, r, o, s, i, !0) } }, T = (e, t, n, r, s, i, a) => { if (n !== r) { if (n !== Ze) for (const c in n) bt(c) || c in r || o(e, c, n[c], null, a, t.children, s, i, V); for (const c in r) { if (bt(c)) continue; const l = r[c], u = n[c]; l !== u && "value" !== c && o(e, c, u, l, a, t.children, s, i, V) } "value" in r && o(e, "value", n.value, r.value) } }, x = (e, t, r, o, s, a, c, l, u) => { const d = t.el = e ? e.el : i(""), p = t.anchor = e ? e.anchor : i(""); let { patchFlag: f, dynamicChildren: h, slotScopeIds: m } = t; m && (l = l ? l.concat(m) : m), null == e ? (n(d, r, o), n(p, r, o), S(t.children, r, p, s, a, c, l, u)) : f > 0 && 64 & f && h && e.dynamicChildren ? (E(e.dynamicChildren, h, r, s, a, c, l), (null != t.key || s && t === s.subTree) && Lo(e, t, !0)) : P(e, t, r, p, s, a, c, l, u) }, C = (e, t, n, r, o, s, i, a, c) => { t.slotScopeIds = a, null == e ? 512 & t.shapeFlag ? o.ctx.activate(t, n, r, i, c) : O(t, n, r, o, s, i, c) : A(e, t, c) }, O = (e, t, n, r, o, s, i) => { const a = e.component = function (e, t, n) { const r = e.type, o = (t ? t.appContext : e.appContext) || ys, s = { uid: _s++, vnode: e, type: r, parent: t, appContext: o, root: null, next: null, subTree: null, effect: null, update: null, scope: new _(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(o.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: ho(r, o), emitsOptions: hn(r, o), emit: null, emitted: null, propsDefaults: Ze, inheritAttrs: r.inheritAttrs, ctx: Ze, data: Ze, props: Ze, attrs: Ze, slots: Ze, refs: Ze, setupState: Ze, setupContext: null, attrsProxy: null, slotsProxy: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; s.ctx = { _: s }, s.root = t ? t.root : s, s.emit = fn.bind(null, s), e.ce && e.ce(s); return s }(e, r, o); if (pr(e) && (a.ctx.renderer = G), function (e, t = !1) { Os = t; const { props: n, children: r } = e.vnode, o = xs(e); (function (e, t, n, r = !1) { const o = {}, s = {}; Rt(s, rs, 1), e.propsDefaults = Object.create(null), po(e, t, o, s); for (const i in e.propsOptions[0]) i in o || (o[i] = void 0); n ? e.props = r ? o : xe(o) : e.type.props ? e.props = o : e.props = s, e.attrs = s })(e, n, o, t), Eo(e, r); const s = o ? function (e, t) { const n = e.type; e.accessCache = Object.create(null), e.proxy = je(new Proxy(e.ctx, Br)); const { setup: r } = n; if (r) { const n = e.setupContext = r.length > 1 ? Is(e) : null; Es(e), D(); const o = Wt(r, e, 0, [e.props, n]); if (N(), Ts(), gt(o)) { if (o.then(Ts, Ts), t) return o.then((n => { As(e, n, t) })).catch((t => { Gt(t, e, 0) })); e.asyncDep = o } else As(e, o, t) } else Rs(e, t) }(e, t) : void 0; Os = !1 }(a), a.asyncDep) { if (o && o.registerDep(a, R), !e.el) { const e = a.subTree = as(Vo); g(null, e, t, n) } } else R(a, e, t, n, o, s, i) }, A = (e, t, n) => { const r = t.component = e.component; if (function (e, t, n) { const { props: r, children: o, component: s } = e, { props: i, children: a, patchFlag: c } = t, l = s.emitsOptions; if (t.dirs || t.transition) return !0; if (!(n && c >= 0)) return !(!o && !a || a && a.$stable) || r !== i && (r ? !i || xn(r, i, l) : !!i); if (1024 & c) return !0; if (16 & c) return r ? xn(r, i, l) : !!i; if (8 & c) { const e = t.dynamicProps; for (let t = 0; t < e.length; t++) { const n = e[t]; if (i[n] !== r[n] && !mn(l, n)) return !0 } } return !1 }(e, t, n)) { if (r.asyncDep && !r.asyncResolved) return void I(r, t, n); r.next = t, function (e) { const t = Yt.indexOf(e); t > Qt && Yt.splice(t, 1) }(r.update), r.update() } else t.el = e.el, r.vnode = t }, R = (e, t, n, r, o, s, i) => { const a = e.effect = new $((() => { if (e.isMounted) { let t, { next: n, bu: r, u: a, parent: c, vnode: l } = e, d = n; Po(e, !1), n ? (n.el = l.el, I(e, n, i)) : n = l, r && At(r), (t = n.props && n.props.onVnodeBeforeUpdate) && gs(t, c, n, l), Po(e, !0); const p = kn(e), f = e.subTree; e.subTree = p, h(f, p, u(f.el), W(f), e, o, s), n.el = p.el, null === d && Cn(e, p.el), a && Io(a, o), (t = n.props && n.props.onVnodeUpdated) && Io((() => gs(t, c, n, l)), o) } else { let i; const { el: a, props: c } = t, { bm: l, m: u, parent: d } = e, p = lr(t); if (Po(e, !1), l && At(l), !p && (i = c && c.onVnodeBeforeMount) && gs(i, d, t), Po(e, !0), a && K) { const n = () => { e.subTree = kn(e), K(a, e.subTree, e, o, null) }; p ? t.type.__asyncLoader().then((() => !e.isUnmounted && n())) : n() } else { const i = e.subTree = kn(e); h(null, i, n, r, e, o, s), t.el = i.el } if (u && Io(u, o), !p && (i = c && c.onVnodeMounted)) { const e = t; Io((() => gs(i, d, e)), o) } (256 & t.shapeFlag || d && lr(d.vnode) && 256 & d.vnode.shapeFlag) && e.a && Io(e.a, o), e.isMounted = !0, t = n = r = null } }), (() => on(c)), e.scope), c = e.update = () => a.run(); c.id = e.uid, Po(e, !0), c() }, I = (e, t, n) => { t.component = e; const r = e.vnode.props; e.vnode = t, e.next = null, function (e, t, n, r) { const { props: o, attrs: s, vnode: { patchFlag: i } } = e, a = Pe(o), [c] = e.propsOptions; let l = !1; if (!(r || i > 0) || 16 & i) { let r; po(e, t, o, s) && (l = !0); for (const s in a) t && (ct(t, s) || (r = Tt(s)) !== s && ct(t, r)) || (c ? !n || void 0 === n[s] && void 0 === n[r] || (o[s] = fo(c, a, s, void 0, e, !0)) : delete o[s]); if (s !== a) for (const e in s) t && ct(t, e) || (delete s[e], l = !0) } else if (8 & i) { const n = e.vnode.dynamicProps; for (let r = 0; r < n.length; r++) { let i = n[r]; if (mn(e.emitsOptions, i)) continue; const u = t[i]; if (c) if (ct(s, i)) u !== s[i] && (s[i] = u, l = !0); else { const t = kt(i); o[t] = fo(c, a, t, u, e, !1) } else u !== s[i] && (s[i] = u, l = !0) } } l && U(e, "set", "$attrs") }(e, t.props, r, n), To(e, t.children, n), D(), cn(e), N() }, P = (e, t, n, r, o, s, i, a, c = !1) => { const u = e && e.children, d = e ? e.shapeFlag : 0, p = t.children, { patchFlag: f, shapeFlag: h } = t; if (f > 0) { if (128 & f) return void L(u, p, n, r, o, s, i, a, c); if (256 & f) return void j(u, p, n, r, o, s, i, a, c) } 8 & h ? (16 & d && V(u, o, s), p !== u && l(n, p)) : 16 & d ? 16 & h ? L(u, p, n, r, o, s, i, a, c) : V(u, o, s, !0) : (8 & d && l(n, ""), 16 & h && S(p, n, r, o, s, i, a, c)) }, j = (e, t, n, r, o, s, i, a, c) => { t = t || et; const l = (e = e || et).length, u = t.length, d = Math.min(l, u); let p; for (p = 0; p < d; p++) { const r = t[p] = c ? fs(t[p]) : ps(t[p]); h(e[p], r, n, null, o, s, i, a, c) } l > u ? V(e, o, s, !0, !1, d) : S(t, n, r, o, s, i, a, c, d) }, L = (e, t, n, r, o, s, i, a, c) => { let l = 0; const u = t.length; let d = e.length - 1, p = u - 1; for (; l <= d && l <= p;) { const r = e[l], u = t[l] = c ? fs(t[l]) : ps(t[l]); if (!ns(r, u)) break; h(r, u, n, null, o, s, i, a, c), l++ } for (; l <= d && l <= p;) { const r = e[d], l = t[p] = c ? fs(t[p]) : ps(t[p]); if (!ns(r, l)) break; h(r, l, n, null, o, s, i, a, c), d--, p-- } if (l > d) { if (l <= p) { const e = p + 1, d = e < u ? t[e].el : r; for (; l <= p;)h(null, t[l] = c ? fs(t[l]) : ps(t[l]), n, d, o, s, i, a, c), l++ } } else if (l > p) for (; l <= d;)F(e[l], o, s, !0), l++; else { const f = l, m = l, g = new Map; for (l = m; l <= p; l++) { const e = t[l] = c ? fs(t[l]) : ps(t[l]); null != e.key && g.set(e.key, l) } let y, _ = 0; const v = p - m + 1; let b = !1, w = 0; const S = new Array(v); for (l = 0; l < v; l++)S[l] = 0; for (l = f; l <= d; l++) { const r = e[l]; if (_ >= v) { F(r, o, s, !0); continue } let u; if (null != r.key) u = g.get(r.key); else for (y = m; y <= p; y++)if (0 === S[y - m] && ns(r, t[y])) { u = y; break } void 0 === u ? F(r, o, s, !0) : (S[u - m] = l + 1, u >= w ? w = u : b = !0, h(r, t[u], n, null, o, s, i, a, c), _++) } const k = b ? function (e) { const t = e.slice(), n = [0]; let r, o, s, i, a; const c = e.length; for (r = 0; r < c; r++) { const c = e[r]; if (0 !== c) { if (o = n[n.length - 1], e[o] < c) { t[r] = o, n.push(r); continue } for (s = 0, i = n.length - 1; s < i;)a = s + i >> 1, e[n[a]] < c ? s = a + 1 : i = a; c < e[n[s]] && (s > 0 && (t[r] = n[s - 1]), n[s] = r) } } s = n.length, i = n[s - 1]; for (; s-- > 0;)n[s] = i, i = t[i]; return n }(S) : et; for (y = k.length - 1, l = v - 1; l >= 0; l--) { const e = m + l, d = t[e], p = e + 1 < u ? t[e + 1].el : r; 0 === S[l] ? h(null, d, n, p, o, s, i, a, c) : b && (y < 0 || l !== k[y] ? M(d, n, p, 2) : y--) } } }, M = (e, t, r, o, s = null) => { const { el: i, type: a, transition: c, children: l, shapeFlag: u } = e; if (6 & u) return void M(e.component.subTree, t, r, o); if (128 & u) return void e.suspense.move(t, r, o); if (64 & u) return void a.move(e, t, r, G); if (a === Bo) { n(i, t, r); for (let e = 0; e < l.length; e++)M(l[e], t, r, o); return void n(e.anchor, t, r) } if (a === Wo) return void (({ el: e, anchor: t }, r, o) => { let s; for (; e && e !== t;)s = d(e), n(e, r, o), e = s; n(t, r, o) })(e, t, r); if (2 !== o && 1 & u && c) if (0 === o) c.beforeEnter(i), n(i, t, r), Io((() => c.enter(i)), s); else { const { leave: e, delayLeave: o, afterLeave: s } = c, a = () => n(i, t, r), l = () => { e(i, (() => { a(), s && s() })) }; o ? o(i, a, l) : l() } else n(i, t, r) }, F = (e, t, n, r = !1, o = !1) => { const { type: s, props: i, ref: a, children: c, dynamicChildren: l, shapeFlag: u, patchFlag: d, dirs: p } = e; if (null != a && xo(a, null, n, e, !0), 256 & u) return void t.ctx.deactivate(e); const f = 1 & u && p, h = !lr(e); let m; if (h && (m = i && i.onVnodeBeforeUnmount) && gs(m, t, e), 6 & u) q(e.component, n, r); else { if (128 & u) return void e.suspense.unmount(n, r); f && Kn(e, null, t, "beforeUnmount"), 64 & u ? e.type.remove(e, t, n, o, G, r) : l && (s !== Bo || d > 0 && 64 & d) ? V(l, t, n, !1, !0) : (s === Bo && 384 & d || !o && 16 & u) && V(c, t, n), r && H(e) } (h && (m = i && i.onVnodeUnmounted) || f) && Io((() => { m && gs(m, t, e), f && Kn(e, null, t, "unmounted") }), n) }, H = e => { const { type: t, el: n, anchor: o, transition: s } = e; if (t === Bo) return void B(n, o); if (t === Wo) return void (({ el: e, anchor: t }) => { let n; for (; e && e !== t;)n = d(e), r(e), e = n; r(t) })(e); const i = () => { r(n), s && !s.persisted && s.afterLeave && s.afterLeave() }; if (1 & e.shapeFlag && s && !s.persisted) { const { leave: t, delayLeave: r } = s, o = () => t(n, i); r ? r(e.el, i, o) : o() } else i() }, B = (e, t) => { let n; for (; e !== t;)n = d(e), r(e), e = n; r(t) }, q = (e, t, n) => { const { bum: r, scope: o, update: s, subTree: i, um: a } = e; r && At(r), o.stop(), s && (s.active = !1, F(i, e, t, n)), a && Io(a, t), Io((() => { e.isUnmounted = !0 }), t), t && t.pendingBranch && !t.isUnmounted && e.asyncDep && !e.asyncResolved && e.suspenseId === t.pendingId && (t.deps--, 0 === t.deps && t.resolve()) }, V = (e, t, n, r = !1, o = !1, s = 0) => { for (let i = s; i < e.length; i++)F(e[i], t, n, r, o) }, W = e => 6 & e.shapeFlag ? W(e.component.subTree) : 128 & e.shapeFlag ? e.suspense.next() : d(e.anchor || e.el), z = (e, t, n) => { null == e ? t._vnode && F(t._vnode, null, null, !0) : h(t._vnode || null, e, t, null, null, null, n), cn(), ln(), t._vnode = e }, G = { p: h, um: F, m: M, r: H, mt: O, mc: S, pc: P, pbc: E, n: W, o: e }; let J, K; return t && ([J, K] = t(G)), { render: z, hydrate: J, createApp: io(z, J) } } function Po({ effect: e, update: t }, n) { e.allowRecurse = t.allowRecurse = n } function jo(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted } function Lo(e, t, n = !1) { const r = e.children, o = t.children; if (lt(r) && lt(o)) for (let s = 0; s < r.length; s++) { const e = r[s]; let t = o[s]; 1 & t.shapeFlag && !t.dynamicChildren && ((t.patchFlag <= 0 || 32 === t.patchFlag) && (t = o[s] = fs(o[s]), t.el = e.el), n || Lo(e, t)), t.type === qo && (t.el = e.el) } } const Do = e => e && (e.disabled || "" === e.disabled), No = e => "undefined" != typeof SVGElement && e instanceof SVGElement, Mo = (e, t) => { const n = e && e.to; if (ft(n)) { if (t) { return t(n) } return null } return n }; function Fo(e, t, n, { o: { insert: r }, m: o }, s = 2) { 0 === s && r(e.targetAnchor, t, n); const { el: i, anchor: a, shapeFlag: c, children: l, props: u } = e, d = 2 === s; if (d && r(i, t, n), (!d || Do(u)) && 16 & c) for (let p = 0; p < l.length; p++)o(l[p], t, n, 2); d && r(a, t, n) } const Uo = { name: "Teleport", __isTeleport: !0, process(e, t, n, r, o, s, i, a, c, l) { const { mc: u, pc: d, pbc: p, o: { insert: f, querySelector: h, createText: m, createComment: g } } = l, y = Do(t.props); let { shapeFlag: _, children: v, dynamicChildren: b } = t; if (null == e) { const e = t.el = m(""), l = t.anchor = m(""); f(e, n, r), f(l, n, r); const d = t.target = Mo(t.props, h), p = t.targetAnchor = m(""); d && (f(p, d), i = i || No(d)); const g = (e, t) => { 16 & _ && u(v, e, t, o, s, i, a, c) }; y ? g(n, l) : d && g(d, p) } else { t.el = e.el; const r = t.anchor = e.anchor, u = t.target = e.target, f = t.targetAnchor = e.targetAnchor, m = Do(e.props), g = m ? n : u, _ = m ? r : f; if (i = i || No(u), b ? (p(e.dynamicChildren, b, g, o, s, i, a), Lo(e, t, !0)) : c || d(e, t, g, _, o, s, i, a, !1), y) m ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : Fo(t, n, r, l, 1); else if ((t.props && t.props.to) !== (e.props && e.props.to)) { const e = t.target = Mo(t.props, h); e && Fo(t, e, null, l, 0) } else m && Fo(t, u, f, l, 1) } Ho(t) }, remove(e, t, n, r, { um: o, o: { remove: s } }, i) { const { shapeFlag: a, children: c, anchor: l, targetAnchor: u, target: d, props: p } = e; if (d && s(u), i && s(l), 16 & a) { const e = i || !Do(p); for (let r = 0; r < c.length; r++) { const s = c[r]; o(s, t, n, e, !!s.dynamicChildren) } } }, move: Fo, hydrate: function (e, t, n, r, o, s, { o: { nextSibling: i, parentNode: a, querySelector: c } }, l) { const u = t.target = Mo(t.props, c); if (u) { const c = u._lpa || u.firstChild; if (16 & t.shapeFlag) if (Do(t.props)) t.anchor = l(i(e), t, a(e), n, r, o, s), t.targetAnchor = c; else { t.anchor = i(e); let a = c; for (; a;)if (a = i(a), a && 8 === a.nodeType && "teleport anchor" === a.data) { t.targetAnchor = a, u._lpa = t.targetAnchor && i(t.targetAnchor); break } l(c, t, u, n, r, o, s) } Ho(t) } return t.anchor && i(t.anchor) } }; function Ho(e) { const t = e.ctx; if (t && t.ut) { let n = e.children[0].el; for (; n && n !== e.targetAnchor;)1 === n.nodeType && n.setAttribute("data-v-owner", t.uid), n = n.nextSibling; t.ut() } } const Bo = Symbol.for("v-fgt"), qo = Symbol.for("v-txt"), Vo = Symbol.for("v-cmt"), Wo = Symbol.for("v-stc"), zo = []; let Go = null; function Jo(e = !1) { zo.push(Go = e ? null : []) } function Ko() { zo.pop(), Go = zo[zo.length - 1] || null } let Yo = 1; function Qo(e) { Yo += e } function Xo(e) { return e.dynamicChildren = Yo > 0 ? Go || et : null, Ko(), Yo > 0 && Go && Go.push(e), e } function Zo(e, t, n, r, o, s) { return Xo(is(e, t, n, r, o, s, !0)) } function es(e, t, n, r, o) { return Xo(as(e, t, n, r, o, !0)) } function ts(e) { return !!e && !0 === e.__v_isVNode } function ns(e, t) { return e.type === t.type && e.key === t.key } const rs = "__vInternal", os = ({ key: e }) => null != e ? e : null, ss = ({ ref: e, ref_key: t, ref_for: n }) => ("number" == typeof e && (e = "" + e), null != e ? ft(e) || Fe(e) || pt(e) ? { i: gn, r: e, k: t, f: !!n } : e : null); function is(e, t = null, n = null, r = 0, o = null, s = (e === Bo ? 0 : 1), i = !1, a = !1) { const c = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && os(t), ref: t && ss(t), scopeId: yn, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag: s, patchFlag: r, dynamicProps: o, dynamicChildren: null, appContext: null, ctx: gn }; return a ? (hs(c, n), 128 & s && e.normalize(c)) : n && (c.shapeFlag |= ft(n) ? 8 : 16), Yo > 0 && !i && Go && (c.patchFlag > 0 || 6 & s) && 32 !== c.patchFlag && Go.push(c), c } const as = function (e, t = null, n = null, r = 0, o = null, s = !1) { e && e !== Rn || (e = Vo); if (ts(e)) { const r = cs(e, t, !0); return n && hs(r, n), Yo > 0 && !s && Go && (6 & r.shapeFlag ? Go[Go.indexOf(e)] = r : Go.push(r)), r.patchFlag |= -2, r } i = e, pt(i) && "__vccOpts" in i && (e = e.__vccOpts); var i; if (t) { t = function (e) { return e ? $e(e) || rs in e ? st({}, e) : e : null }(t); let { class: e, style: n } = t; e && !ft(e) && (t.class = Ut(e)), mt(n) && ($e(n) && !lt(n) && (n = st({}, n)), t.style = Lt(n)) } const a = ft(e) ? 1 : jn(e) ? 128 : (e => e.__isTeleport)(e) ? 64 : mt(e) ? 4 : pt(e) ? 2 : 0; return is(e, t, n, r, o, a, s, !0) }; function cs(e, t, n = !1) { const { props: r, ref: o, patchFlag: s, children: i } = e, a = t ? ms(r || {}, t) : r; return { __v_isVNode: !0, __v_skip: !0, type: e.type, props: a, key: a && os(a), ref: t && t.ref ? n && o ? lt(o) ? o.concat(ss(t)) : [o, ss(t)] : ss(t) : o, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: i, target: e.target, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== Bo ? -1 === s ? 16 : 16 | s : s, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: e.transition, component: e.component, suspense: e.suspense, ssContent: e.ssContent && cs(e.ssContent), ssFallback: e.ssFallback && cs(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce } } function ls(e = " ", t = 0) { return as(qo, null, e, t) } function us(e, t) { const n = as(Wo, null, e); return n.staticCount = t, n } function ds(e = "", t = !1) { return t ? (Jo(), es(Vo, null, e)) : as(Vo, null, e) } function ps(e) { return null == e || "boolean" == typeof e ? as(Vo) : lt(e) ? as(Bo, null, e.slice()) : "object" == typeof e ? fs(e) : as(qo, null, String(e)) } function fs(e) { return null === e.el && -1 !== e.patchFlag || e.memo ? e : cs(e) } function hs(e, t) { let n = 0; const { shapeFlag: r } = e; if (null == t) t = null; else if (lt(t)) n = 16; else if ("object" == typeof t) { if (65 & r) { const n = t.default; return void (n && (n._c && (n._d = !1), hs(e, n()), n._c && (n._d = !0))) } { n = 32; const r = t._; r || rs in t ? 3 === r && gn && (1 === gn.slots._ ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) : t._ctx = gn } } else pt(t) ? (t = { default: t, _ctx: gn }, n = 32) : (t = String(t), 64 & r ? (n = 16, t = [ls(t)]) : n = 8); e.children = t, e.shapeFlag |= n } function ms(...e) { const t = {}; for (let n = 0; n < e.length; n++) { const r = e[n]; for (const e in r) if ("class" === e) t.class !== r.class && (t.class = Ut([t.class, r.class])); else if ("style" === e) t.style = Lt([t.style, r.style]); else if (rt(e)) { const n = t[e], o = r[e]; !o || n === o || lt(n) && n.includes(o) || (t[e] = n ? [].concat(n, o) : o) } else "" !== e && (t[e] = r[e]) } return t } function gs(e, t, n, r = null) { zt(e, t, 7, [n, r]) } const ys = oo(); let _s = 0; let vs = null; const bs = () => vs || gn; let ws, Ss, ks = "__VUE_INSTANCE_SETTERS__"; (Ss = jt()[ks]) || (Ss = jt()[ks] = []), Ss.push((e => vs = e)), ws = e => { Ss.length > 1 ? Ss.forEach((t => t(e))) : Ss[0](e) }; const Es = e => { ws(e), e.scope.on() }, Ts = () => { vs && vs.scope.off(), ws(null) }; function xs(e) { return 4 & e.vnode.shapeFlag } let Cs, Os = !1; function As(e, t, n) { pt(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : mt(t) && (e.setupState = ze(t)), Rs(e, n) } function Rs(e, t, n) { const r = e.type; if (!e.render) { if (!t && Cs && !r.render) { const t = r.template || Yr(e).template; if (t) { const { isCustomElement: n, compilerOptions: o } = e.appContext.config, { delimiters: s, compilerOptions: i } = r, a = st(st({ isCustomElement: n, delimiters: s }, o), i); r.render = Cs(t, a) } } e.render = r.render || tt } Es(e), D(); try { Gr(e) } finally { N(), Ts() } } function Is(e) { const t = t => { e.exposed = t || {} }; return { get attrs() { return function (e) { return e.attrsProxy || (e.attrsProxy = new Proxy(e.attrs, { get: (t, n) => (M(e, 0, "$attrs"), t[n]) })) }(e) }, slots: e.slots, emit: e.emit, expose: t } } function $s(e) { if (e.exposed) return e.exposeProxy || (e.exposeProxy = new Proxy(ze(je(e.exposed)), { get: (t, n) => n in t ? t[n] : n in Ur ? Ur[n](e) : void 0, has: (e, t) => t in e || t in Ur })) } function Ps(e, t = !0) { return pt(e) ? e.displayName || e.name : e.name || t && e.__name } const js = (e, t) => function (e, t, n = !1) { let o, s; const i = c(e); return i ? (o = e, s = r) : (o = e.get, s = e.set), new Qe(o, s, i || !s, n) }(e, 0, Os); function Ls(e, t, n) { const r = arguments.length; return 2 === r ? mt(t) && !lt(t) ? ts(t) ? as(e, null, [t]) : as(e, t) : as(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : 3 === r && ts(n) && (n = [n]), as(e, t, n)) } const Ds = Symbol.for("v-scx"), Ns = () => lo(Ds), Ms = "3.3.13"; function Fs(e, t) { const n = Object.create(null), r = e.split(","); for (let o = 0; o < r.length; o++)n[r[o]] = !0; return t ? e => !!n[e.toLowerCase()] : e => !!n[e] } const Us = Object.assign, Hs = Array.isArray, Bs = e => "[object Set]" === Ks(e), qs = e => "[object Date]" === Ks(e), Vs = e => "function" == typeof e, Ws = e => "string" == typeof e, zs = e => "symbol" == typeof e, Gs = e => null !== e && "object" == typeof e, Js = Object.prototype.toString, Ks = e => Js.call(e), Ys = e => { const t = Object.create(null); return n => t[n] || (t[n] = e(n)) }, Qs = /\B([A-Z])/g, Xs = Ys((e => e.replace(Qs, "-$1").toLowerCase())), Zs = Ys((e => e.charAt(0).toUpperCase() + e.slice(1))), ei = e => { const t = parseFloat(e); return isNaN(t) ? e : t }, ti = e => { const t = Ws(e) ? Number(e) : NaN; return isNaN(t) ? e : t }, ni = Fs("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"); function ri(e) { return !!e || "" === e } function oi(e, t) { if (e === t) return !0; let n = qs(e), r = qs(t); if (n || r) return !(!n || !r) && e.getTime() === t.getTime(); if (n = zs(e), r = zs(t), n || r) return e === t; if (n = Hs(e), r = Hs(t), n || r) return !(!n || !r) && function (e, t) { if (e.length !== t.length) return !1; let n = !0; for (let r = 0; n && r < e.length; r++)n = oi(e[r], t[r]); return n }(e, t); if (n = Gs(e), r = Gs(t), n || r) { if (!n || !r) return !1; if (Object.keys(e).length !== Object.keys(t).length) return !1; for (const n in e) { const r = e.hasOwnProperty(n), o = t.hasOwnProperty(n); if (r && !o || !r && o || !oi(e[n], t[n])) return !1 } } return String(e) === String(t) } function si(e, t) { return e.findIndex((e => oi(e, t))) } const ii = "undefined" != typeof document ? document : null, ai = ii && ii.createElement("template"), ci = { insert: (e, t, n) => { t.insertBefore(e, n || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, n, r) => { const o = t ? ii.createElementNS("http://www.w3.org/2000/svg", e) : ii.createElement(e, n ? { is: n } : void 0); return "select" === e && r && null != r.multiple && o.setAttribute("multiple", r.multiple), o }, createText: e => ii.createTextNode(e), createComment: e => ii.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => ii.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, n, r, o, s) { const i = n ? n.previousSibling : t.lastChild; if (o && (o === s || o.nextSibling)) for (; t.insertBefore(o.cloneNode(!0), n), o !== s && (o = o.nextSibling);); else { ai.innerHTML = r ? `<svg>${e}</svg>` : e; const o = ai.content; if (r) { const e = o.firstChild; for (; e.firstChild;)o.appendChild(e.firstChild); o.removeChild(e) } t.insertBefore(o, n) } return [i ? i.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild] } }, li = "transition", ui = "animation", di = Symbol("_vtc"), pi = (e, { slots: t }) => Ls(tr, function (e) { const t = {}; for (const O in e) O in fi || (t[O] = e[O]); if (!1 === e.css) return t; const { name: n = "v", type: r, duration: o, enterFromClass: s = `${n}-enter-from`, enterActiveClass: i = `${n}-enter-active`, enterToClass: a = `${n}-enter-to`, appearFromClass: c = s, appearActiveClass: l = i, appearToClass: u = a, leaveFromClass: d = `${n}-leave-from`, leaveActiveClass: p = `${n}-leave-active`, leaveToClass: f = `${n}-leave-to` } = e, h = function (e) { if (null == e) return null; if (Gs(e)) return [gi(e.enter), gi(e.leave)]; { const t = gi(e); return [t, t] } }(o), m = h && h[0], g = h && h[1], { onBeforeEnter: y, onEnter: _, onEnterCancelled: v, onLeave: b, onLeaveCancelled: w, onBeforeAppear: S = y, onAppear: k = _, onAppearCancelled: E = v } = t, T = (e, t, n) => { _i(e, t ? u : a), _i(e, t ? l : i), n && n() }, x = (e, t) => { e._isLeaving = !1, _i(e, d), _i(e, f), _i(e, p), t && t() }, C = e => (t, n) => { const o = e ? k : _, i = () => T(t, e, n); hi(o, [t, i]), vi((() => { _i(t, e ? c : s), yi(t, e ? u : a), mi(o) || wi(t, r, m, i) })) }; return Us(t, { onBeforeEnter(e) { hi(y, [e]), yi(e, s), yi(e, i) }, onBeforeAppear(e) { hi(S, [e]), yi(e, c), yi(e, l) }, onEnter: C(!1), onAppear: C(!0), onLeave(e, t) { e._isLeaving = !0; const n = () => x(e, t); yi(e, d), document.body.offsetHeight, yi(e, p), vi((() => { e._isLeaving && (_i(e, d), yi(e, f), mi(b) || wi(e, r, g, n)) })), hi(b, [e, n]) }, onEnterCancelled(e) { T(e, !1), hi(v, [e]) }, onAppearCancelled(e) { T(e, !0), hi(E, [e]) }, onLeaveCancelled(e) { x(e), hi(w, [e]) } }) }(e), t); pi.displayName = "Transition"; const fi = { name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }; pi.props = Us({}, Zn, fi); const hi = (e, t = []) => { Hs(e) ? e.forEach((e => e(...t))) : e && e(...t) }, mi = e => !!e && (Hs(e) ? e.some((e => e.length > 1)) : e.length > 1); function gi(e) { return ti(e) } function yi(e, t) { t.split(/\s+/).forEach((t => t && e.classList.add(t))), (e[di] || (e[di] = new Set)).add(t) } function _i(e, t) { t.split(/\s+/).forEach((t => t && e.classList.remove(t))); const n = e[di]; n && (n.delete(t), n.size || (e[di] = void 0)) } function vi(e) { requestAnimationFrame((() => { requestAnimationFrame(e) })) } let bi = 0; function wi(e, t, n, r) { const o = e._endId = ++bi, s = () => { o === e._endId && r() }; if (n) return setTimeout(s, n); const { type: i, timeout: a, propCount: c } = function (e, t) { const n = window.getComputedStyle(e), r = e => (n[e] || "").split(", "), o = r(`${li}Delay`), s = r(`${li}Duration`), i = Si(o, s), a = r(`${ui}Delay`), c = r(`${ui}Duration`), l = Si(a, c); let u = null, d = 0, p = 0; t === li ? i > 0 && (u = li, d = i, p = s.length) : t === ui ? l > 0 && (u = ui, d = l, p = c.length) : (d = Math.max(i, l), u = d > 0 ? i > l ? li : ui : null, p = u ? u === li ? s.length : c.length : 0); const f = u === li && /\b(transform|all)(,|$)/.test(r(`${li}Property`).toString()); return { type: u, timeout: d, propCount: p, hasTransform: f } }(e, t); if (!i) return r(); const l = i + "end"; let u = 0; const d = () => { e.removeEventListener(l, p), s() }, p = t => { t.target === e && ++u >= c && d() }; setTimeout((() => { u < c && d() }), a + 1), e.addEventListener(l, p) } function Si(e, t) { for (; e.length < t.length;)e = e.concat(e); return Math.max(...t.map(((t, n) => ki(t) + ki(e[n])))) } function ki(e) { return "auto" === e ? 0 : 1e3 * Number(e.slice(0, -1).replace(",", ".")) } const Ei = Symbol("_vod"), Ti = { beforeMount(e, { value: t }, { transition: n }) { e[Ei] = "none" === e.style.display ? "" : e.style.display, n && t ? n.beforeEnter(e) : xi(e, t) }, mounted(e, { value: t }, { transition: n }) { n && t && n.enter(e) }, updated(e, { value: t, oldValue: n }, { transition: r }) { !t != !n && (r ? t ? (r.beforeEnter(e), xi(e, !0), r.enter(e)) : r.leave(e, (() => { xi(e, !1) })) : xi(e, t)) }, beforeUnmount(e, { value: t }) { xi(e, t) } }; function xi(e, t) { e.style.display = t ? e[Ei] : "none" } const Ci = Symbol(""); const Oi = /\s*!important$/; function Ai(e, t, n) { if (Hs(n)) n.forEach((n => Ai(e, t, n))); else if (null == n && (n = ""), t.startsWith("--")) e.setProperty(t, n); else { const r = function (e, t) { const n = Ii[t]; if (n) return n; let r = kt(t); if ("filter" !== r && r in e) return Ii[t] = r; r = Zs(r); for (let o = 0; o < Ri.length; o++) { const n = Ri[o] + r; if (n in e) return Ii[t] = n } return t }(e, t); Oi.test(n) ? e.setProperty(Xs(r), n.replace(Oi, ""), "important") : e[r] = n } } const Ri = ["Webkit", "Moz", "ms"], Ii = {}; const $i = "http://www.w3.org/1999/xlink"; function Pi(e, t, n, r) { e.addEventListener(t, n, r) } const ji = Symbol("_vei"); function Li(e, t, n, r, o = null) { const s = e[ji] || (e[ji] = {}), i = s[t]; if (r && i) i.value = r; else { const [n, a] = function (e) { let t; if (Di.test(e)) { let n; for (t = {}; n = e.match(Di);)e = e.slice(0, e.length - n[0].length), t[n[0].toLowerCase()] = !0 } const n = ":" === e[2] ? e.slice(3) : Xs(e.slice(2)); return [n, t] }(t); if (r) { const i = s[t] = function (e, t) { const n = e => { if (e._vts) { if (e._vts <= n.attached) return } else e._vts = Date.now(); zt(function (e, t) { if (Hs(t)) { const n = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { n.call(e), e._stopped = !0 }, t.map((e => t => !t._stopped && e && e(t))) } return t }(e, n.value), t, 5, [e]) }; return n.value = e, n.attached = Fi(), n }(r, o); Pi(e, n, i, a) } else i && (!function (e, t, n, r) { e.removeEventListener(t, n, r) }(e, n, i, a), s[t] = void 0) } } const Di = /(?:Once|Passive|Capture)$/; let Ni = 0; const Mi = Promise.resolve(), Fi = () => Ni || (Mi.then((() => Ni = 0)), Ni = Date.now()); const Ui = e => 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123; const Hi = e => { const t = e.props["onUpdate:modelValue"] || !1; return Hs(t) ? e => ((e, t) => { for (let n = 0; n < e.length; n++)e[n](t) })(t, e) : t }; function Bi(e) { e.target.composing = !0 } function qi(e) { const t = e.target; t.composing && (t.composing = !1, t.dispatchEvent(new Event("input"))) } const Vi = Symbol("_assign"), Wi = { created(e, { modifiers: { lazy: t, trim: n, number: r } }, o) { e[Vi] = Hi(o); const s = r || o.props && "number" === o.props.type; Pi(e, t ? "change" : "input", (t => { if (t.target.composing) return; let r = e.value; n && (r = r.trim()), s && (r = ei(r)), e[Vi](r) })), n && Pi(e, "change", (() => { e.value = e.value.trim() })), t || (Pi(e, "compositionstart", Bi), Pi(e, "compositionend", qi), Pi(e, "change", qi)) }, mounted(e, { value: t }) { e.value = null == t ? "" : t }, beforeUpdate(e, { value: t, modifiers: { lazy: n, trim: r, number: o } }, s) { if (e[Vi] = Hi(s), e.composing) return; const i = null == t ? "" : t; if ((o || "number" === e.type ? ei(e.value) : e.value) !== i) { if (document.activeElement === e && "range" !== e.type) { if (n) return; if (r && e.value.trim() === i) return } e.value = i } } }, zi = { deep: !0, created(e, t, n) { e[Vi] = Hi(n), Pi(e, "change", (() => { const t = e._modelValue, n = function (e) { return "_value" in e ? e._value : e.value }(e), r = e.checked, o = e[Vi]; if (Hs(t)) { const e = si(t, n), s = -1 !== e; if (r && !s) o(t.concat(n)); else if (!r && s) { const n = [...t]; n.splice(e, 1), o(n) } } else if (Bs(t)) { const e = new Set(t); r ? e.add(n) : e.delete(n), o(e) } else o(Ji(e, r)) })) }, mounted: Gi, beforeUpdate(e, t, n) { e[Vi] = Hi(n), Gi(e, t, n) } }; function Gi(e, { value: t, oldValue: n }, r) { e._modelValue = t, Hs(t) ? e.checked = si(t, r.props.value) > -1 : Bs(t) ? e.checked = t.has(r.props.value) : t !== n && (e.checked = oi(t, Ji(e, !0))) } function Ji(e, t) { const n = t ? "_trueValue" : "_falseValue"; return n in e ? e[n] : t } const Ki = ["ctrl", "shift", "alt", "meta"], Yi = { stop: e => e.stopPropagation(), prevent: e => e.preventDefault(), self: e => e.target !== e.currentTarget, ctrl: e => !e.ctrlKey, shift: e => !e.shiftKey, alt: e => !e.altKey, meta: e => !e.metaKey, left: e => "button" in e && 0 !== e.button, middle: e => "button" in e && 1 !== e.button, right: e => "button" in e && 2 !== e.button, exact: (e, t) => Ki.some((n => e[`${n}Key`] && !t.includes(n))) }, Qi = (e, t) => { const n = e._withMods || (e._withMods = {}), r = t.join("."); return n[r] || (n[r] = (n, ...r) => { for (let e = 0; e < t.length; e++) { const r = Yi[t[e]]; if (r && r(n, t)) return } return e(n, ...r) }) }, Xi = { esc: "escape", space: " ", up: "arrow-up", left: "arrow-left", right: "arrow-right", down: "arrow-down", delete: "backspace" }, Zi = (e, t) => { const n = e._withKeys || (e._withKeys = {}), r = t.join("."); return n[r] || (n[r] = n => { if (!("key" in n)) return; const r = Xs(n.key); return t.some((e => e === r || Xi[e] === r)) ? e(n) : void 0 }) }, ea = Us({ patchProp: (e, t, n, r, o = !1, s, i, a, c) => { "class" === t ? function (e, t, n) { const r = e[di]; r && (t = (t ? [t, ...r] : [...r]).join(" ")), null == t ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t }(e, r, o) : "style" === t ? function (e, t, n) { const r = e.style, o = Ws(n); if (n && !o) { if (t && !Ws(t)) for (const e in t) null == n[e] && Ai(r, e, ""); for (const e in n) Ai(r, e, n[e]) } else { const s = r.display; if (o) { if (t !== n) { const e = r[Ci]; e && (n += ";" + e), r.cssText = n } } else t && e.removeAttribute("style"); Ei in e && (r.display = s) } }(e, n, r) : (e => 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97))(t) ? (e => e.startsWith("onUpdate:"))(t) || Li(e, t, 0, r, i) : ("." === t[0] ? (t = t.slice(1), 1) : "^" === t[0] ? (t = t.slice(1), 0) : function (e, t, n, r) { if (r) return "innerHTML" === t || "textContent" === t || !!(t in e && Ui(t) && Vs(n)); if ("spellcheck" === t || "draggable" === t || "translate" === t) return !1; if ("form" === t) return !1; if ("list" === t && "INPUT" === e.tagName) return !1; if ("type" === t && "TEXTAREA" === e.tagName) return !1; if ("width" === t || "height" === t) { const t = e.tagName; if ("IMG" === t || "VIDEO" === t || "CANVAS" === t || "SOURCE" === t) return !1 } if (Ui(t) && Ws(n)) return !1; return t in e }(e, t, r, o)) ? function (e, t, n, r, o, s, i) { if ("innerHTML" === t || "textContent" === t) return r && i(r, o, s), void (e[t] = null == n ? "" : n); const a = e.tagName; if ("value" === t && "PROGRESS" !== a && !a.includes("-")) { e._value = n; const r = null == n ? "" : n; return ("OPTION" === a ? e.getAttribute("value") : e.value) !== r && (e.value = r), void (null == n && e.removeAttribute(t)) } let c = !1; if ("" === n || null == n) { const r = typeof e[t]; "boolean" === r ? n = ri(n) : null == n && "string" === r ? (n = "", c = !0) : "number" === r && (n = 0, c = !0) } try { e[t] = n } catch (l) { } c && e.removeAttribute(t) }(e, t, r, s, i, a, c) : ("true-value" === t ? e._trueValue = r : "false-value" === t && (e._falseValue = r), function (e, t, n, r, o) { if (r && t.startsWith("xlink:")) null == n ? e.removeAttributeNS($i, t.slice(6, t.length)) : e.setAttributeNS($i, t, n); else { const r = ni(t); null == n || r && !ri(n) ? e.removeAttribute(t) : e.setAttribute(t, r ? "" : n) } }(e, t, r, o)) } }, ci); let ta, na = !1; function ra() { return ta || (ta = $o(ea)) } function oa() { return ta = na ? ta : $o(ea, Ro), na = !0, ta } function sa(e) { if (Ws(e)) { return document.querySelector(e) } return e } const ia = /#/g, aa = /&/g, ca = /\//g, la = /=/g, ua = /\?/g, da = /\+/g, pa = /%5e/gi, fa = /%60/gi, ha = /%7c/gi, ma = /%20/gi, ga = /%252f/gi; function ya(e) { return encodeURI("" + e).replace(ha, "|") } function _a(e) { return ya("string" == typeof e ? e : JSON.stringify(e)).replace(da, "%2B").replace(ma, "+").replace(ia, "%23").replace(aa, "%26").replace(fa, "`").replace(pa, "^").replace(ca, "%2F") } function va(e) { return _a(e).replace(la, "%3D") } function ba(e) { return ya(e).replace(ia, "%23").replace(ua, "%3F").replace(ga, "%2F").replace(aa, "%26").replace(da, "%2B") } function wa(e) { return ba(e).replace(ca, "%2F") } function Sa(e = "") { try { return decodeURIComponent("" + e) } catch { return "" + e } } function ka(e) { return Sa(e.replace(da, " ")) } function Ea(e = "") { const t = {}; "?" === e[0] && (e = e.slice(1)); for (const n of e.split("&")) { const e = n.match(/([^=]+)=?(.*)/) || []; if (e.length < 2) continue; const r = Sa(e[1].replace(da, " ")); if ("__proto__" === r || "constructor" === r) continue; const o = ka(e[2] || ""); void 0 === t[r] ? t[r] = o : Array.isArray(t[r]) ? t[r].push(o) : t[r] = [t[r], o] } return t } function Ta(e) { return Object.keys(e).filter((t => void 0 !== e[t])).map((t => { return n = t, "number" != typeof (r = e[t]) && "boolean" != typeof r || (r = String(r)), r ? Array.isArray(r) ? r.map((e => `${va(n)}=${_a(e)}`)).join("&") : `${va(n)}=${_a(r)}` : va(n); var n, r })).filter(Boolean).join("&") } const xa = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/, Ca = /^[\s\w\0+.-]{2,}:([/\\]{2})?/, Oa = /^([/\\]\s*){2,}[^/\\]/, Aa = /^[\s\0]*(blob|data|javascript|vbscript):$/i, Ra = /\/$|\/\?|\/#/, Ia = /^\.?\//; function $a(e, t = {}) { return "boolean" == typeof t && (t = { acceptRelative: t }), t.strict ? xa.test(e) : Ca.test(e) || !!t.acceptRelative && Oa.test(e) } function Pa(e = "", t) { return t ? Ra.test(e) : e.endsWith("/") } function ja(e = "", t) { if (!t) return (Pa(e) ? e.slice(0, -1) : e) || "/"; if (!Pa(e, !0)) return e || "/"; let n = e, r = ""; const o = e.indexOf("#"); o >= 0 && (n = e.slice(0, o), r = e.slice(o)); const [s, ...i] = n.split("?"); return ((s.endsWith("/") ? s.slice(0, -1) : s) || "/") + (i.length > 0 ? `?${i.join("?")}` : "") + r } function La(e = "", t) { if (!t) return e.endsWith("/") ? e : e + "/"; if (Pa(e, !0)) return e || "/"; let n = e, r = ""; const o = e.indexOf("#"); if (o >= 0 && (n = e.slice(0, o), r = e.slice(o), !n)) return r; const [s, ...i] = n.split("?"); return s + "/" + (i.length > 0 ? `?${i.join("?")}` : "") + r } function Da(e = "") { return function (e = "") { return e.startsWith("/") }(e) ? e : "/" + e } function Na(e, t) { if (Fa(t)) return e; const n = ja(t); if (!e.startsWith(n)) return e; const r = e.slice(n.length); return "/" === r[0] ? r : "/" + r } function Ma(e, t) { const n = Ba(e), r = { ...Ea(n.search), ...t }; return n.search = Ta(r), function (e) { const t = e.pathname || "", n = e.search ? (e.search.startsWith("?") ? "" : "?") + e.search : "", r = e.hash || "", o = e.auth ? e.auth + "@" : "", s = e.host || "", i = e.protocol || e[Ha] ? (e.protocol || "") + "//" : ""; return i + o + s + t + n + r }(n) } function Fa(e) { return !e || "/" === e } function Ua(e, ...t) { let n = e || ""; for (const r of t.filter((e => function (e) { return e && "/" !== e }(e)))) if (n) { const e = r.replace(Ia, ""); n = La(n) + e } else n = r; return n } const Ha = Symbol.for("ufo:protocolRelative"); function Ba(e = "", t) { const n = e.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i); if (n) { const [, e, t = ""] = n; return { protocol: e.toLowerCase(), pathname: t, href: e + t, auth: "", host: "", search: "", hash: "" } } if (!$a(e, { acceptRelative: !0 })) return t ? Ba(t + e) : qa(e); const [, r = "", o, s = ""] = e.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [], [, i = "", a = ""] = s.match(/([^#/?]*)(.*)?/) || [], { pathname: c, search: l, hash: u } = qa(a.replace(/\/(?=[A-Za-z]:)/, "")); return { protocol: r.toLowerCase(), auth: o ? o.slice(0, Math.max(0, o.length - 1)) : "", host: i, pathname: c, search: l, hash: u, [Ha]: !r } } function qa(e = "") { const [t = "", n = "", r = ""] = (e.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1); return { pathname: t, search: n, hash: r } } const Va = ((null == (Wa = null == window ? void 0 : window.__NUXT__) ? void 0 : Wa.config) || {}).app; var Wa; const za = (...e) => Ua(Ga(), Va.buildAssetsDir, ...e), Ga = (...e) => { const t = Va.cdnURL || Va.baseURL; return e.length ? Ua(t, ...e) : t }; globalThis.__buildAssetsURL = za, globalThis.__publicAssetsURL = Ga; const Ja = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, Ka = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, Ya = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/; function Qa(e, t) { if (!("__proto__" === e || "constructor" === e && t && "object" == typeof t && "prototype" in t)) return t; !function (e) { console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`) }(e) } function Xa(e, t = {}) { if ("string" != typeof e) return e; const n = e.trim(); if ('"' === e[0] && e.endsWith('"') && !e.includes("\\")) return n.slice(1, -1); if (n.length <= 9) { const e = n.toLowerCase(); if ("true" === e) return !0; if ("false" === e) return !1; if ("undefined" === e) return; if ("null" === e) return null; if ("nan" === e) return Number.NaN; if ("infinity" === e) return Number.POSITIVE_INFINITY; if ("-infinity" === e) return Number.NEGATIVE_INFINITY } if (!Ya.test(e)) { if (t.strict) throw new SyntaxError("[destr] Invalid JSON"); return e } try { if (Ja.test(e) || Ka.test(e)) { if (t.strict) throw new Error("[destr] Possible prototype pollution"); return JSON.parse(e, Qa) } return JSON.parse(e) } catch (r) { if (t.strict) throw r; return e } } class Za extends Error { constructor(e, t) { super(e, t), this.name = "FetchError", (null == t ? void 0 : t.cause) && !this.cause && (this.cause = t.cause) } } const ec = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"])); function tc(e = "GET") { return ec.has(e.toUpperCase()) } const nc = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"]), rc = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i; function oc(e, t, n = globalThis.Headers) { const r = { ...t, ...e }; if ((null == t ? void 0 : t.params) && (null == e ? void 0 : e.params) && (r.params = { ...null == t ? void 0 : t.params, ...null == e ? void 0 : e.params }), (null == t ? void 0 : t.query) && (null == e ? void 0 : e.query) && (r.query = { ...null == t ? void 0 : t.query, ...null == e ? void 0 : e.query }), (null == t ? void 0 : t.headers) && (null == e ? void 0 : e.headers)) { r.headers = new n((null == t ? void 0 : t.headers) || {}); for (const [t, o] of new n((null == e ? void 0 : e.headers) || {})) r.headers.set(t, o) } return r } const sc = new Set([408, 409, 425, 429, 500, 502, 503, 504]), ic = new Set([101, 204, 205, 304]); const ac = function () { if ("undefined" != typeof globalThis) return globalThis; if ("undefined" != typeof self) return self; if ("undefined" != typeof window) return window; if ("undefined" != typeof global) return global; throw new Error("unable to locate global object") }(), cc = function e(t = {}) { const { fetch: n = globalThis.fetch, Headers: r = globalThis.Headers, AbortController: o = globalThis.AbortController } = t; async function s(e) { const t = e.error && "AbortError" === e.error.name && !e.options.timeout || !1; if (!1 !== e.options.retry && !t) { let t; t = "number" == typeof e.options.retry ? e.options.retry : tc(e.options.method) ? 0 : 1; const n = e.response && e.response.status || 500; if (t > 0 && (Array.isArray(e.options.retryStatusCodes) ? e.options.retryStatusCodes.includes(n) : sc.has(n))) { const n = e.options.retryDelay || 0; return n > 0 && await new Promise((e => setTimeout(e, n))), i(e.request, { ...e.options, retry: t - 1 }) } } const n = function (e) { var t, n, r, o, s; const i = (null == (t = e.error) ? void 0 : t.message) || (null == (n = e.error) ? void 0 : n.toString()) || "", a = (null == (r = e.request) ? void 0 : r.method) || (null == (o = e.options) ? void 0 : o.method) || "GET", c = (null == (s = e.request) ? void 0 : s.url) || String(e.request) || "/", l = `[${a}] ${JSON.stringify(c)}`, u = e.response ? `${e.response.status} ${e.response.statusText}` : "<no response>", d = new Za(`${l}: ${u}${i ? ` ${i}` : ""}`, e.error ? { cause: e.error } : void 0); for (const p of ["request", "options", "response"]) Object.defineProperty(d, p, { get: () => e[p] }); for (const [p, f] of [["data", "_data"], ["status", "status"], ["statusCode", "status"], ["statusText", "statusText"], ["statusMessage", "statusText"]]) Object.defineProperty(d, p, { get: () => e.response && e.response[f] }); return d }(e); throw Error.captureStackTrace && Error.captureStackTrace(n, i), n } const i = async function (e, i = {}) { var a; const c = { request: e, options: oc(i, t.defaults, r), response: void 0, error: void 0 }; let l; if (c.options.method = null == (a = c.options.method) ? void 0 : a.toUpperCase(), c.options.onRequest && await c.options.onRequest(c), "string" == typeof c.request && (c.options.baseURL && (c.request = function (e, t) { if (Fa(t) || $a(e)) return e; const n = ja(t); return e.startsWith(n) ? e : Ua(n, e) }(c.request, c.options.baseURL)), (c.options.query || c.options.params) && (c.request = Ma(c.request, { ...c.options.params, ...c.options.query }))), c.options.body && tc(c.options.method) && (!function (e) { if (void 0 === e) return !1; const t = typeof e; return "string" === t || "number" === t || "boolean" === t || null === t || "object" === t && (!!Array.isArray(e) || !e.buffer && (e.constructor && "Object" === e.constructor.name || "function" == typeof e.toJSON)) }(c.options.body) ? ("pipeTo" in c.options.body && "function" == typeof c.options.body.pipeTo || "function" == typeof c.options.body.pipe) && ("duplex" in c.options || (c.options.duplex = "half")) : (c.options.body = "string" == typeof c.options.body ? c.options.body : JSON.stringify(c.options.body), c.options.headers = new r(c.options.headers || {}), c.options.headers.has("content-type") || c.options.headers.set("content-type", "application/json"), c.options.headers.has("accept") || c.options.headers.set("accept", "application/json"))), !c.options.signal && c.options.timeout) { const e = new o; l = setTimeout((() => e.abort()), c.options.timeout), c.options.signal = e.signal } try { c.response = await n(c.request, c.options) } catch (u) { return c.error = u, c.options.onRequestError && await c.options.onRequestError(c), await s(c) } finally { l && clearTimeout(l) } if (c.response.body && !ic.has(c.response.status) && "HEAD" !== c.options.method) { const e = (c.options.parseResponse ? "json" : c.options.responseType) || function (e = "") { if (!e) return "json"; const t = e.split(";").shift() || ""; return rc.test(t) ? "json" : nc.has(t) || t.startsWith("text/") ? "text" : "blob" }(c.response.headers.get("content-type") || ""); switch (e) { case "json": { const e = await c.response.text(), t = c.options.parseResponse || Xa; c.response._data = t(e); break } case "stream": c.response._data = c.response.body; break; default: c.response._data = await c.response[e]() } } return c.options.onResponse && await c.options.onResponse(c), !c.options.ignoreResponseError && c.response.status >= 400 && c.response.status < 600 ? (c.options.onResponseError && await c.options.onResponseError(c), await s(c)) : c.response }, a = async function (e, t) { return (await i(e, t))._data }; return a.raw = i, a.native = (...e) => n(...e), a.create = (n = {}) => e({ ...t, defaults: { ...t.defaults, ...n } }), a }({ fetch: ac.fetch || (() => Promise.reject(new Error("[ofetch] global.fetch is not supported!"))), Headers: ac.Headers, AbortController: ac.AbortController }), lc = cc; function uc(e, t = {}, n) { for (const r in e) { const o = e[r], s = n ? `${n}:${r}` : r; "object" == typeof o && null !== o ? uc(o, t, s) : "function" == typeof o && (t[s] = o) } return t } globalThis.$fetch || (globalThis.$fetch = lc.create({ baseURL: Va.baseURL })); const dc = { run: e => e() }, pc = void 0 !== console.createTask ? console.createTask : () => dc; function fc(e, t) { const n = t.shift(), r = pc(n); return e.reduce(((e, n) => e.then((() => r.run((() => n(...t)))))), Promise.resolve()) } function hc(e, t) { const n = t.shift(), r = pc(n); return Promise.all(e.map((e => r.run((() => e(...t)))))) } function mc(e, t) { for (const n of [...e]) n(t) } class gc { constructor() { this._hooks = {}, this._before = void 0, this._after = void 0, this._deprecatedMessages = void 0, this._deprecatedHooks = {}, this.hook = this.hook.bind(this), this.callHook = this.callHook.bind(this), this.callHookWith = this.callHookWith.bind(this) } hook(e, t, n = {}) { if (!e || "function" != typeof t) return () => { }; const r = e; let o; for (; this._deprecatedHooks[e];)o = this._deprecatedHooks[e], e = o.to; if (o && !n.allowDeprecated) { let e = o.message; e || (e = `${r} hook has been deprecated` + (o.to ? `, please use ${o.to}` : "")), this._deprecatedMessages || (this._deprecatedMessages = new Set), this._deprecatedMessages.has(e) || (console.warn(e), this._deprecatedMessages.add(e)) } if (!t.name) try { Object.defineProperty(t, "name", { get: () => "_" + e.replace(/\W+/g, "_") + "_hook_cb", configurable: !0 }) } catch { } return this._hooks[e] = this._hooks[e] || [], this._hooks[e].push(t), () => { t && (this.removeHook(e, t), t = void 0) } } hookOnce(e, t) { let n, r = (...e) => ("function" == typeof n && n(), n = void 0, r = void 0, t(...e)); return n = this.hook(e, r), n } removeHook(e, t) { if (this._hooks[e]) { const n = this._hooks[e].indexOf(t); -1 !== n && this._hooks[e].splice(n, 1), 0 === this._hooks[e].length && delete this._hooks[e] } } deprecateHook(e, t) { this._deprecatedHooks[e] = "string" == typeof t ? { to: t } : t; const n = this._hooks[e] || []; delete this._hooks[e]; for (const r of n) this.hook(e, r) } deprecateHooks(e) { Object.assign(this._deprecatedHooks, e); for (const t in e) this.deprecateHook(t, e[t]) } addHooks(e) { const t = uc(e), n = Object.keys(t).map((e => this.hook(e, t[e]))); return () => { for (const e of n.splice(0, n.length)) e() } } removeHooks(e) { const t = uc(e); for (const n in t) this.removeHook(n, t[n]) } removeAllHooks() { for (const e in this._hooks) delete this._hooks[e] } callHook(e, ...t) { return t.unshift(e), this.callHookWith(fc, e, ...t) } callHookParallel(e, ...t) { return t.unshift(e), this.callHookWith(hc, e, ...t) } callHookWith(e, t, ...n) { const r = this._before || this._after ? { name: t, args: n, context: {} } : void 0; this._before && mc(this._before, r); const o = e(t in this._hooks ? [...this._hooks[t]] : [], n); return o instanceof Promise ? o.finally((() => { this._after && r && mc(this._after, r) })) : (this._after && r && mc(this._after, r), o) } beforeEach(e) { return this._before = this._before || [], this._before.push(e), () => { if (void 0 !== this._before) { const t = this._before.indexOf(e); -1 !== t && this._before.splice(t, 1) } } } afterEach(e) { return this._after = this._after || [], this._after.push(e), () => { if (void 0 !== this._after) { const t = this._after.indexOf(e); -1 !== t && this._after.splice(t, 1) } } } } function yc() { return new gc } const _c = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof global ? global : "undefined" != typeof window ? window : {}, vc = "__unctx__", bc = _c[vc] || (_c[vc] = function (e = {}) { const t = {}; return { get: (n, r = {}) => (t[n] || (t[n] = function (e = {}) { let t, n = !1; const r = e => { if (t && t !== e) throw new Error("Context conflict") }; let o; if (e.asyncContext) { const t = e.AsyncLocalStorage || globalThis.AsyncLocalStorage; t ? o = new t : console.warn("[unctx] `AsyncLocalStorage` is not provided.") } const s = () => { if (o && void 0 === t) { const e = o.getStore(); if (void 0 !== e) return e } return t }; return { use: () => { const e = s(); if (void 0 === e) throw new Error("Context is not available"); return e }, tryUse: () => s(), set: (e, o) => { o || r(e), t = e, n = !0 }, unset: () => { t = void 0, n = !1 }, call: (e, s) => { r(e), t = e; try { return o ? o.run(e, s) : s() } finally { n || (t = void 0) } }, async callAsync(e, r) { t = e; const s = () => { t = e }, i = () => t === e ? s : void 0; kc.add(i); try { const s = o ? o.run(e, r) : r(); return n || (t = void 0), await s } finally { kc.delete(i) } } } }({ ...e, ...r })), t[n], t[n]) } }()), wc = (e, t = {}) => bc.get(e, t), Sc = "__unctx_async_handlers__", kc = _c[Sc] || (_c[Sc] = new Set); function Ec(e) { const t = []; for (const o of kc) { const e = o(); e && t.push(e) } const n = () => { for (const e of t) e() }; let r = e(); return r && "object" == typeof r && "catch" in r && (r = r.catch((e => { throw n(), e }))), [r, n] } const Tc = wc("nuxt-app", { asyncContext: !1 }), xc = "__nuxt_plugin"; function Cc(e) { let t = 0; const n = { _scope: v(), provide: void 0, globalName: "nuxt", versions: { get nuxt() { return "3.9.3" }, get vue() { return n.vueApp.version } }, payload: Te({ data: {}, state: {}, once: new Set, _errors: {}, ...window.__NUXT__ ?? {} }), static: { data: {} }, runWithContext: e => n._scope.run((() => function (e, t, n) { const r = () => n ? t(...n) : t(); return Tc.set(e), e.vueApp.runWithContext(r) }(n, e))), isHydrating: !0, deferHydration() { if (!n.isHydrating) return () => { }; t++; let e = !1; return () => { if (!e) return e = !0, t--, 0 === t ? (n.isHydrating = !1, n.callHook("app:suspense:resolve")) : void 0 } }, _asyncDataPromises: {}, _asyncData: {}, _payloadRevivers: {}, ...e }; n.hooks = yc(), n.hook = n.hooks.hook, n.callHook = n.hooks.callHook, n.provide = (e, t) => { const r = "$" + e; Ic(n, r, t), Ic(n.vueApp.config.globalProperties, r, t) }, Ic(n.vueApp, "$nuxt", n), Ic(n.vueApp.config.globalProperties, "$nuxt", n); { window.addEventListener("nuxt.preloadError", (e => { n.callHook("app:chunkError", { error: e.payload }) })), window.useNuxtApp = window.useNuxtApp || Ac; const e = n.hook("app:error", ((...e) => { console.error("[nuxt] error caught during app initialization", ...e) })); n.hook("app:mounted", e) } const r = Te(n.payload.config); return n.provide("config", r), n } function Oc(e) { if ("function" == typeof e) return e; const t = e._name || e.name; return delete e.name, Object.assign(e.setup || (() => { }), e, { [xc]: !0, _name: t }) } function Ac() { var e; let t; if (uo() && (t = null == (e = bs()) ? void 0 : e.appContext.app.$nuxt), t = t || Tc.tryUse(), !t) throw new Error("[nuxt] instance unavailable"); return t } function Rc() { return Ac().$config } function Ic(e, t, n) { Object.defineProperty(e, t, { get: () => n }) } const $c = {}, Pc = function (e, t, n) { let r = Promise.resolve(); if (t && t.length > 0) { const e = document.getElementsByTagName("link"); r = Promise.all(t.map((t => { if (t = function (e, t) { return "." === e[0] ? new URL(e, t).href : e }(t, n), t in $c) return; $c[t] = !0; const r = t.endsWith(".css"), o = r ? '[rel="stylesheet"]' : ""; if (!!n) for (let n = e.length - 1; n >= 0; n--) { const o = e[n]; if (o.href === t && (!r || "stylesheet" === o.rel)) return } else if (document.querySelector(`link[href="${t}"]${o}`)) return; const s = document.createElement("link"); return s.rel = r ? "stylesheet" : "modulepreload", r || (s.as = "script", s.crossOrigin = ""), s.href = t, document.head.appendChild(s), r ? new Promise(((e, n) => { s.addEventListener("load", e), s.addEventListener("error", (() => n(new Error(`Unable to preload CSS for ${t}`)))) })) : void 0 }))) } return r.then((() => e())).catch((e => { const t = new Event("vite:preloadError", { cancelable: !0 }); if (t.payload = e, window.dispatchEvent(t), !t.defaultPrevented) throw e })) }, jc = (...e) => Pc(...e).catch((e => { const t = new Event("nuxt.preloadError"); throw t.payload = e, window.dispatchEvent(t), e })), Lc = -1, Dc = -2, Nc = -3, Mc = -4, Fc = -5, Uc = -6; function Hc(e, t) { return function (e, t) { if ("number" == typeof e) return o(e, !0); if (!Array.isArray(e) || 0 === e.length) throw new Error("Invalid input"); const n = e, r = Array(n.length); function o(e, s = !1) { if (e === Lc) return; if (e === Nc) return NaN; if (e === Mc) return 1 / 0; if (e === Fc) return -1 / 0; if (e === Uc) return -0; if (s) throw new Error("Invalid input"); if (e in r) return r[e]; const i = n[e]; if (i && "object" == typeof i) if (Array.isArray(i)) if ("string" == typeof i[0]) { const n = i[0], s = null == t ? void 0 : t[n]; if (s) return r[e] = s(o(i[1])); switch (n) { case "Date": r[e] = new Date(i[1]); break; case "Set": const t = new Set; r[e] = t; for (let e = 1; e < i.length; e += 1)t.add(o(i[e])); break; case "Map": const s = new Map; r[e] = s; for (let e = 1; e < i.length; e += 2)s.set(o(i[e]), o(i[e + 1])); break; case "RegExp": r[e] = new RegExp(i[1], i[2]); break; case "Object": r[e] = Object(i[1]); break; case "BigInt": r[e] = BigInt(i[1]); break; case "null": const a = Object.create(null); r[e] = a; for (let e = 1; e < i.length; e += 2)a[i[e]] = o(i[e + 1]); break; default: throw new Error(`Unknown type ${n}`) } } else { const t = new Array(i.length); r[e] = t; for (let e = 0; e < i.length; e += 1) { const n = i[e]; n !== Dc && (t[e] = o(n)) } } else { const t = {}; r[e] = t; for (const e in i) { const n = i[e]; t[e] = o(n) } } else r[e] = i; return r[e] } return o(0) }(JSON.parse(e), t) } const Bc = ["title", "titleTemplate", "script", "style", "noscript"], qc = ["base", "meta", "link", "style", "script", "noscript"], Vc = ["title", "titleTemplate", "templateParams", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"], Wc = ["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"], zc = ["tagPosition", "tagPriority", "tagDuplicateStrategy", "children", "innerHTML", "textContent", "processTemplateParams"], Gc = "undefined" != typeof window; function Jc(e) { let t = 9; for (let n = 0; n < e.length;)t = Math.imul(t ^ e.charCodeAt(n++), 9 ** 9); return (65536 + (t ^ t >>> 9)).toString(16).substring(1, 8).toLowerCase() } function Kc(e) { return e._h || Jc(e._d ? e._d : `${e.tag}:${e.textContent || e.innerHTML || ""}:${Object.entries(e.props).map((([e, t]) => `${e}:${String(t)}`)).join(",")}`) } function Yc(e, t) { const { props: n, tag: r } = e; if (Wc.includes(r)) return r; if ("link" === r && "canonical" === n.rel) return "canonical"; if (n.charset) return "charset"; const o = ["id"]; "meta" === r && o.push("name", "property", "http-equiv"); for (const s of o) if (void 0 !== n[s]) { const e = String(n[s]); return !(t && !t(e)) && `${r}:${s}:${e}` } return !1 } function Qc(e, t) { return null == e ? t || null : "function" == typeof e ? e(t) : e } function Xc(e, t) { const n = [], r = t.resolveKeyData || (e => e.key), o = t.resolveValueData || (e => e.value); for (const [s, i] of Object.entries(e)) n.push(...(Array.isArray(i) ? i : [i]).map((e => { const n = { key: s, value: e }, i = o(n); return "object" == typeof i ? Xc(i, t) : Array.isArray(i) ? i : { ["function" == typeof t.key ? t.key(n) : t.key]: r(n), ["function" == typeof t.value ? t.value(n) : t.value]: i } })).flat()); return n } function Zc(e, t) { return Object.entries(e).map((([e, n]) => { if ("object" == typeof n && (n = Zc(n, t)), t.resolve) { const r = t.resolve({ key: e, value: n }); if (void 0 !== r) return r } return "number" == typeof n && (n = n.toString()), "string" == typeof n && t.wrapValue && (n = n.replace(new RegExp(t.wrapValue, "g"), `\\${t.wrapValue}`), n = `${t.wrapValue}${n}${t.wrapValue}`), `${e}${t.keyValueSeparator || ""}${n}` })).join(t.entrySeparator || "") } const el = e => ({ keyValue: e, metaKey: "property" }), tl = e => ({ keyValue: e }), nl = { appleItunesApp: { unpack: { entrySeparator: ", ", resolve: ({ key: e, value: t }) => `${sl(e)}=${t}` } }, articleExpirationTime: el("article:expiration_time"), articleModifiedTime: el("article:modified_time"), articlePublishedTime: el("article:published_time"), bookReleaseDate: el("book:release_date"), charset: { metaKey: "charset" }, contentSecurityPolicy: { unpack: { entrySeparator: "; ", resolve: ({ key: e, value: t }) => `${sl(e)} ${t}` }, metaKey: "http-equiv" }, contentType: { metaKey: "http-equiv" }, defaultStyle: { metaKey: "http-equiv" }, fbAppId: el("fb:app_id"), msapplicationConfig: tl("msapplication-Config"), msapplicationTileColor: tl("msapplication-TileColor"), msapplicationTileImage: tl("msapplication-TileImage"), ogAudioSecureUrl: el("og:audio:secure_url"), ogAudioUrl: el("og:audio"), ogImageSecureUrl: el("og:image:secure_url"), ogImageUrl: el("og:image"), ogSiteName: el("og:site_name"), ogVideoSecureUrl: el("og:video:secure_url"), ogVideoUrl: el("og:video"), profileFirstName: el("profile:first_name"), profileLastName: el("profile:last_name"), profileUsername: el("profile:username"), refresh: { metaKey: "http-equiv", unpack: { entrySeparator: ";", resolve({ key: e, value: t }) { if ("seconds" === e) return `${t}` } } }, robots: { unpack: { entrySeparator: ", ", resolve: ({ key: e, value: t }) => "boolean" == typeof t ? `${sl(e)}` : `${sl(e)}:${t}` } }, xUaCompatible: { metaKey: "http-equiv" } }, rl = ["og", "book", "article", "profile"]; function ol(e) { var t; const n = sl(e).split(":")[0]; return rl.includes(n) ? "property" : (null == (t = nl[e]) ? void 0 : t.metaKey) || "name" } function sl(e) { const t = e.replace(/([A-Z])/g, "-$1").toLowerCase(), n = t.split("-")[0]; return rl.includes(n) || "twitter" === n ? e.replace(/([A-Z])/g, ":$1").toLowerCase() : t } function il(e) { if (Array.isArray(e)) return e.map((e => il(e))); if ("object" != typeof e || Array.isArray(e)) return e; const t = {}; for (const [n, r] of Object.entries(e)) t[sl(n)] = il(r); return t } function al(e, t) { const n = nl[t]; return "refresh" === t ? `${e.seconds};url=${e.url}` : Zc(il(e), { keyValueSeparator: "=", entrySeparator: ", ", resolve: ({ value: e, key: t }) => null === e ? "" : "boolean" == typeof e ? `${t}` : void 0, ...null == n ? void 0 : n.unpack }) } const cl = ["og:image", "og:video", "og:audio", "twitter:image"]; function ll(e) { const t = {}; return Object.entries(e).forEach((([e, n]) => { "false" !== String(n) && e && (t[e] = n) })), t } function ul(e, t) { const n = ll(t), r = sl(e), o = ol(r); if (cl.includes(r)) { const t = {}; return Object.entries(n).forEach((([n, r]) => { t[`${e}${"url" === n ? "" : `${n.charAt(0).toUpperCase()}${n.slice(1)}`}`] = r })), dl(t).sort(((e, t) => { var n, r; return ((null == (n = e[o]) ? void 0 : n.length) || 0) - ((null == (r = t[o]) ? void 0 : r.length) || 0) })) } return [{ [o]: r, ...n }] } function dl(e) { const t = [], n = {}; Object.entries(e).forEach((([e, r]) => { if (Array.isArray(r)) r.forEach((n => { t.push(..."string" == typeof n ? dl({ [e]: n }) : ul(e, n)) })); else if ("object" == typeof r && r) { if (cl.includes(sl(e))) return void t.push(...ul(e, r)); n[e] = ll(r) } else n[e] = r })); const r = Xc(n, { key: ({ key: e }) => ol(e), value: ({ key: e }) => "charset" === e ? "charset" : "content", resolveKeyData: ({ key: e }) => function (e) { var t; return (null == (t = nl[e]) ? void 0 : t.keyValue) || sl(e) }(e), resolveValueData: ({ value: e, key: t }) => null === e ? "_null" : "object" == typeof e ? al(e, t) : "number" == typeof e ? e.toString() : e }); return [...t, ...r].map((e => ("_null" === e.content && (e.content = null), e))) } function pl(e, t) { const n = "class" === e ? " " : ";"; return "object" != typeof t || Array.isArray(t) || (t = Object.entries(t).filter((([, e]) => e)).map((([t, n]) => "style" === e ? `${t}:${n}` : t))), (Array.isArray(t) ? t.join(n) : t).split(n).filter((e => e.trim())).filter(Boolean).join(n) } async function fl(e, t) { for (const n of Object.keys(e)) if (["class", "style"].includes(n)) e[n] = pl(n, e[n]); else if (e[n] instanceof Promise && (e[n] = await e[n]), !t && !zc.includes(n)) { const t = String(e[n]), r = n.startsWith("data-"); "true" === t || "" === t ? e[n] = !r || "true" : e[n] || (r && "false" === t ? e[n] = "false" : delete e[n]) } return e } const hl = 10; async function ml(e) { const t = []; return Object.entries(e.resolvedInput).filter((([e, t]) => void 0 !== t && Vc.includes(e))).forEach((([n, r]) => { const o = function (e) { return Array.isArray(e) ? e : [e] }(r); t.push(...o.map((t => async function (e, t, n) { const r = { tag: e, props: await fl("object" != typeof t || "function" == typeof t || t instanceof Promise ? { [["script", "noscript", "style"].includes(e) ? "innerHTML" : "textContent"]: t } : { ...t }, ["templateParams", "titleTemplate"].includes(e)) }; return zc.forEach((e => { const t = void 0 !== r.props[e] ? r.props[e] : n[e]; void 0 !== t && (["innerHTML", "textContent", "children"].includes(e) && !Bc.includes(r.tag) || (r["children" === e ? "innerHTML" : e] = t), delete r.props[e]) })), r.props.body && (r.tagPosition = "bodyClose", delete r.props.body), "script" === r.tag && "object" == typeof r.innerHTML && (r.innerHTML = JSON.stringify(r.innerHTML), r.props.type = r.props.type || "application/json"), Array.isArray(r.props.content) ? r.props.content.map((e => ({ ...r, props: { ...r.props, content: e } }))) : r }(n, t, e))).flat()) })), (await Promise.all(t)).flat().filter(Boolean).map(((t, n) => (t._e = e._i, e.mode && (t._m = e.mode), t._p = (e._i << hl) + n, t))) } const gl = { base: -10, title: 10 }, yl = { critical: -80, high: -10, low: 20 }; function _l(e) { let t = 100; const n = e.tagPriority; return "number" == typeof n ? n : ("meta" === e.tag ? ("content-security-policy" === e.props["http-equiv"] && (t = -30), e.props.charset && (t = -20), "viewport" === e.props.name && (t = -15)) : "link" === e.tag && "preconnect" === e.props.rel ? t = 20 : e.tag in gl && (t = gl[e.tag]), "string" == typeof n && n in yl ? t + yl[n] : t) } const vl = [{ prefix: "before:", offset: -1 }, { prefix: "after:", offset: 1 }], bl = ["onload", "onerror", "onabort", "onprogress", "onloadstart"], wl = "%separator"; function Sl(e, t, n) { if ("string" != typeof e || !e.includes("%")) return e; let r = e; try { r = decodeURI(e) } catch { } return (r.match(/%(\w+\.+\w+)|%(\w+)/g) || []).sort().reverse().forEach((n => { const r = function (e) { let n; return n = ["s", "pageTitle"].includes(e) ? t.pageTitle : e.includes(".") ? e.split(".").reduce(((e, t) => e && e[t] || void 0), t) : t[e], void 0 !== n && (n || "").replace(/"/g, '\\"') }(n.slice(1)); "string" == typeof r && (e = e.replace(new RegExp(`\\${n}(\\W|$)`, "g"), ((e, t) => `${r}${t}`)).trim()) })), e.includes(wl) && (e.endsWith(wl) && (e = e.slice(0, -10).trim()), e.startsWith(wl) && (e = e.slice(10).trim()), e = Sl(e = e.replace(new RegExp(`\\${wl}\\s*\\${wl}`, "g"), wl), { separator: n }, n)), e } async function kl(e, t = {}) { var n; const r = t.document || e.resolvedOptions.document; if (!r || !e.dirty) return; const o = { shouldRender: !0, tags: [] }; if (await e.hooks.callHook("dom:beforeRender", o), !o.shouldRender) return; const s = (await e.resolveTags()).map((e => ({ tag: e, id: qc.includes(e.tag) ? Kc(e) : e.tag, shouldRender: !0 }))); let i = e._dom; if (!i) { i = { elMap: { htmlAttrs: r.documentElement, bodyAttrs: r.body } }; for (const e of ["body", "head"]) { const t = null == (n = r[e]) ? void 0 : n.children, o = []; for (const e of [...t].filter((e => qc.includes(e.tagName.toLowerCase())))) { const t = { tag: e.tagName.toLowerCase(), props: await fl(e.getAttributeNames().reduce(((t, n) => ({ ...t, [n]: e.getAttribute(n) })), {})), innerHTML: e.innerHTML }; let n = 1, r = Yc(t); for (; r && o.find((e => e._d === r));)r = `${r}:${n++}`; t._d = r || void 0, o.push(t), i.elMap[e.getAttribute("data-hid") || Kc(t)] = e } } } function a(e, t, n) { const r = `${e}:${t}`; i.sideEffects[r] = n, delete i.pendingSideEffects[r] } function c({ id: e, $el: t, tag: n }) { const o = n.tag.endsWith("Attrs"); i.elMap[e] = t, o || (["textContent", "innerHTML"].forEach((e => { n[e] && n[e] !== t[e] && (t[e] = n[e]) })), a(e, "el", (() => { var t; null == (t = i.elMap[e]) || t.remove(), delete i.elMap[e] }))); for (const [s, i] of Object.entries(n._eventHandlers || {})) "" !== t.getAttribute(`data-${s}`) && (("bodyAttrs" === n.tag ? r.defaultView : t).addEventListener(s.replace("on", ""), i.bind(t)), t.setAttribute(`data-${s}`, "")); Object.entries(n.props).forEach((([n, r]) => { const s = `attr:${n}`; if ("class" === n) for (const i of (r || "").split(" ").filter(Boolean)) o && a(e, `${s}:${i}`, (() => t.classList.remove(i))), !t.classList.contains(i) && t.classList.add(i); else if ("style" === n) for (const o of (r || "").split(";").filter(Boolean)) { const [n, ...r] = o.split(":").map((e => e.trim())); a(e, `${s}:${o}:${n}`, (() => { t.style.removeProperty(n) })), t.style.setProperty(n, r.join(":")) } else t.getAttribute(n) !== r && t.setAttribute(n, !0 === r ? "" : String(r)), o && a(e, s, (() => t.removeAttribute(n))) })) } i.pendingSideEffects = { ...i.sideEffects || {} }, i.sideEffects = {}; const l = [], u = { bodyClose: void 0, bodyOpen: void 0, head: void 0 }; for (const d of s) { const { tag: e, shouldRender: t, id: n } = d; t && ("title" !== e.tag ? (d.$el = d.$el || i.elMap[n], d.$el ? c(d) : qc.includes(e.tag) && l.push(d)) : r.title = e.textContent) } for (const d of l) { const e = d.tag.tagPosition || "head"; d.$el = r.createElement(d.tag.tag), c(d), u[e] = u[e] || r.createDocumentFragment(), u[e].appendChild(d.$el) } for (const d of s) await e.hooks.callHook("dom:renderTag", d, r, a); u.head && r.head.appendChild(u.head), u.bodyOpen && r.body.insertBefore(u.bodyOpen, r.body.firstChild), u.bodyClose && r.body.appendChild(u.bodyClose), Object.values(i.pendingSideEffects).forEach((e => e())), e._dom = i, e.dirty = !1, await e.hooks.callHook("dom:rendered", { renders: s }) } function El(e) { return t => { var n, r; const o = (null == (r = null == (n = t.resolvedOptions.document) ? void 0 : n.head.querySelector('script[id="unhead:payload"]')) ? void 0 : r.innerHTML) || !1; return o && t.push(JSON.parse(o)), { mode: "client", hooks: { "entries:updated": function (t) { !async function (e, t = {}) { const n = t.delayFn || (e => setTimeout(e, 10)); e._domUpdatePromise = e._domUpdatePromise || new Promise((r => n((async () => { await kl(e, t), delete e._domUpdatePromise, r() })))) }(t, e) } } } } } const Tl = ["templateParams", "htmlAttrs", "bodyAttrs"], xl = { hooks: { "tag:normalise": function ({ tag: e }) { ["hid", "vmid", "key"].forEach((t => { e.props[t] && (e.key = e.props[t], delete e.props[t]) })); const t = Yc(e) || !!e.key && `${e.tag}:${e.key}`; t && (e._d = t) }, "tags:resolve": function (e) { const t = {}; e.tags.forEach((e => { const n = (e.key ? `${e.tag}:${e.key}` : e._d) || e._p, r = t[n]; if (r) { let o = null == e ? void 0 : e.tagDuplicateStrategy; if (!o && Tl.includes(e.tag) && (o = "merge"), "merge" === o) { const o = r.props; return ["class", "style"].forEach((t => { o[t] && (e.props[t] ? ("style" !== t || o[t].endsWith(";") || (o[t] += ";"), e.props[t] = `${o[t]} ${e.props[t]}`) : e.props[t] = o[t]) })), void (t[n].props = { ...o, ...e.props }) } if (e._e === r._e) return r._duped = r._duped || [], e._d = `${r._d}:${r._duped.length + 1}`, void r._duped.push(e); if (_l(e) > _l(r)) return } const o = Object.keys(e.props).length + (e.innerHTML ? 1 : 0) + (e.textContent ? 1 : 0); qc.includes(e.tag) && 0 === o ? delete t[n] : t[n] = e })); const n = []; Object.values(t).forEach((e => { const t = e._duped; delete e._duped, n.push(e), t && n.push(...t) })), e.tags = n, e.tags = e.tags.filter((e => !("meta" === e.tag && (e.props.name || e.props.property) && !e.props.content))) } } }, Cl = { mode: "server", hooks: { "tags:resolve": function (e) { const t = {}; e.tags.filter((e => ["titleTemplate", "templateParams", "title"].includes(e.tag) && "server" === e._m)).forEach((e => { t[e.tag] = e.tag.startsWith("title") ? e.textContent : e.props })), Object.keys(t).length && e.tags.push({ tag: "script", innerHTML: JSON.stringify(t), props: { id: "unhead:payload", type: "application/json" } }) } } }, Ol = ["script", "link", "bodyAttrs"], Al = e => ({ hooks: { "tags:resolve": function (t) { for (const n of t.tags.filter((e => Ol.includes(e.tag)))) Object.entries(n.props).forEach((([t, r]) => { t.startsWith("on") && "function" == typeof r && (e.ssr && bl.includes(t) ? n.props[t] = `this.dataset.${t}fired = true` : delete n.props[t], n._eventHandlers = n._eventHandlers || {}, n._eventHandlers[t] = r) })), e.ssr && n._eventHandlers && (n.props.src || n.props.href) && (n.key = n.key || Jc(n.props.src || n.props.href)) }, "dom:renderTag": function ({ $el: e, tag: t }) { var n, r; for (const o of Object.keys((null == e ? void 0 : e.dataset) || {}).filter((e => bl.some((t => `${t}fired` === e))))) { const s = o.replace("fired", ""); null == (r = null == (n = t._eventHandlers) ? void 0 : n[s]) || r.call(e, new Event(s.replace("on", ""))) } } } }), Rl = ["link", "style", "script", "noscript"], Il = { hooks: { "tag:normalise": ({ tag: e }) => { e.key && Rl.includes(e.tag) && (e.props["data-hid"] = e._h = Jc(e.key)) } } }, $l = { hooks: { "tags:resolve": e => { const t = t => { var n; return null == (n = e.tags.find((e => e._d === t))) ? void 0 : n._p }; for (const { prefix: n, offset: r } of vl) for (const o of e.tags.filter((e => "string" == typeof e.tagPriority && e.tagPriority.startsWith(n)))) { const e = t(o.tagPriority.replace(n, "")); void 0 !== e && (o._p = e + r) } e.tags.sort(((e, t) => e._p - t._p)).sort(((e, t) => _l(e) - _l(t))) } } }, Pl = { meta: "content", link: "href", htmlAttrs: "lang" }, jl = e => ({ hooks: { "tags:resolve": t => { var n; const { tags: r } = t, o = null == (n = r.find((e => "title" === e.tag))) ? void 0 : n.textContent, s = r.findIndex((e => "templateParams" === e.tag)), i = -1 !== s ? r[s].props : {}, a = i.separator || "|"; delete i.separator, i.pageTitle = Sl(i.pageTitle || o || "", i, a); for (const e of r.filter((e => !1 !== e.processTemplateParams))) { const t = Pl[e.tag]; t && "string" == typeof e.props[t] ? e.props[t] = Sl(e.props[t], i, a) : (!0 === e.processTemplateParams || ["titleTemplate", "title"].includes(e.tag)) && ["innerHTML", "textContent"].forEach((t => { "string" == typeof e[t] && (e[t] = Sl(e[t], i, a)) })) } e._templateParams = i, e._separator = a, t.tags = r.filter((e => "templateParams" !== e.tag)) } } }), Ll = { hooks: { "tags:resolve": e => { const { tags: t } = e; let n = t.findIndex((e => "titleTemplate" === e.tag)); const r = t.findIndex((e => "title" === e.tag)); if (-1 !== r && -1 !== n) { const e = Qc(t[n].textContent, t[r].textContent); null !== e ? t[r].textContent = e || t[r].textContent : delete t[r] } else if (-1 !== n) { const e = Qc(t[n].textContent); null !== e && (t[n].textContent = e, t[n].tag = "title", n = -1) } -1 !== n && delete t[n], e.tags = t.filter(Boolean) } } }, Dl = { hooks: { "tags:afterResolve": function (e) { for (const t of e.tags) "string" == typeof t.innerHTML && (t.innerHTML && ["application/ld+json", "application/json"].includes(t.props.type) ? t.innerHTML = t.innerHTML.replace(/</g, "\\u003C") : t.innerHTML = t.innerHTML.replace(new RegExp(`</${t.tag}`, "g"), `<\\/${t.tag}`)) } } }; let Nl; function Ml(e = {}) { const t = function (e = {}) { const t = yc(); t.addHooks(e.hooks || {}), e.document = e.document || (Gc ? document : void 0); const n = !e.document, r = () => { a.dirty = !0, t.callHook("entries:updated", a) }; let o = 0, s = []; const i = [], a = { plugins: i, dirty: !1, resolvedOptions: e, hooks: t, headEntries: () => s, use(e) { const r = "function" == typeof e ? e(a) : e; r.key && i.some((e => e.key === r.key)) || (i.push(r), Fl(r.mode, n) && t.addHooks(r.hooks || {})) }, push(e, i) { null == i || delete i.head; const c = { _i: o++, input: e, ...i }; return Fl(c.mode, n) && (s.push(c), r()), { dispose() { s = s.filter((e => e._i !== c._i)), t.callHook("entries:updated", a), r() }, patch(e) { s = s.map((t => (t._i === c._i && (t.input = c.input = e), t))), r() } } }, async resolveTags() { const e = { tags: [], entries: [...s] }; await t.callHook("entries:resolve", e); for (const n of e.entries) { const r = n.resolvedInput || n.input; if (n.resolvedInput = await (n.transform ? n.transform(r) : r), n.resolvedInput) for (const o of await ml(n)) { const r = { tag: o, entry: n, resolvedOptions: a.resolvedOptions }; await t.callHook("tag:normalise", r), e.tags.push(r.tag) } } return await t.callHook("tags:beforeResolve", e), await t.callHook("tags:resolve", e), await t.callHook("tags:afterResolve", e), e.tags }, ssr: n }; return [xl, Cl, Al, Il, $l, jl, Ll, Dl, ...(null == e ? void 0 : e.plugins) || []].forEach((e => a.use(e))), a.hooks.callHook("init", a), a }(e); return t.use(El()), Nl = t } function Fl(e, t) { return !e || "server" === e && t || "client" === e && !t } const Ul = Ms.startsWith("3"); function Hl(e, t = "") { if (e instanceof Promise) return e; const n = "function" == typeof (r = e) ? r() : Ve(r); var r; return e && n ? Array.isArray(n) ? n.map((e => Hl(e, t))) : "object" == typeof n ? Object.fromEntries(Object.entries(n).map((([e, t]) => "titleTemplate" === e || e.startsWith("on") ? [e, Ve(t)] : [e, Hl(t, e)]))) : n : n } const Bl = { hooks: { "entries:resolve": function (e) { for (const t of e.entries) t.resolvedInput = Hl(t.input) } } }, ql = "usehead"; function Vl(e = {}) { e.domDelayFn = e.domDelayFn || (e => rn((() => setTimeout((() => e()), 0)))); const t = Ml(e); return t.use(Bl), t.install = function (e) { return { install(t) { Ul && (t.config.globalProperties.$unhead = e, t.config.globalProperties.$head = e, t.provide(ql, e)) } }.install }(t), t } const Wl = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, zl = "__unhead_injection_handler__"; function Gl() { if (zl in Wl) return Wl[zl](); const e = lo(ql); return e || Nl } function Jl(e, t = {}) { const n = t.head || Gl(); if (n) return n.ssr ? n.push(e, t) : function (e, t, n = {}) { const r = Ue(!1), o = Ue({}); Hn((() => { o.value = r.value ? {} : Hl(t) })); const s = e.push(o.value, n); qn(o, (e => { s.patch(e) })); bs() && (Or((() => { s.dispose() })), yr((() => { r.value = !0 })), gr((() => { r.value = !1 }))); return s }(n, e, t) } function Kl(e, t) { const { title: n, titleTemplate: r, ...o } = e; return Jl({ title: n, titleTemplate: r, _flatMeta: o }, { ...t, transform(e) { const t = dl({ ...e._flatMeta }); return delete e._flatMeta, { ...e, meta: t } } }) } function Yl(e) { if (null === e || "object" != typeof e) return !1; const t = Object.getPrototypeOf(e); return (null === t || t === Object.prototype || null === Object.getPrototypeOf(t)) && (!(Symbol.iterator in e) && (!(Symbol.toStringTag in e) || "[object Module]" === Object.prototype.toString.call(e))) } function Ql(e, t, n = ".", r) { if (!Yl(t)) return Ql(e, {}, n, r); const o = Object.assign({}, t); for (const s in e) { if ("__proto__" === s || "constructor" === s) continue; const t = e[s]; null != t && (r && r(o, s, t, n) || (Array.isArray(t) && Array.isArray(o[s]) ? o[s] = [...t, ...o[s]] : Yl(t) && Yl(o[s]) ? o[s] = Ql(t, o[s], (n ? `${n}.` : "") + s.toString(), r) : o[s] = t)) } return o } const Xl = (...e) => e.reduce(((e, t) => Ql(e, t, "", Zl)), {}); var Zl; var eu = Object.defineProperty, tu = (e, t, n) => (((e, t, n) => { t in e ? eu(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n })(e, "symbol" != typeof t ? t + "" : t, n), n); class nu extends Error { constructor(e, t = {}) { super(e, t), tu(this, "statusCode", 500), tu(this, "fatal", !1), tu(this, "unhandled", !1), tu(this, "statusMessage"), tu(this, "data"), tu(this, "cause"), t.cause && !this.cause && (this.cause = t.cause) } toJSON() { const e = { message: this.message, statusCode: iu(this.statusCode, 500) }; return this.statusMessage && (e.statusMessage = su(this.statusMessage)), void 0 !== this.data && (e.data = this.data), e } } function ru(e) { if ("string" == typeof e) return new nu(e); if (function (e) { var t; return !0 === (null == (t = null == e ? void 0 : e.constructor) ? void 0 : t.__h3_error__) }(e)) return e; const t = new nu(e.message ?? e.statusMessage ?? "", { cause: e.cause || e }); if (function (e, t) { try { return t in e } catch { return !1 } }(e, "stack")) try { Object.defineProperty(t, "stack", { get: () => e.stack }) } catch { try { t.stack = e.stack } catch { } } if (e.data && (t.data = e.data), e.statusCode ? t.statusCode = iu(e.statusCode, t.statusCode) : e.status && (t.statusCode = iu(e.status, t.statusCode)), e.statusMessage ? t.statusMessage = e.statusMessage : e.statusText && (t.statusMessage = e.statusText), t.statusMessage) { const e = t.statusMessage; su(t.statusMessage) !== e && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.") } return void 0 !== e.fatal && (t.fatal = e.fatal), void 0 !== e.unhandled && (t.unhandled = e.unhandled), t } tu(nu, "__h3_error__", !0); const ou = /[^\u0009\u0020-\u007E]/g; function su(e = "") { return e.replace(ou, "") } function iu(e, t = 200) { return e ? ("string" == typeof e && (e = Number.parseInt(e, 10)), e < 100 || e > 999 ? t : e) : t } "undefined" == typeof setImmediate || setImmediate; const au = Symbol("layout-meta"), cu = Symbol("route"), lu = "__nuxt_error", uu = () => function (e, t, n) { return Fe(e) ? e : c(e) ? new Ke(e) : u(e) && arguments.length > 1 ? Ye(e, t, n) : Ue(e) }(Ac().payload, "error"), du = e => { const t = fu(e); try { const e = Ac(), n = uu(); e.hooks.callHook("app:error", t), n.value = n.value || t } catch { throw t } return t }, pu = async (e = {}) => { const t = Ac(), n = uu(); t.callHook("app:error:cleared", e), e.redirect && await hu().replace(e.redirect), n.value = null }, fu = e => { const t = ru(e); return Object.defineProperty(t, lu, { value: !0, configurable: !1, writable: !1 }), t }, hu = () => { var e; return null == (e = Ac()) ? void 0 : e.$router }, mu = () => uo() ? lo(cu, Ac()._route) : Ac()._route; function gu(e) { return e } const yu = (e, t) => { e || (e = "/"); const n = "string" == typeof e ? e : Ma(e.path || "/", e.query || {}) + (e.hash || ""); if (null == t ? void 0 : t.open) { { const { target: e = "_blank", windowFeatures: r = {} } = t.open, o = Object.entries(r).filter((([e, t]) => void 0 !== t)).map((([e, t]) => `${e.toLowerCase()}=${t}`)).join(", "); open(n, e, o) } return Promise.resolve() } const r = (null == t ? void 0 : t.external) || $a(n, { acceptRelative: !0 }); if (r) { if (!(null == t ? void 0 : t.external)) throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`."); const e = Ba(n).protocol; if (e && function (e) { return !!e && Aa.test(e) }(e)) throw new Error(`Cannot navigate to a URL with '${e}' protocol.`) } const o = (() => { try { if (Ac()._processingMiddleware) return !0 } catch { return !0 } return !1 })(); if (!r && o) return e; const s = hu(), i = Ac(); return r ? (i._scope.stop(), (null == t ? void 0 : t.replace) ? location.replace(n) : location.href = n, o ? !!i.isHydrating && new Promise((() => { })) : Promise.resolve()) : (null == t ? void 0 : t.replace) ? s.replace(e) : s.push(e) }, _u = !1, vu = { componentName: "NuxtLink" }; function bu(e, t = {}) { const n = function (e, t = {}) { const n = new URL(e, "http://localhost"); if (n.search) throw new Error("Payload URL cannot contain search params: " + e); if ("localhost" !== n.host || $a(n.pathname, { acceptRelative: !0 })) throw new Error("Payload URL must not include hostname: " + e); const r = t.hash || (t.fresh ? Date.now() : ""); return Ua(Rc().app.baseURL, n.pathname, r ? `_payload.${r}.${wu}` : `_payload.${wu}`) }(e, t), r = Ac(), o = r._payloadCache = r._payloadCache || {}; return n in o || (o[n] = async function (e = mu().path) { return !!Ac().payload.prerenderedAt }(e).then((e => e ? Su(n).then((e => e || (delete o[n], null))) : (o[n] = null, null)))), o[n] } const wu = "json"; async function Su(e) { const t = fetch(e).then((e => e.text().then(Tu))); try { return await t } catch (n) { console.warn("[nuxt] Cannot load payload ", e, n) } return null } let ku = null; async function Eu() { if (ku) return ku; const e = document.getElementById("__NUXT_DATA__"); if (!e) return {}; const t = await Tu(e.textContent || ""), n = e.dataset.src ? await Su(e.dataset.src) : void 0; return ku = { ...t, ...n, ...window.__NUXT__ }, ku } async function Tu(e) { return await Hc(e, Ac()._payloadRevivers) } const xu = { NuxtError: e => fu(e), EmptyShallowRef: e => He("_" === e ? void 0 : "0n" === e ? BigInt(0) : Xa(e)), EmptyRef: e => Ue("_" === e ? void 0 : "0n" === e ? BigInt(0) : Xa(e)), ShallowRef: e => He(e), ShallowReactive: e => xe(e), Ref: e => Ue(e), Reactive: e => Te(e) }, Cu = Oc({ name: "nuxt:revive-payload:client", order: -30, async setup(e) { let t, n; for (const s in xu) r = s, o = xu[s], Ac()._payloadRevivers[r] = o; var r, o; Object.assign(e.payload, ([t, n] = Ec((() => e.runWithContext(Eu))), t = await t, n(), t)), window.__NUXT__ = e.payload } }), Ou = [], Au = Oc({ name: "nuxt:head", enforce: "pre", setup(e) { const t = Vl({ plugins: Ou }); var n; n = () => Ac().vueApp._context.provides.usehead, Wl[zl] = n, e.vueApp.use(t); { let n = !0; const r = async () => { n = !1, await kl(t) }; t.hooks.hook("dom:beforeRender", (e => { e.shouldRender = !n })), e.hooks.hook("page:start", (() => { n = !0 })), e.hooks.hook("page:finish", (() => { e.isHydrating || r() })), e.hooks.hook("app:error", r), e.hooks.hook("app:suspense:resolve", r) } } }), Ru = "undefined" != typeof document; const Iu = Object.assign; function $u(e, t) { const n = {}; for (const r in t) { const o = t[r]; n[r] = ju(o) ? o.map(e) : e(o) } return n } const Pu = () => { }, ju = Array.isArray, Lu = /#/g, Du = /&/g, Nu = /\//g, Mu = /=/g, Fu = /\?/g, Uu = /\+/g, Hu = /%5B/g, Bu = /%5D/g, qu = /%5E/g, Vu = /%60/g, Wu = /%7B/g, zu = /%7C/g, Gu = /%7D/g, Ju = /%20/g; function Ku(e) { return encodeURI("" + e).replace(zu, "|").replace(Hu, "[").replace(Bu, "]") } function Yu(e) { return Ku(e).replace(Uu, "%2B").replace(Ju, "+").replace(Lu, "%23").replace(Du, "%26").replace(Vu, "`").replace(Wu, "{").replace(Gu, "}").replace(qu, "^") } function Qu(e) { return null == e ? "" : function (e) { return Ku(e).replace(Lu, "%23").replace(Fu, "%3F") }(e).replace(Nu, "%2F") } function Xu(e) { try { return decodeURIComponent("" + e) } catch (t) { } return "" + e } const Zu = /\/$/, ed = e => e.replace(Zu, ""); function td(e, t, n = "/") { let r, o = {}, s = "", i = ""; const a = t.indexOf("#"); let c = t.indexOf("?"); return a < c && a >= 0 && (c = -1), c > -1 && (r = t.slice(0, c), s = t.slice(c + 1, a > -1 ? a : t.length), o = e(s)), a > -1 && (r = r || t.slice(0, a), i = t.slice(a, t.length)), r = function (e, t) { if (e.startsWith("/")) return e; if (!e) return t; const n = t.split("/"), r = e.split("/"), o = r[r.length - 1]; ".." !== o && "." !== o || r.push(""); let s, i, a = n.length - 1; for (s = 0; s < r.length; s++)if (i = r[s], "." !== i) { if (".." !== i) break; a > 1 && a-- } return n.slice(0, a).join("/") + "/" + r.slice(s).join("/") }(null != r ? r : t, n), { fullPath: r + (s && "?") + s + i, path: r, query: o, hash: Xu(i) } } function nd(e, t) { return t && e.toLowerCase().startsWith(t.toLowerCase()) ? e.slice(t.length) || "/" : e } function rd(e, t) { return (e.aliasOf || e) === (t.aliasOf || t) } function od(e, t) { if (Object.keys(e).length !== Object.keys(t).length) return !1; for (const n in e) if (!sd(e[n], t[n])) return !1; return !0 } function sd(e, t) { return ju(e) ? id(e, t) : ju(t) ? id(t, e) : e === t } function id(e, t) { return ju(t) ? e.length === t.length && e.every(((e, n) => e === t[n])) : 1 === e.length && e[0] === t } var ad, cd, ld, ud; (cd = ad || (ad = {})).pop = "pop", cd.push = "push", (ud = ld || (ld = {})).back = "back", ud.forward = "forward", ud.unknown = ""; const dd = /^[^#]+#/; function pd(e, t) { return e.replace(dd, "#") + t } const fd = () => ({ left: window.scrollX, top: window.scrollY }); function hd(e) { let t; if ("el" in e) { const n = e.el, r = "string" == typeof n && n.startsWith("#"), o = "string" == typeof n ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n; if (!o) return; t = function (e, t) { const n = document.documentElement.getBoundingClientRect(), r = e.getBoundingClientRect(); return { behavior: t.behavior, left: r.left - n.left - (t.left || 0), top: r.top - n.top - (t.top || 0) } }(o, e) } else t = e; "scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(null != t.left ? t.left : window.scrollX, null != t.top ? t.top : window.scrollY) } function md(e, t) { return (history.state ? history.state.position - t : -1) + e } const gd = new Map; let yd = () => location.protocol + "//" + location.host; function _d(e, t) { const { pathname: n, search: r, hash: o } = t, s = e.indexOf("#"); if (s > -1) { let t = o.includes(e.slice(s)) ? e.slice(s).length : 1, n = o.slice(t); return "/" !== n[0] && (n = "/" + n), nd(n, "") } return nd(n, e) + r + o } function vd(e, t, n, r = !1, o = !1) { return { back: e, current: t, forward: n, replaced: r, position: window.history.length, scroll: o ? fd() : null } } function bd(e) { const t = function (e) { const { history: t, location: n } = window, r = { value: _d(e, n) }, o = { value: t.state }; function s(r, s, i) { const a = e.indexOf("#"), c = a > -1 ? (n.host && document.querySelector("base") ? e : e.slice(a)) + r : yd() + e + r; try { t[i ? "replaceState" : "pushState"](s, "", c), o.value = s } catch (l) { console.error(l), n[i ? "replace" : "assign"](c) } } return o.value || s(r.value, { back: null, current: r.value, forward: null, position: t.length - 1, replaced: !0, scroll: null }, !0), { location: r, state: o, push: function (e, n) { const i = Iu({}, o.value, t.state, { forward: e, scroll: fd() }); s(i.current, i, !0), s(e, Iu({}, vd(r.value, e, null), { position: i.position + 1 }, n), !1), r.value = e }, replace: function (e, n) { s(e, Iu({}, t.state, vd(o.value.back, e, o.value.forward, !0), n, { position: o.value.position }), !0), r.value = e } } }(e = function (e) { if (!e) if (Ru) { const t = document.querySelector("base"); e = (e = t && t.getAttribute("href") || "/").replace(/^\w+:\/\/[^\/]+/, "") } else e = "/"; return "/" !== e[0] && "#" !== e[0] && (e = "/" + e), ed(e) }(e)), n = function (e, t, n, r) { let o = [], s = [], i = null; const a = ({ state: s }) => { const a = _d(e, location), c = n.value, l = t.value; let u = 0; if (s) { if (n.value = a, t.value = s, i && i === c) return void (i = null); u = l ? s.position - l.position : 0 } else r(a); o.forEach((e => { e(n.value, c, { delta: u, type: ad.pop, direction: u ? u > 0 ? ld.forward : ld.back : ld.unknown }) })) }; function c() { const { history: e } = window; e.state && e.replaceState(Iu({}, e.state, { scroll: fd() }), "") } return window.addEventListener("popstate", a), window.addEventListener("beforeunload", c, { passive: !0 }), { pauseListeners: function () { i = n.value }, listen: function (e) { o.push(e); const t = () => { const t = o.indexOf(e); t > -1 && o.splice(t, 1) }; return s.push(t), t }, destroy: function () { for (const e of s) e(); s = [], window.removeEventListener("popstate", a), window.removeEventListener("beforeunload", c) } } }(e, t.state, t.location, t.replace); const r = Iu({ location: "", base: e, go: function (e, t = !0) { t || n.pauseListeners(), history.go(e) }, createHref: pd.bind(null, e) }, t, n); return Object.defineProperty(r, "location", { enumerable: !0, get: () => t.location.value }), Object.defineProperty(r, "state", { enumerable: !0, get: () => t.state.value }), r } function wd(e) { return "string" == typeof e || "symbol" == typeof e } const Sd = { path: "/", name: void 0, params: {}, query: {}, hash: "", fullPath: "/", matched: [], meta: {}, redirectedFrom: void 0 }, kd = Symbol(""); var Ed, Td; function xd(e, t) { return Iu(new Error, { type: e, [kd]: !0 }, t) } function Cd(e, t) { return e instanceof Error && kd in e && (null == t || !!(e.type & t)) } (Td = Ed || (Ed = {}))[Td.aborted = 4] = "aborted", Td[Td.cancelled = 8] = "cancelled", Td[Td.duplicated = 16] = "duplicated"; const Od = "[^/]+?", Ad = { sensitive: !1, strict: !1, start: !0, end: !0 }, Rd = /[.+*?^${}()[\]/\\]/g; function Id(e, t) { let n = 0; for (; n < e.length && n < t.length;) { const r = t[n] - e[n]; if (r) return r; n++ } return e.length < t.length ? 1 === e.length && 80 === e[0] ? -1 : 1 : e.length > t.length ? 1 === t.length && 80 === t[0] ? 1 : -1 : 0 } function $d(e, t) { let n = 0; const r = e.score, o = t.score; for (; n < r.length && n < o.length;) { const e = Id(r[n], o[n]); if (e) return e; n++ } if (1 === Math.abs(o.length - r.length)) { if (Pd(r)) return 1; if (Pd(o)) return -1 } return o.length - r.length } function Pd(e) { const t = e[e.length - 1]; return e.length > 0 && t[t.length - 1] < 0 } const jd = { type: 0, value: "" }, Ld = /[a-zA-Z0-9_]/; function Dd(e, t, n) { const r = function (e, t) { const n = Iu({}, Ad, t), r = []; let o = n.start ? "^" : ""; const s = []; for (const c of e) { const e = c.length ? [] : [90]; n.strict && !c.length && (o += "/"); for (let t = 0; t < c.length; t++) { const r = c[t]; let i = 40 + (n.sensitive ? .25 : 0); if (0 === r.type) t || (o += "/"), o += r.value.replace(Rd, "\\$&"), i += 40; else if (1 === r.type) { const { value: e, repeatable: n, optional: l, regexp: u } = r; s.push({ name: e, repeatable: n, optional: l }); const d = u || Od; if (d !== Od) { i += 10; try { new RegExp(`(${d})`) } catch (a) { throw new Error(`Invalid custom RegExp for param "${e}" (${d}): ` + a.message) } } let p = n ? `((?:${d})(?:/(?:${d}))*)` : `(${d})`; t || (p = l && c.length < 2 ? `(?:/${p})` : "/" + p), l && (p += "?"), o += p, i += 20, l && (i += -8), n && (i += -20), ".*" === d && (i += -50) } e.push(i) } r.push(e) } if (n.strict && n.end) { const e = r.length - 1; r[e][r[e].length - 1] += .7000000000000001 } n.strict || (o += "/?"), n.end ? o += "$" : n.strict && (o += "(?:/|$)"); const i = new RegExp(o, n.sensitive ? "" : "i"); return { re: i, score: r, keys: s, parse: function (e) { const t = e.match(i), n = {}; if (!t) return null; for (let r = 1; r < t.length; r++) { const e = t[r] || "", o = s[r - 1]; n[o.name] = e && o.repeatable ? e.split("/") : e } return n }, stringify: function (t) { let n = "", r = !1; for (const o of e) { r && n.endsWith("/") || (n += "/"), r = !1; for (const e of o) if (0 === e.type) n += e.value; else if (1 === e.type) { const { value: s, repeatable: i, optional: a } = e, c = s in t ? t[s] : ""; if (ju(c) && !i) throw new Error(`Provided param "${s}" is an array but it is not repeatable (* or + modifiers)`); const l = ju(c) ? c.join("/") : c; if (!l) { if (!a) throw new Error(`Missing required param "${s}"`); o.length < 2 && (n.endsWith("/") ? n = n.slice(0, -1) : r = !0) } n += l } } return n || "/" } } }(function (e) { if (!e) return [[]]; if ("/" === e) return [[jd]]; if (!e.startsWith("/")) throw new Error(`Invalid path "${e}"`); function t(e) { throw new Error(`ERR (${n})/"${l}": ${e}`) } let n = 0, r = n; const o = []; let s; function i() { s && o.push(s), s = [] } let a, c = 0, l = "", u = ""; function d() { l && (0 === n ? s.push({ type: 0, value: l }) : 1 === n || 2 === n || 3 === n ? (s.length > 1 && ("*" === a || "+" === a) && t(`A repeatable param (${l}) must be alone in its segment. eg: '/:ids+.`), s.push({ type: 1, value: l, regexp: u, repeatable: "*" === a || "+" === a, optional: "*" === a || "?" === a })) : t("Invalid state to consume buffer"), l = "") } function p() { l += a } for (; c < e.length;)if (a = e[c++], "\\" !== a || 2 === n) switch (n) { case 0: "/" === a ? (l && d(), i()) : ":" === a ? (d(), n = 1) : p(); break; case 4: p(), n = r; break; case 1: "(" === a ? n = 2 : Ld.test(a) ? p() : (d(), n = 0, "*" !== a && "?" !== a && "+" !== a && c--); break; case 2: ")" === a ? "\\" == u[u.length - 1] ? u = u.slice(0, -1) + a : n = 3 : u += a; break; case 3: d(), n = 0, "*" !== a && "?" !== a && "+" !== a && c--, u = ""; break; default: t("Unknown state") } else r = n, n = 4; return 2 === n && t(`Unfinished custom RegExp for param "${l}"`), d(), i(), o }(e.path), n), o = Iu(r, { record: e, parent: t, children: [], alias: [] }); return t && !o.record.aliasOf == !t.record.aliasOf && t.children.push(o), o } function Nd(e, t) { const n = [], r = new Map; function o(e, n, r) { const a = !r, c = function (e) { return { path: e.path, redirect: e.redirect, name: e.name, meta: e.meta || {}, aliasOf: void 0, beforeEnter: e.beforeEnter, props: Fd(e), children: e.children || [], instances: {}, leaveGuards: new Set, updateGuards: new Set, enterCallbacks: {}, components: "components" in e ? e.components || null : e.component && { default: e.component } } }(e); c.aliasOf = r && r.record; const l = Bd(t, e), u = [c]; if ("alias" in e) { const t = "string" == typeof e.alias ? [e.alias] : e.alias; for (const e of t) u.push(Iu({}, c, { components: r ? r.record.components : c.components, path: e, aliasOf: r ? r.record : c })) } let d, p; for (const t of u) { const { path: u } = t; if (n && "/" !== u[0]) { const e = n.record.path, r = "/" === e[e.length - 1] ? "" : "/"; t.path = n.record.path + (u && r + u) } if (d = Dd(t, n, l), r ? r.alias.push(d) : (p = p || d, p !== d && p.alias.push(d), a && e.name && !Ud(d) && s(e.name)), c.children) { const e = c.children; for (let t = 0; t < e.length; t++)o(e[t], d, r && r.children[t]) } r = r || d, (d.record.components && Object.keys(d.record.components).length || d.record.name || d.record.redirect) && i(d) } return p ? () => { s(p) } : Pu } function s(e) { if (wd(e)) { const t = r.get(e); t && (r.delete(e), n.splice(n.indexOf(t), 1), t.children.forEach(s), t.alias.forEach(s)) } else { const t = n.indexOf(e); t > -1 && (n.splice(t, 1), e.record.name && r.delete(e.record.name), e.children.forEach(s), e.alias.forEach(s)) } } function i(e) { let t = 0; for (; t < n.length && $d(e, n[t]) >= 0 && (e.record.path !== n[t].record.path || !qd(e, n[t]));)t++; n.splice(t, 0, e), e.record.name && !Ud(e) && r.set(e.record.name, e) } return t = Bd({ strict: !1, end: !0, sensitive: !1 }, t), e.forEach((e => o(e))), { addRoute: o, resolve: function (e, t) { let o, s, i, a = {}; if ("name" in e && e.name) { if (o = r.get(e.name), !o) throw xd(1, { location: e }); i = o.record.name, a = Iu(Md(t.params, o.keys.filter((e => !e.optional)).concat(o.parent ? o.parent.keys.filter((e => e.optional)) : []).map((e => e.name))), e.params && Md(e.params, o.keys.map((e => e.name)))), s = o.stringify(a) } else if (null != e.path) s = e.path, o = n.find((e => e.re.test(s))), o && (a = o.parse(s), i = o.record.name); else { if (o = t.name ? r.get(t.name) : n.find((e => e.re.test(t.path))), !o) throw xd(1, { location: e, currentLocation: t }); i = o.record.name, a = Iu({}, t.params, e.params), s = o.stringify(a) } const c = []; let l = o; for (; l;)c.unshift(l.record), l = l.parent; return { name: i, path: s, params: a, matched: c, meta: Hd(c) } }, removeRoute: s, getRoutes: function () { return n }, getRecordMatcher: function (e) { return r.get(e) } } } function Md(e, t) { const n = {}; for (const r of t) r in e && (n[r] = e[r]); return n } function Fd(e) { const t = {}, n = e.props || !1; if ("component" in e) t.default = n; else for (const r in e.components) t[r] = "object" == typeof n ? n[r] : n; return t } function Ud(e) { for (; e;) { if (e.record.aliasOf) return !0; e = e.parent } return !1 } function Hd(e) { return e.reduce(((e, t) => Iu(e, t.meta)), {}) } function Bd(e, t) { const n = {}; for (const r in e) n[r] = r in t ? t[r] : e[r]; return n } function qd(e, t) { return t.children.some((t => t === e || qd(e, t))) } function Vd(e) { const t = {}; if ("" === e || "?" === e) return t; const n = ("?" === e[0] ? e.slice(1) : e).split("&"); for (let r = 0; r < n.length; ++r) { const e = n[r].replace(Uu, " "), o = e.indexOf("="), s = Xu(o < 0 ? e : e.slice(0, o)), i = o < 0 ? null : Xu(e.slice(o + 1)); if (s in t) { let e = t[s]; ju(e) || (e = t[s] = [e]), e.push(i) } else t[s] = i } return t } function Wd(e) { let t = ""; for (let n in e) { const r = e[n]; if (n = Yu(n).replace(Mu, "%3D"), null == r) { void 0 !== r && (t += (t.length ? "&" : "") + n); continue } (ju(r) ? r.map((e => e && Yu(e))) : [r && Yu(r)]).forEach((e => { void 0 !== e && (t += (t.length ? "&" : "") + n, null != e && (t += "=" + e)) })) } return t } function zd(e) { const t = {}; for (const n in e) { const r = e[n]; void 0 !== r && (t[n] = ju(r) ? r.map((e => null == e ? null : "" + e)) : null == r ? r : "" + r) } return t } const Gd = Symbol(""), Jd = Symbol(""), Kd = Symbol(""), Yd = Symbol(""), Qd = Symbol(""); function Xd() { let e = []; return { add: function (t) { return e.push(t), () => { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } }, list: () => e.slice(), reset: function () { e = [] } } } function Zd(e, t, n, r, o, s = (e => e())) { const i = r && (r.enterCallbacks[o] = r.enterCallbacks[o] || []); return () => new Promise(((a, c) => { const l = e => { var s; !1 === e ? c(xd(4, { from: n, to: t })) : e instanceof Error ? c(e) : "string" == typeof (s = e) || s && "object" == typeof s ? c(xd(2, { from: t, to: e })) : (i && r.enterCallbacks[o] === i && "function" == typeof e && i.push(e), a()) }, u = s((() => e.call(r && r.instances[o], t, n, l))); let d = Promise.resolve(u); e.length < 3 && (d = d.then(l)), d.catch((e => c(e))) })) } function ep(e, t, n, r, o = (e => e())) { const s = []; for (const a of e) for (const e in a.components) { let c = a.components[e]; if ("beforeRouteEnter" === t || a.instances[e]) if ("object" == typeof (i = c) || "displayName" in i || "props" in i || "__vccOpts" in i) { const i = (c.__vccOpts || c)[t]; i && s.push(Zd(i, n, r, a, e, o)) } else { let i = c(); s.push((() => i.then((s => { if (!s) return Promise.reject(new Error(`Couldn't resolve component "${e}" at "${a.path}"`)); const i = (c = s).__esModule || "Module" === c[Symbol.toStringTag] ? s.default : s; var c; a.components[e] = i; const l = (i.__vccOpts || i)[t]; return l && Zd(l, n, r, a, e, o)() })))) } } var i; return s } function tp(e) { const t = lo(Kd), n = lo(Yd), r = js((() => t.resolve(Ve(e.to)))), o = js((() => { const { matched: e } = r.value, { length: t } = e, o = e[t - 1], s = n.matched; if (!o || !s.length) return -1; const i = s.findIndex(rd.bind(null, o)); if (i > -1) return i; const a = rp(e[t - 2]); return t > 1 && rp(o) === a && s[s.length - 1].path !== a ? s.findIndex(rd.bind(null, e[t - 2])) : i })), s = js((() => o.value > -1 && function (e, t) { for (const n in t) { const r = t[n], o = e[n]; if ("string" == typeof r) { if (r !== o) return !1 } else if (!ju(o) || o.length !== r.length || r.some(((e, t) => e !== o[t]))) return !1 } return !0 }(n.params, r.value.params))), i = js((() => o.value > -1 && o.value === n.matched.length - 1 && od(n.params, r.value.params))); return { route: r, href: js((() => r.value.href)), isActive: s, isExactActive: i, navigate: function (n = {}) { return function (e) { if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return; if (e.defaultPrevented) return; if (void 0 !== e.button && 0 !== e.button) return; if (e.currentTarget && e.currentTarget.getAttribute) { const t = e.currentTarget.getAttribute("target"); if (/\b_blank\b/i.test(t)) return } e.preventDefault && e.preventDefault(); return !0 }(n) ? t[Ve(e.replace) ? "replace" : "push"](Ve(e.to)).catch(Pu) : Promise.resolve() } } } const np = cr({ name: "RouterLink", compatConfig: { MODE: 3 }, props: { to: { type: [String, Object], required: !0 }, replace: Boolean, activeClass: String, exactActiveClass: String, custom: Boolean, ariaCurrentValue: { type: String, default: "page" } }, useLink: tp, setup(e, { slots: t }) { const n = Te(tp(e)), { options: r } = lo(Kd), o = js((() => ({ [op(e.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive, [op(e.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive }))); return () => { const r = t.default && t.default(n); return e.custom ? r : Ls("a", { "aria-current": n.isExactActive ? e.ariaCurrentValue : null, href: n.href, onClick: n.navigate, class: o.value }, r) } } }); function rp(e) { return e ? e.aliasOf ? e.aliasOf.path : e.path : "" } const op = (e, t, n) => null != e ? e : null != t ? t : n; function sp(e, t) { if (!e) return null; const n = e(t); return 1 === n.length ? n[0] : n } const ip = cr({ name: "RouterView", inheritAttrs: !1, props: { name: { type: String, default: "default" }, route: Object }, compatConfig: { MODE: 3 }, setup(e, { attrs: t, slots: n }) { const r = lo(Qd), o = js((() => e.route || r.value)), s = lo(Jd, 0), i = js((() => { let e = Ve(s); const { matched: t } = o.value; let n; for (; (n = t[e]) && !n.components;)e++; return e })), a = js((() => o.value.matched[i.value])); co(Jd, js((() => i.value + 1))), co(Gd, a), co(Qd, o); const c = Ue(); return qn((() => [c.value, a.value, e.name]), (([e, t, n], [r, o, s]) => { t && (t.instances[n] = e, o && o !== t && e && e === r && (t.leaveGuards.size || (t.leaveGuards = o.leaveGuards), t.updateGuards.size || (t.updateGuards = o.updateGuards))), !e || !t || o && rd(t, o) && r || (t.enterCallbacks[n] || []).forEach((t => t(e))) }), { flush: "post" }), () => { const r = o.value, s = e.name, i = a.value, l = i && i.components[s]; if (!l) return sp(n.default, { Component: l, route: r }); const u = i.props[s], d = u ? !0 === u ? r.params : "function" == typeof u ? u(r) : u : null, p = Ls(l, Iu({}, d, t, { onVnodeUnmounted: e => { e.component.isUnmounted && (i.instances[s] = null) }, ref: c })); return sp(n.default, { Component: p, route: r }) || p } } }); function ap(e) { const t = Nd(e.routes, e), n = e.parseQuery || Vd, r = e.stringifyQuery || Wd, o = e.history, s = Xd(), i = Xd(), a = Xd(), c = He(Sd); let l = Sd; Ru && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual"); const u = $u.bind(null, (e => "" + e)), d = $u.bind(null, Qu), p = $u.bind(null, Xu); function f(e, s) { if (s = Iu({}, s || c.value), "string" == typeof e) { const r = td(n, e, s.path), i = t.resolve({ path: r.path }, s), a = o.createHref(r.fullPath); return Iu(r, i, { params: p(i.params), hash: Xu(r.hash), redirectedFrom: void 0, href: a }) } let i; if (null != e.path) i = Iu({}, e, { path: td(n, e.path, s.path).path }); else { const t = Iu({}, e.params); for (const e in t) null == t[e] && delete t[e]; i = Iu({}, e, { params: d(t) }), s.params = d(s.params) } const a = t.resolve(i, s), l = e.hash || ""; a.params = u(p(a.params)); const f = function (e, t) { const n = t.query ? e(t.query) : ""; return t.path + (n && "?") + n + (t.hash || "") }(r, Iu({}, e, { hash: (h = l, Ku(h).replace(Wu, "{").replace(Gu, "}").replace(qu, "^")), path: a.path })); var h; const m = o.createHref(f); return Iu({ fullPath: f, hash: l, query: r === Wd ? zd(e.query) : e.query || {} }, a, { redirectedFrom: void 0, href: m }) } function h(e) { return "string" == typeof e ? td(n, e, c.value.path) : Iu({}, e) } function m(e, t) { if (l !== e) return xd(8, { from: t, to: e }) } function g(e) { return _(e) } function y(e) { const t = e.matched[e.matched.length - 1]; if (t && t.redirect) { const { redirect: n } = t; let r = "function" == typeof n ? n(e) : n; return "string" == typeof r && (r = r.includes("?") || r.includes("#") ? r = h(r) : { path: r }, r.params = {}), Iu({ query: e.query, hash: e.hash, params: null != r.path ? {} : e.params }, r) } } function _(e, t) { const n = l = f(e), o = c.value, s = e.state, i = e.force, a = !0 === e.replace, u = y(n); if (u) return _(Iu(h(u), { state: "object" == typeof u ? Iu({}, s, u.state) : s, force: i, replace: a }), t || n); const d = n; let p; return d.redirectedFrom = t, !i && function (e, t, n) { const r = t.matched.length - 1, o = n.matched.length - 1; return r > -1 && r === o && rd(t.matched[r], n.matched[o]) && od(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash }(r, o, n) && (p = xd(16, { to: d, from: o }), I(o, o, !0, !1)), (p ? Promise.resolve(p) : w(d, o)).catch((e => Cd(e) ? Cd(e, 2) ? e : R(e) : A(e, d, o))).then((e => { if (e) { if (Cd(e, 2)) return _(Iu({ replace: a }, h(e.to), { state: "object" == typeof e.to ? Iu({}, s, e.to.state) : s, force: i }), t || d) } else e = k(d, o, !0, a, s); return S(d, o, e), e })) } function v(e, t) { const n = m(e, t); return n ? Promise.reject(n) : Promise.resolve() } function b(e) { const t = j.values().next().value; return t && "function" == typeof t.runWithContext ? t.runWithContext(e) : e() } function w(e, t) { let n; const [r, o, a] = function (e, t) { const n = [], r = [], o = [], s = Math.max(t.matched.length, e.matched.length); for (let i = 0; i < s; i++) { const s = t.matched[i]; s && (e.matched.find((e => rd(e, s))) ? r.push(s) : n.push(s)); const a = e.matched[i]; a && (t.matched.find((e => rd(e, a))) || o.push(a)) } return [n, r, o] }(e, t); n = ep(r.reverse(), "beforeRouteLeave", e, t); for (const s of r) s.leaveGuards.forEach((r => { n.push(Zd(r, e, t)) })); const c = v.bind(null, e, t); return n.push(c), D(n).then((() => { n = []; for (const r of s.list()) n.push(Zd(r, e, t)); return n.push(c), D(n) })).then((() => { n = ep(o, "beforeRouteUpdate", e, t); for (const r of o) r.updateGuards.forEach((r => { n.push(Zd(r, e, t)) })); return n.push(c), D(n) })).then((() => { n = []; for (const r of a) if (r.beforeEnter) if (ju(r.beforeEnter)) for (const o of r.beforeEnter) n.push(Zd(o, e, t)); else n.push(Zd(r.beforeEnter, e, t)); return n.push(c), D(n) })).then((() => (e.matched.forEach((e => e.enterCallbacks = {})), n = ep(a, "beforeRouteEnter", e, t, b), n.push(c), D(n)))).then((() => { n = []; for (const r of i.list()) n.push(Zd(r, e, t)); return n.push(c), D(n) })).catch((e => Cd(e, 8) ? e : Promise.reject(e))) } function S(e, t, n) { a.list().forEach((r => b((() => r(e, t, n))))) } function k(e, t, n, r, s) { const i = m(e, t); if (i) return i; const a = t === Sd, l = Ru ? history.state : {}; n && (r || a ? o.replace(e.fullPath, Iu({ scroll: a && l && l.scroll }, s)) : o.push(e.fullPath, s)), c.value = e, I(e, t, n, a), R() } let E; function T() { E || (E = o.listen(((e, t, n) => { if (!L.listening) return; const r = f(e), s = y(r); if (s) return void _(Iu(s, { replace: !0 }), r).catch(Pu); l = r; const i = c.value; var a, u; Ru && (a = md(i.fullPath, n.delta), u = fd(), gd.set(a, u)), w(r, i).catch((e => Cd(e, 12) ? e : Cd(e, 2) ? (_(e.to, r).then((e => { Cd(e, 20) && !n.delta && n.type === ad.pop && o.go(-1, !1) })).catch(Pu), Promise.reject()) : (n.delta && o.go(-n.delta, !1), A(e, r, i)))).then((e => { (e = e || k(r, i, !1)) && (n.delta && !Cd(e, 8) ? o.go(-n.delta, !1) : n.type === ad.pop && Cd(e, 20) && o.go(-1, !1)), S(r, i, e) })).catch(Pu) }))) } let x, C = Xd(), O = Xd(); function A(e, t, n) { R(e); const r = O.list(); return r.length ? r.forEach((r => r(e, t, n))) : console.error(e), Promise.reject(e) } function R(e) { return x || (x = !e, T(), C.list().forEach((([t, n]) => e ? n(e) : t())), C.reset()), e } function I(t, n, r, o) { const { scrollBehavior: s } = e; if (!Ru || !s) return Promise.resolve(); const i = !r && function (e) { const t = gd.get(e); return gd.delete(e), t }(md(t.fullPath, 0)) || (o || !r) && history.state && history.state.scroll || null; return rn().then((() => s(t, n, i))).then((e => e && hd(e))).catch((e => A(e, t, n))) } const $ = e => o.go(e); let P; const j = new Set, L = { currentRoute: c, listening: !0, addRoute: function (e, n) { let r, o; return wd(e) ? (r = t.getRecordMatcher(e), o = n) : o = e, t.addRoute(o, r) }, removeRoute: function (e) { const n = t.getRecordMatcher(e); n && t.removeRoute(n) }, hasRoute: function (e) { return !!t.getRecordMatcher(e) }, getRoutes: function () { return t.getRoutes().map((e => e.record)) }, resolve: f, options: e, push: g, replace: function (e) { return g(Iu(h(e), { replace: !0 })) }, go: $, back: () => $(-1), forward: () => $(1), beforeEach: s.add, beforeResolve: i.add, afterEach: a.add, onError: O.add, isReady: function () { return x && c.value !== Sd ? Promise.resolve() : new Promise(((e, t) => { C.add([e, t]) })) }, install(e) { e.component("RouterLink", np), e.component("RouterView", ip), e.config.globalProperties.$router = this, Object.defineProperty(e.config.globalProperties, "$route", { enumerable: !0, get: () => Ve(c) }), Ru && !P && c.value === Sd && (P = !0, g(o.location).catch((e => { }))); const t = {}; for (const r in Sd) Object.defineProperty(t, r, { get: () => c.value[r], enumerable: !0 }); e.provide(Kd, this), e.provide(Yd, xe(t)), e.provide(Qd, c); const n = e.unmount; j.add(e), e.unmount = function () { j.delete(e), j.size < 1 && (l = Sd, E && E(), E = null, c.value = Sd, P = !1, x = !1), n() } } }; function D(e) { return e.reduce(((e, t) => e.then((() => b(t)))), Promise.resolve()) } return L } const cp = (e, t) => { const n = e.route.matched.find((t => { var n; return (null == (n = t.components) ? void 0 : n.default) === e.Component.type })), r = t ?? (null == n ? void 0 : n.meta.key) ?? (n && (o = e.route, n.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, (e => { var t; return (null == (t = o.params[e.slice(1)]) ? void 0 : t.toString()) || "" })))); var o; return "function" == typeof r ? r(e.route) : r }; function lp(e) { return Array.isArray(e) ? e : [e] } const up = { layout: "raffle" }, dp = { layout: "payment" }, pp = { layout: "gifts" }, fp = { layout: "gifts" }, hp = { layout: "payment" }, mp = [{ name: (null == up ? void 0 : up.name) ?? "_disabled-predzakaz-gta-6", path: (null == up ? void 0 : up.path) ?? "/_disabled/predzakaz-gta-6", meta: up || {}, alias: (null == up ? void 0 : up.alias) || [], redirect: (null == up ? void 0 : up.redirect) || void 0, component: () => jc((() => import("./predzakaz-gta-6.t-iAN5p0.js")), __vite__mapDeps([0, 1, 2, 3, 4]), import.meta.url).then((e => e.default || e)) }, { name: "bonus-program", path: "/bonus-program", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./bonus-program.wPrMEJds.js")), __vite__mapDeps([5, 6, 7, 8, 9, 2, 3, 10, 11]), import.meta.url).then((e => e.default || e)) }, { name: (null == dp ? void 0 : dp.name) ?? "index", path: (null == dp ? void 0 : dp.path) ?? "/", children: [{ name: "index-contacts", path: "contacts", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./contacts.Dob7V1hW.js")), __vite__mapDeps([12, 13, 14]), import.meta.url).then((e => e.default || e)) }, { name: "index-policy", path: "policy", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./policy.3V8mOafy.js")), __vite__mapDeps([15, 13, 16]), import.meta.url).then((e => e.default || e)) }, { name: "index-terms", path: "terms", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./terms.CquVN1lI.js")), __vite__mapDeps([17, 13, 18]), import.meta.url).then((e => e.default || e)) }], meta: dp || {}, alias: (null == dp ? void 0 : dp.alias) || [], redirect: (null == dp ? void 0 : dp.redirect) || void 0, component: () => jc((() => import("./index.D9m4a8kE.js")), __vite__mapDeps([]), import.meta.url).then((e => e.default || e)) }, { name: "order-status-plati-gift", path: "/order-status-plati-gift", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./order-status-plati-gift.jHganKvS.js")), __vite__mapDeps([19, 6, 7, 20, 21, 22, 23, 24, 25, 26, 27, 28, 8, 9, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39]), import.meta.url).then((e => e.default || e)) }, { name: "order-status-plati-skins", path: "/order-status-plati-skins", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./order-status-plati-skins.Ci9HAU7q.js")), __vite__mapDeps([40, 41, 42, 43, 44, 45, 30, 46, 33, 34, 35, 36, 37, 47]), import.meta.url).then((e => e.default || e)) }, { name: "order-status-plati", path: "/order-status-plati", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./order-status-plati.BlyYLrsZ.js")), __vite__mapDeps([48, 30, 33, 35, 34, 36, 37, 49]), import.meta.url).then((e => e.default || e)) }, { name: "order-status-skins", path: "/order-status-skins", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./order-status-skins.D6PZ6ma9.js")), __vite__mapDeps([50, 41, 42, 43, 44, 45, 30, 46, 33, 34, 35, 36, 37, 51]), import.meta.url).then((e => e.default || e)) }, { name: "order-status", path: "/order-status", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./order-status.BKk7_Eco.js")), __vite__mapDeps([52, 53, 54, 55, 56, 37, 36, 57]), import.meta.url).then((e => e.default || e)) }, { name: "orders", path: "/orders", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./orders._qyQuVOs.js")), __vite__mapDeps([58, 6, 7, 8, 9, 13, 30, 20, 21, 33, 59, 35, 41, 42, 60, 61, 44, 62, 36, 63]), import.meta.url).then((e => e.default || e)) }, { name: "parse-steam-review", path: "/parse-steam-review", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./parse-steam-review.BXi_S9W-.js")), __vite__mapDeps([64, 30, 65]), import.meta.url).then((e => e.default || e)) }, { name: "ru-ru-games-slug", path: "/ru-ru/games/:slug()", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./index.BsqDI0Br.js")), __vite__mapDeps([66, 6, 7, 20, 21, 55, 56, 61, 23, 24, 13, 67, 30, 59, 68, 22, 25, 69, 70, 26, 27, 31, 32, 71, 39]), import.meta.url).then((e => e.default || e)) }, { name: "ru-ru-games-slug-reviews", path: "/ru-ru/games/:slug()/reviews", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./reviews.Dmk0SUVU.js")), __vite__mapDeps([72, 73, 13, 30, 74, 61, 75]), import.meta.url).then((e => e.default || e)) }, { name: "ru-ru-games", path: "/ru-ru/games", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./index.yPp_hKTc.js")), __vite__mapDeps([76, 6, 7, 13, 67, 30, 59, 68, 22, 23, 24, 25, 1, 31, 77, 78, 61, 79, 80]), import.meta.url).then((e => e.default || e)) }, { name: (null == pp ? void 0 : pp.name) ?? "ru-ru", path: (null == pp ? void 0 : pp.path) ?? "/ru-ru", meta: pp || {}, alias: (null == pp ? void 0 : pp.alias) || [], redirect: (null == pp ? void 0 : pp.redirect) || void 0, component: () => jc((() => import("./index.D4f5KimQ.js")), __vite__mapDeps([81, 13, 1, 82, 78, 83, 77, 84, 53, 54, 6, 7, 61, 85, 86, 87, 88]), import.meta.url).then((e => e.default || e)) }, { name: (null == fp ? void 0 : fp.name) ?? "ru-ru-razprodazha", path: (null == fp ? void 0 : fp.path) ?? "/ru-ru/razprodazha", meta: fp || {}, alias: (null == fp ? void 0 : fp.alias) || [], redirect: (null == fp ? void 0 : fp.redirect) || void 0, component: () => jc((() => import("./razprodazha.CoiB6FZH.js")), __vite__mapDeps([89, 84, 13, 53, 54, 6, 7, 61, 85, 86, 87, 90]), import.meta.url).then((e => e.default || e)) }, { name: "service", path: "/service", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./service.kgFeCbAI.js")), __vite__mapDeps([91, 30, 92]), import.meta.url).then((e => e.default || e)) }, { name: (null == hp ? void 0 : hp.name) ?? "skins", path: (null == hp ? void 0 : hp.path) ?? "/skins", meta: hp || {}, alias: (null == hp ? void 0 : hp.alias) || [], redirect: (null == hp ? void 0 : hp.redirect) || void 0, component: () => jc((() => import("./skins.BjSK3k2n.js")), __vite__mapDeps([93, 94, 33, 35, 95, 96, 30, 97]), import.meta.url).then((e => e.default || e)) }, { name: (null == dp ? void 0 : dp.name) ?? "kzt", path: (null == dp ? void 0 : dp.path) ?? "/kzt", meta: dp || {}, alias: (null == dp ? void 0 : dp.alias) || [], redirect: (null == dp ? void 0 : dp.redirect) || void 0, component: () => jc((() => import("./index.D9m4a8kE.js")), __vite__mapDeps([]), import.meta.url).then((e => e.default || e)) }, { name: "order-status-game-buy", path: "/ru-ru/order-status-game/:slug?", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./order-status-plati-gift.jHganKvS.js")), __vite__mapDeps([19, 6, 7, 20, 21, 22, 23, 24, 25, 26, 27, 28, 8, 9, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39]), import.meta.url).then((e => e.default || e)) }, { name: "order-status-game", path: "/ru-ru/order-status-game/:id?", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./order-status-plati-gift.jHganKvS.js")), __vite__mapDeps([19, 6, 7, 20, 21, 22, 23, 24, 25, 26, 27, 28, 8, 9, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39]), import.meta.url).then((e => e.default || e)) }, { name: "order-status-game-buy-old", path: "/order-status-game/:id?-:slug?", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./order-status-plati-gift.jHganKvS.js")), __vite__mapDeps([19, 6, 7, 20, 21, 22, 23, 24, 25, 26, 27, 28, 8, 9, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39]), import.meta.url).then((e => e.default || e)) }, { name: "order-status-game-old", path: "/order-status-game/:id?", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./order-status-plati-gift.jHganKvS.js")), __vite__mapDeps([19, 6, 7, 20, 21, 22, 23, 24, 25, 26, 27, 28, 8, 9, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39]), import.meta.url).then((e => e.default || e)) }, { name: "new", path: "/ru-ru/games/new", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./index.yPp_hKTc.js")), __vite__mapDeps([76, 6, 7, 13, 67, 30, 59, 68, 22, 23, 24, 25, 1, 31, 77, 78, 61, 79, 80]), import.meta.url).then((e => e.default || e)) }, { name: "all", path: "/ru-ru/games", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./index.yPp_hKTc.js")), __vite__mapDeps([76, 6, 7, 13, 67, 30, 59, 68, 22, 23, 24, 25, 1, 31, 77, 78, 61, 79, 80]), import.meta.url).then((e => e.default || e)) }, { name: "no-access-ru", path: "/ru-ru/games/no-access-ru", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./index.yPp_hKTc.js")), __vite__mapDeps([76, 6, 7, 13, 67, 30, 59, 68, 22, 23, 24, 25, 1, 31, 77, 78, 61, 79, 80]), import.meta.url).then((e => e.default || e)) }, { name: "pre-order", path: "/ru-ru/games/pre-order", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./index.yPp_hKTc.js")), __vite__mapDeps([76, 6, 7, 13, 67, 30, 59, 68, 22, 23, 24, 25, 1, 31, 77, 78, 61, 79, 80]), import.meta.url).then((e => e.default || e)) }, { name: "top", path: "/ru-ru/games/top", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./index.yPp_hKTc.js")), __vite__mapDeps([76, 6, 7, 13, 67, 30, 59, 68, 22, 23, 24, 25, 1, 31, 77, 78, 61, 79, 80]), import.meta.url).then((e => e.default || e)) }, { name: "game-releated", path: "/ru-ru/games/:slug?/related", meta: {}, alias: [], redirect: void 0, component: () => jc((() => import("./index.yPp_hKTc.js")), __vite__mapDeps([76, 6, 7, 13, 67, 30, 59, 68, 22, 23, 24, 25, 1, 31, 77, 78, 61, 79, 80]), import.meta.url).then((e => e.default || e)) }], gp = { scrollBehavior(e, t, n) { if (!JSON.parse(localStorage.getItem("pr-t") ?? "false")) return n || void (e.params.savePosition || window.scrollTo({ top: 0 })); localStorage.setItem("pr-t", "false") } }, yp = (e, t, n) => (t = !0 === t ? {} : t, { default: () => { var r; return t ? Ls(e, t, n) : null == (r = n.default) ? void 0 : r.call(n) } }); function _p(e) { const t = (null == e ? void 0 : e.meta.key) ?? e.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, (t => { var n; return (null == (n = e.params[t.slice(1)]) ? void 0 : n.toString()) || "" })); return "function" == typeof t ? t(e) : t } const vp = { scrollBehavior(e, t, n) { var r; const o = Ac(), s = (null == (r = hu().options) ? void 0 : r.scrollBehaviorType) ?? "auto"; let i = n || void 0; const a = "function" == typeof e.meta.scrollToTop ? e.meta.scrollToTop(e, t) : e.meta.scrollToTop; if (!i && t && e && !1 !== a && function (e, t) { if (e === t || t === Sd) return !1; if (_p(e) !== _p(t)) return !0; const n = e.matched.every(((e, n) => { var r, o; return e.components && e.components.default === (null == (o = null == (r = t.matched[n]) ? void 0 : r.components) ? void 0 : o.default) })); return !n }(e, t) && (i = { left: 0, top: 0 }), e.path === t.path) { if (t.hash && !e.hash) return { left: 0, top: 0 }; if (e.hash) return { el: e.hash, top: bp(e.hash), behavior: s } } const c = e => !!(e.meta.pageTransition ?? _u), l = c(t) && c(e) ? "page:transition:finish" : "page:finish"; return new Promise((t => { o.hooks.hookOnce(l, (async () => { await rn(), e.hash && (i = { el: e.hash, top: bp(e.hash), behavior: s }), t(i) })) })) } }; function bp(e) { try { const t = document.querySelector(e); if (t) return parseFloat(getComputedStyle(t).scrollMarginTop) } catch { } return 0 } const wp = { hashMode: !1, scrollBehaviorType: "auto", ...vp, ...gp }, Sp = gu((async e => { var t; let n, r; if (!(null == (t = e.meta) ? void 0 : t.validate)) return; const o = Ac(), s = hu(); if (!0 === ([n, r] = Ec((() => Promise.resolve(e.meta.validate(e)))), n = await n, r(), n)) return; const i = fu({ statusCode: 404, statusMessage: `Page Not Found: ${e.fullPath}`, data: { path: e.fullPath } }), a = s.beforeResolve((t => { if (a(), t === e) { const t = s.afterEach((async () => { t(), await o.runWithContext((() => du(i))), window.history.pushState({}, "", e.fullPath) })); return !1 } })) })), kp = gu(((e, t) => { if ("/" !== e.path && e.path.endsWith("/")) { const { path: t, query: n, hash: r } = e, o = t.replace(/\/+$/, "") || "/"; return yu({ path: o, query: n, hash: r }, { redirectCode: 301 }) } })), Ep = globalThis.requestIdleCallback || (e => { const t = Date.now(), n = { didTimeout: !1, timeRemaining: () => Math.max(0, 50 - (Date.now() - t)) }; return setTimeout((() => { e(n) }), 1) }), Tp = globalThis.cancelIdleCallback || (e => { clearTimeout(e) }), xp = e => { const t = Ac(); t.isHydrating ? t.hooks.hookOnce("app:suspense:resolve", (() => { Ep(e) })) : Ep(e) };
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
let Cp; const Op = e => Cp = e, Ap = Symbol(); function Rp(e) { return e && "object" == typeof e && "[object Object]" === Object.prototype.toString.call(e) && "function" != typeof e.toJSON } var Ip, $p; ($p = Ip || (Ip = {})).direct = "direct", $p.patchObject = "patch object", $p.patchFunction = "patch function"; const Pp = () => { }; function jp(e, t, n, r = Pp) { e.push(t); const o = () => { const n = e.indexOf(t); n > -1 && (e.splice(n, 1), r()) }; return !n && b() && w(o), o } function Lp(e, ...t) { e.slice().forEach((e => { e(...t) })) } const Dp = e => e(); function Np(e, t) { e instanceof Map && t instanceof Map && t.forEach(((t, n) => e.set(n, t))), e instanceof Set && t instanceof Set && t.forEach(e.add, e); for (const n in t) { if (!t.hasOwnProperty(n)) continue; const r = t[n], o = e[n]; Rp(o) && Rp(r) && e.hasOwnProperty(n) && !Fe(r) && !Ae(r) ? e[n] = Np(o, r) : e[n] = r } return e } const Mp = Symbol(); const { assign: Fp } = Object; function Up(e, t, n = {}, r, o, s) { let i; const a = Fp({ actions: {} }, n), c = { deep: !0 }; let l, u, d, p = [], f = []; const h = r.state.value[e]; let m; function g(t) { let n; l = u = !1, "function" == typeof t ? (t(r.state.value[e]), n = { type: Ip.patchFunction, storeId: e, events: d }) : (Np(r.state.value[e], t), n = { type: Ip.patchObject, payload: t, storeId: e, events: d }); const o = m = Symbol(); rn().then((() => { m === o && (l = !0) })), u = !0, Lp(p, n, r.state.value[e]) } s || h || (r.state.value[e] = {}), Ue({}); const y = s ? function () { const { state: e } = n, t = e ? e() : {}; this.$patch((e => { Fp(e, t) })) } : Pp; function _(t, n) { return function () { Op(r); const o = Array.from(arguments), s = [], i = []; let a; Lp(f, { args: o, name: t, store: b, after: function (e) { s.push(e) }, onError: function (e) { i.push(e) } }); try { a = n.apply(this && this.$id === e ? this : b, o) } catch (c) { throw Lp(i, c), c } return a instanceof Promise ? a.then((e => (Lp(s, e), e))).catch((e => (Lp(i, e), Promise.reject(e)))) : (Lp(s, a), a) } } const b = Te({ _p: r, $id: e, $onAction: jp.bind(null, f), $patch: g, $reset: y, $subscribe(t, n = {}) { const o = jp(p, t, n.detached, (() => s())), s = i.run((() => qn((() => r.state.value[e]), (r => { ("sync" === n.flush ? u : l) && t({ storeId: e, type: Ip.direct, events: d }, r) }), Fp({}, c, n)))); return o }, $dispose: function () { i.stop(), p = [], f = [], r._s.delete(e) } }); r._s.set(e, b); const w = (r._a && r._a.runWithContext || Dp)((() => r._e.run((() => (i = v()).run(t))))); for (const v in w) { const t = w[v]; if (Fe(t) && (!Fe(k = t) || !k.effect) || Ae(t)) s || (!h || Rp(S = t) && S.hasOwnProperty(Mp) || (Fe(t) ? t.value = h[v] : Np(t, h[v])), r.state.value[e][v] = t); else if ("function" == typeof t) { const e = _(v, t); w[v] = e, a.actions[v] = t } } var S, k; return Fp(b, w), Fp(Pe(b), w), Object.defineProperty(b, "$state", { get: () => r.state.value[e], set: e => { g((t => { Fp(t, e) })) } }), r._p.forEach((e => { Fp(b, i.run((() => e({ store: b, app: r._a, pinia: r, options: a })))) })), h && s && n.hydrate && n.hydrate(b.$state, h), l = !0, u = !0, b } function Hp(e, t, n) { let r, o; const s = "function" == typeof t; function i(e, n) { const i = uo(); (e = e || (i ? lo(Ap, null) : null)) && Op(e), (e = Cp)._s.has(r) || (s ? Up(r, t, o, e) : function (e, t, n, r) { const { state: o, actions: s, getters: i } = t, a = n.state.value[e]; let c; c = Up(e, (function () { a || (n.state.value[e] = o ? o() : {}); const t = Ge(n.state.value[e]); return Fp(t, s, Object.keys(i || {}).reduce(((t, r) => (t[r] = je(js((() => { Op(n); const t = n._s.get(e); return i[r].call(t, t) }))), t)), {})) }), t, n, 0, !0) }(r, o, e)); return e._s.get(r) } return "string" == typeof e ? (r = e, o = s ? n : t) : (o = e, r = e.id), i.$id = r, i } const Bp = Hp("modalStore", { state: () => ({ isActive: !1, isActiveQuery: !1, currentType: "", currentTypeQuery: "", alertText: "", noQuery: !1 }), actions: { async openModalQuery(e) { e.name && (e.text && this.setAlertText(e.text), await this.openModalQueryAction(e)) }, async openModal(e) { const t = mu(), n = hu(); "string" == typeof e ? (this.currentType = e, t.path !== `/${e}` && await n.push(`/${e}`), this.isActive = !0) : (this.currentType = e.name, t.path !== `/${e.name}` && await n.push(`/${e.name}?onlyVK=1`), this.isActive = !0) }, async openModalQueryAction(e) { const t = hu(); this.currentTypeQuery = e.name, e.noQuery ? this.noQuery = !0 : await t.replace({ query: { view: e.name } }), this.isActiveQuery = !0 }, async closeModalQuery() { const e = hu(); "popunder" == this.currentTypeQuery && (localStorage.setItem("popunder-viewed", "1"), localStorage.setItem("popunder-timestamp", JSON.stringify(new Date))), this.currentTypeQuery = "", this.noQuery || await e.replace({ query: null }), this.isActiveQuery = !1 }, closeModal(e = !0) { const t = hu(); this.isActive = !1; const n = new CustomEvent("close-modal"); window.dispatchEvent(n), setTimeout((async () => { this.currentType = "", e && await t.push("/") }), 150) }, setAlertText(e) { this.alertText = e } } }), qp = ["/terms", "/contacts", "/policy", "/api", "/login", "/register", "/restore", "/telegram", "/register-offer", "/test-vk-login", "/duplicate", "/contest"], Vp = ["/order-status", "/ru-ru/order-status", "/order-status-plati", "/ru-ru/games", "/ru-ru", "/ru-ru/razprodazha", "/kzt", "/skins", "/preland", "/bonus-program", "/tournament", "/parse-steam-review", "/international", "/service", "/predzakaz-gta-6"].concat(qp), Wp = ["/order-status", "/orders", "/order-status-skins"]; console.log("fetch"); const zp = [Sp, kp, gu((e => { setTimeout((() => { e.path.includes("/ru-ru/games") || e.path.includes("/ru-ru") || e.path.includes("/predzakaz-gta-6") ? (document.body.classList.remove("black-bg"), document.body.classList.add("grey-bg")) : e.path.includes("/orders") || e.path.includes("/order-status-skins") || e.path.includes("/order-status-plati-skins") || e.path.includes("/service") ? (document.body.classList.remove("grey-bg"), document.body.classList.add("black-bg")) : (document.body.classList.remove("grey-bg"), document.body.classList.remove("black-bg")), document.body.classList.toggle("sale-page", e.path.includes("/ru-ru/razprodazha")) }), 300), Bp(); const t = document.querySelector('link[rel="canonical"]'); return null !== t && t.setAttribute("href", window.location.origin + (e.path.endsWith("/") ? e.path.slice(0, -1) : e.path)), "/" === e.fullPath[e.fullPath.length - 1] && e.fullPath.length > 1 ? yu({ path: e.fullPath.slice(0, -1), query: e.query }) : ("/" != e.path && Vp.findIndex((t => e.path.includes(t))), "/bonus-program" === e.path ? document.body.classList.add("deep-black-bg") : document.body.classList.remove("deep-black-bg"), Wp.includes(e.path) ? document.getElementById("app").classList.add("--new-layout") : document.getElementById("app").classList.remove("--new-layout"), e.path.includes("/preland") ? (document.body.classList.add("prelanding"), document.getElementById("app").classList.add("prelanding-app")) : (document.body.classList.remove("prelanding"), document.getElementById("app").classList.remove("prelanding-app")), "/games" == e.path ? yu({ path: "/ru-ru/games", query: e.query }) : (["/login", "/register"].includes(e.path), void localStorage.getItem("user"))) }))], Gp = {}; function Jp(e, t, n) { const { pathname: r, search: o, hash: s } = t, i = e.indexOf("#"); if (i > -1) { const t = s.includes(e.slice(i)) ? e.slice(i).length : 1; let n = s.slice(t); return "/" !== n[0] && (n = "/" + n), Na(n, "") } const a = Na(r, e), c = !n || function (e, t, n = {}) { return n.trailingSlash || (e = La(e), t = La(t)), n.leadingSlash || (e = Da(e), t = Da(t)), n.encoding || (e = Sa(e), t = Sa(t)), e === t }(a, n, { trailingSlash: !0 }) ? a : n; return c + (c.includes("?") ? "" : o) + s } const Kp = Oc({ name: "nuxt:router", enforce: "pre", async setup(e) { var t, n; let r, o, s = Rc().app.baseURL; wp.hashMode && !s.includes("#") && (s += "#"); const i = (null == (t = wp.history) ? void 0 : t.call(wp, s)) ?? (wp.hashMode ? (a = s, (a = location.host ? a || location.pathname + location.search : "").includes("#") || (a += "#"), bd(a)) : bd(s)); var a; const c = (null == (n = wp.routes) ? void 0 : n.call(wp, mp)) ?? mp; let l; const u = Jp(s, window.location, e.payload.path), d = ap({ ...wp, scrollBehavior: (e, t, n) => { var r; if (t !== Sd) return d.options.scrollBehavior = wp.scrollBehavior, null == (r = wp.scrollBehavior) ? void 0 : r.call(wp, e, Sd, l || n); l = n }, history: i, routes: c }); e.vueApp.use(d); const p = He(d.currentRoute.value); d.afterEach(((e, t) => { p.value = t })), Object.defineProperty(e.vueApp.config.globalProperties, "previousRoute", { get: () => p.value }); const f = He(d.resolve(u)), h = () => { f.value = d.currentRoute.value }; e.hook("page:finish", h), d.afterEach(((e, t) => { var n, r, o, s; (null == (r = null == (n = e.matched[0]) ? void 0 : n.components) ? void 0 : r.default) === (null == (s = null == (o = t.matched[0]) ? void 0 : o.components) ? void 0 : s.default) && h() })); const m = {}; for (const v in f.value) Object.defineProperty(m, v, { get: () => f.value[v] }); e._route = xe(m), e._middleware = e._middleware || { global: [], named: {} }; const g = uu(); try { 0, [r, o] = Ec((() => d.isReady())), await r, o() } catch (_) { [r, o] = Ec((() => e.runWithContext((() => du(_))))), await r, o() } const y = e.payload.state._layout; return d.beforeEach((async (t, n) => { var r; await e.callHook("page:loading:start"), t.meta = Te(t.meta), e.isHydrating && y && !Re(t.meta.layout) && (t.meta.layout = y), e._processingMiddleware = !0; { const o = new Set([...zp, ...e._middleware.global]); for (const e of t.matched) { const t = e.meta.middleware; if (t) for (const e of lp(t)) o.add(e) } for (const s of o) { const o = "string" == typeof s ? e._middleware.named[s] || await (null == (r = Gp[s]) ? void 0 : r.call(Gp).then((e => e.default || e))) : s; if (!o) throw new Error(`Unknown route middleware: '${s}'.`); const i = await e.runWithContext((() => o(t, n))); if (!e.payload.serverRendered && e.isHydrating && (!1 === i || i instanceof Error)) { const t = i || ru({ statusCode: 404, statusMessage: `Page Not Found: ${u}` }); return await e.runWithContext((() => du(t))), !1 } if (!0 !== i && (i || !1 === i)) return i } } })), d.onError((async () => { delete e._processingMiddleware, await e.callHook("page:loading:end") })), d.afterEach((async (t, n, r) => { delete e._processingMiddleware, !e.isHydrating && g.value && await e.runWithContext(pu), r && await e.callHook("page:loading:end"), 0 === t.matched.length && await e.runWithContext((() => du(ru({ statusCode: 404, fatal: !1, statusMessage: `Page not found: ${t.fullPath}`, data: { path: t.fullPath } })))) })), e.hooks.hookOnce("app:created", (async () => { try { await d.replace({ ...d.resolve(u), name: void 0, force: !0 }), d.options.scrollBehavior = wp.scrollBehavior } catch (_) { await e.runWithContext((() => du(_))) } })), { provide: { router: d } } } }), Yp = Oc({ name: "nuxt:payload", setup(e) { hu().beforeResolve((async (t, n) => { if (t.path === n.path) return; const r = await bu(t.path); r && Object.assign(e.static.data, r.data) })), xp((() => { e.hooks.hook("link:prefetch", (async e => { Ba(e).protocol || await bu(e) })) })) } }), Qp = Oc((e => { const t = function () { const e = v(!0), t = e.run((() => Ue({}))); let n = [], r = []; const o = je({ install(e) { Op(o), o._a = e, e.provide(Ap, o), e.config.globalProperties.$pinia = o, r.forEach((e => n.push(e))), r = [] }, use(e) { return this._a ? n.push(e) : r.push(e), this }, _p: n, _a: null, _e: e, _s: new Map, state: t }); return o }(); return e.vueApp.use(t), Op(t), e.payload && e.payload.pinia && (t.state.value = e.payload.pinia), { provide: { pinia: t } } })), Xp = Oc({ name: "nuxt:global-components" }), Zp = { digiseller: () => jc((() => import("./digiseller.BqbjoaLl.js")), __vite__mapDeps([98, 99, 100]), import.meta.url).then((e => e.default || e)), gifts: () => jc((() => import("./gifts.BKXRNM1E.js")), __vite__mapDeps([101, 102]), import.meta.url).then((e => e.default || e)), main: () => jc((() => import("./main._BKJ5qC5.js")), __vite__mapDeps([103, 13, 104, 105]), import.meta.url).then((e => e.default || e)), "order-new": () => jc((() => import("./order-new.DDqOxevT.js")), __vite__mapDeps([106, 13, 6, 7, 8, 9, 107, 55, 56, 108, 104, 43, 44, 45, 109]), import.meta.url).then((e => e.default || e)), order: () => jc((() => import("./order.DK8UPh1L.js")), __vite__mapDeps([110, 13, 41, 42, 60, 61, 44, 30, 33, 62, 35, 36, 20, 21, 111]), import.meta.url).then((e => e.default || e)), payment: () => jc((() => import("./payment.7ywNYUAM.js")), __vite__mapDeps([112, 43, 44, 45, 1, 13, 96, 30, 97, 32, 113]), import.meta.url).then((e => e.default || e)), raffle: () => jc((() => import("./raffle.C-szGx0I.js")), __vite__mapDeps([114, 115]), import.meta.url).then((e => e.default || e)) }, ef = Oc({ name: "nuxt:prefetch", setup(e) { const t = hu(); e.hooks.hook("app:mounted", (() => { t.beforeEach((async e => { var t; const n = null == (t = null == e ? void 0 : e.meta) ? void 0 : t.layout; n && "function" == typeof Zp[n] && await Zp[n]() })) })), e.hooks.hook("link:prefetch", (e => { if ($a(e)) return; const n = t.resolve(e); if (!n) return; const r = n.meta.layout; let o = lp(n.meta.middleware); o = o.filter((e => "string" == typeof e)); for (const t of o) "function" == typeof Gp[t] && Gp[t](); r && "function" == typeof Zp[r] && Zp[r]() })) } }), tf = Oc({ name: "nuxt:chunk-reload", setup(e) { const t = hu(), n = Rc(), r = new Set; function o(e) { !function (e = {}) { const t = e.path || window.location.pathname; let n = {}; try { n = Xa(sessionStorage.getItem("nuxt:reload") || "{}") } catch { } if (e.force || (null == n ? void 0 : n.path) !== t || (null == n ? void 0 : n.expires) < Date.now()) { try { sessionStorage.setItem("nuxt:reload", JSON.stringify({ path: t, expires: Date.now() + (e.ttl ?? 1e4) })) } catch { } if (e.persistState) try { sessionStorage.setItem("nuxt:reload:state", JSON.stringify({ state: Ac().payload.state })) } catch { } window.location.pathname !== t ? window.location.href = t : window.location.reload() } }({ path: "href" in e && "#" === e.href[0] ? n.app.baseURL + e.href : Ua(n.app.baseURL, e.fullPath), persistState: !0 }) } t.beforeEach((() => { r.clear() })), e.hook("app:chunkError", (({ error: e }) => { r.add(e) })), e.hook("app:manifest:update", (() => { t.beforeResolve(o) })), t.onError(((e, t) => { r.has(e) && o(t) })) } }); function nf(e, t) { return function () { return e.apply(t, arguments) } } const { toString: rf } = Object.prototype, { getPrototypeOf: of } = Object, sf = (e => t => { const n = rf.call(t); return e[n] || (e[n] = n.slice(8, -1).toLowerCase()) })(Object.create(null)), af = e => (e = e.toLowerCase(), t => sf(t) === e), cf = e => t => typeof t === e, { isArray: lf } = Array, uf = cf("undefined"); const df = af("ArrayBuffer"); const pf = cf("string"), ff = cf("function"), hf = cf("number"), mf = e => null !== e && "object" == typeof e, gf = e => { if ("object" !== sf(e)) return !1; const t = of(e); return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || Symbol.toStringTag in e || Symbol.iterator in e) }, yf = af("Date"), _f = af("File"), vf = af("Blob"), bf = af("FileList"), wf = af("URLSearchParams"); function Sf(e, t, { allOwnKeys: n = !1 } = {}) { if (null == e) return; let r, o; if ("object" != typeof e && (e = [e]), lf(e)) for (r = 0, o = e.length; r < o; r++)t.call(null, e[r], r, e); else { const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e), s = o.length; let i; for (r = 0; r < s; r++)i = o[r], t.call(null, e[i], i, e) } } function kf(e, t) { t = t.toLowerCase(); const n = Object.keys(e); let r, o = n.length; for (; o-- > 0;)if (r = n[o], t === r.toLowerCase()) return r; return null } const Ef = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global, Tf = e => !uf(e) && e !== Ef; const xf = (e => t => e && t instanceof e)("undefined" != typeof Uint8Array && of(Uint8Array)), Cf = af("HTMLFormElement"), Of = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), Af = af("RegExp"), Rf = (e, t) => { const n = Object.getOwnPropertyDescriptors(e), r = {}; Sf(n, ((n, o) => { let s; !1 !== (s = t(n, o, e)) && (r[o] = s || n) })), Object.defineProperties(e, r) }, If = "abcdefghijklmnopqrstuvwxyz", $f = "0123456789", Pf = { DIGIT: $f, ALPHA: If, ALPHA_DIGIT: If + If.toUpperCase() + $f }; const jf = af("AsyncFunction"), Lf = { isArray: lf, isArrayBuffer: df, isBuffer: function (e) { return null !== e && !uf(e) && null !== e.constructor && !uf(e.constructor) && ff(e.constructor.isBuffer) && e.constructor.isBuffer(e) }, isFormData: e => { let t; return e && ("function" == typeof FormData && e instanceof FormData || ff(e.append) && ("formdata" === (t = sf(e)) || "object" === t && ff(e.toString) && "[object FormData]" === e.toString())) }, isArrayBufferView: function (e) { let t; return t = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && df(e.buffer), t }, isString: pf, isNumber: hf, isBoolean: e => !0 === e || !1 === e, isObject: mf, isPlainObject: gf, isUndefined: uf, isDate: yf, isFile: _f, isBlob: vf, isRegExp: Af, isFunction: ff, isStream: e => mf(e) && ff(e.pipe), isURLSearchParams: wf, isTypedArray: xf, isFileList: bf, forEach: Sf, merge: function e() { const { caseless: t } = Tf(this) && this || {}, n = {}, r = (r, o) => { const s = t && kf(n, o) || o; gf(n[s]) && gf(r) ? n[s] = e(n[s], r) : gf(r) ? n[s] = e({}, r) : lf(r) ? n[s] = r.slice() : n[s] = r }; for (let o = 0, s = arguments.length; o < s; o++)arguments[o] && Sf(arguments[o], r); return n }, extend: (e, t, n, { allOwnKeys: r } = {}) => (Sf(t, ((t, r) => { n && ff(t) ? e[r] = nf(t, n) : e[r] = t }), { allOwnKeys: r }), e), trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e), inherits: (e, t, n, r) => { e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", { value: t.prototype }), n && Object.assign(e.prototype, n) }, toFlatObject: (e, t, n, r) => { let o, s, i; const a = {}; if (t = t || {}, null == e) return t; do { for (o = Object.getOwnPropertyNames(e), s = o.length; s-- > 0;)i = o[s], r && !r(i, e, t) || a[i] || (t[i] = e[i], a[i] = !0); e = !1 !== n && of(e) } while (e && (!n || n(e, t)) && e !== Object.prototype); return t }, kindOf: sf, kindOfTest: af, endsWith: (e, t, n) => { e = String(e), (void 0 === n || n > e.length) && (n = e.length), n -= t.length; const r = e.indexOf(t, n); return -1 !== r && r === n }, toArray: e => { if (!e) return null; if (lf(e)) return e; let t = e.length; if (!hf(t)) return null; const n = new Array(t); for (; t-- > 0;)n[t] = e[t]; return n }, forEachEntry: (e, t) => { const n = (e && e[Symbol.iterator]).call(e); let r; for (; (r = n.next()) && !r.done;) { const n = r.value; t.call(e, n[0], n[1]) } }, matchAll: (e, t) => { let n; const r = []; for (; null !== (n = e.exec(t));)r.push(n); return r }, isHTMLForm: Cf, hasOwnProperty: Of, hasOwnProp: Of, reduceDescriptors: Rf, freezeMethods: e => { Rf(e, ((t, n) => { if (ff(e) && -1 !== ["arguments", "caller", "callee"].indexOf(n)) return !1; const r = e[n]; ff(r) && (t.enumerable = !1, "writable" in t ? t.writable = !1 : t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + n + "'") })) })) }, toObjectSet: (e, t) => { const n = {}, r = e => { e.forEach((e => { n[e] = !0 })) }; return lf(e) ? r(e) : r(String(e).split(t)), n }, toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function (e, t, n) { return t.toUpperCase() + n })), noop: () => { }, toFiniteNumber: (e, t) => (e = +e, Number.isFinite(e) ? e : t), findKey: kf, global: Ef, isContextDefined: Tf, ALPHABET: Pf, generateString: (e = 16, t = Pf.ALPHA_DIGIT) => { let n = ""; const { length: r } = t; for (; e--;)n += t[Math.random() * r | 0]; return n }, isSpecCompliantForm: function (e) { return !!(e && ff(e.append) && "FormData" === e[Symbol.toStringTag] && e[Symbol.iterator]) }, toJSONObject: e => { const t = new Array(10), n = (e, r) => { if (mf(e)) { if (t.indexOf(e) >= 0) return; if (!("toJSON" in e)) { t[r] = e; const o = lf(e) ? [] : {}; return Sf(e, ((e, t) => { const s = n(e, r + 1); !uf(s) && (o[t] = s) })), t[r] = void 0, o } } return e }; return n(e, 0) }, isAsyncFn: jf, isThenable: e => e && (mf(e) || ff(e)) && ff(e.then) && ff(e.catch) }; function Df(e, t, n, r, o) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), o && (this.response = o) } Lf.inherits(Df, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: Lf.toJSONObject(this.config), code: this.code, status: this.response && this.response.status ? this.response.status : null } } }); const Nf = Df.prototype, Mf = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e => { Mf[e] = { value: e } })), Object.defineProperties(Df, Mf), Object.defineProperty(Nf, "isAxiosError", { value: !0 }), Df.from = (e, t, n, r, o, s) => { const i = Object.create(Nf); return Lf.toFlatObject(e, i, (function (e) { return e !== Error.prototype }), (e => "isAxiosError" !== e)), Df.call(i, e.message, t, n, r, o), i.cause = e, i.name = e.name, s && Object.assign(i, s), i }; function Ff(e) { return Lf.isPlainObject(e) || Lf.isArray(e) } function Uf(e) { return Lf.endsWith(e, "[]") ? e.slice(0, -2) : e } function Hf(e, t, n) { return e ? e.concat(t).map((function (e, t) { return e = Uf(e), !n && t ? "[" + e + "]" : e })).join(n ? "." : "") : t } const Bf = Lf.toFlatObject(Lf, {}, null, (function (e) { return /^is[A-Z]/.test(e) })); function qf(e, t, n) { if (!Lf.isObject(e)) throw new TypeError("target must be an object"); t = t || new FormData; const r = (n = Lf.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, (function (e, t) { return !Lf.isUndefined(t[e]) }))).metaTokens, o = n.visitor || l, s = n.dots, i = n.indexes, a = (n.Blob || "undefined" != typeof Blob && Blob) && Lf.isSpecCompliantForm(t); if (!Lf.isFunction(o)) throw new TypeError("visitor must be a function"); function c(e) { if (null === e) return ""; if (Lf.isDate(e)) return e.toISOString(); if (!a && Lf.isBlob(e)) throw new Df("Blob is not supported. Use a Buffer instead."); return Lf.isArrayBuffer(e) || Lf.isTypedArray(e) ? a && "function" == typeof Blob ? new Blob([e]) : Buffer.from(e) : e } function l(e, n, o) { let a = e; if (e && !o && "object" == typeof e) if (Lf.endsWith(n, "{}")) n = r ? n : n.slice(0, -2), e = JSON.stringify(e); else if (Lf.isArray(e) && function (e) { return Lf.isArray(e) && !e.some(Ff) }(e) || (Lf.isFileList(e) || Lf.endsWith(n, "[]")) && (a = Lf.toArray(e))) return n = Uf(n), a.forEach((function (e, r) { !Lf.isUndefined(e) && null !== e && t.append(!0 === i ? Hf([n], r, s) : null === i ? n : n + "[]", c(e)) })), !1; return !!Ff(e) || (t.append(Hf(o, n, s), c(e)), !1) } const u = [], d = Object.assign(Bf, { defaultVisitor: l, convertValue: c, isVisitable: Ff }); if (!Lf.isObject(e)) throw new TypeError("data must be an object"); return function e(n, r) { if (!Lf.isUndefined(n)) { if (-1 !== u.indexOf(n)) throw Error("Circular reference detected in " + r.join(".")); u.push(n), Lf.forEach(n, (function (n, s) { !0 === (!(Lf.isUndefined(n) || null === n) && o.call(t, n, Lf.isString(s) ? s.trim() : s, r, d)) && e(n, r ? r.concat(s) : [s]) })), u.pop() } }(e), t } function Vf(e) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, (function (e) { return t[e] })) } function Wf(e, t) { this._pairs = [], e && qf(e, this, t) } const zf = Wf.prototype; function Gf(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function Jf(e, t, n) { if (!t) return e; const r = n && n.encode || Gf, o = n && n.serialize; let s; if (s = o ? o(t, n) : Lf.isURLSearchParams(t) ? t.toString() : new Wf(t, n).toString(r), s) { const t = e.indexOf("#"); -1 !== t && (e = e.slice(0, t)), e += (-1 === e.indexOf("?") ? "?" : "&") + s } return e } zf.append = function (e, t) { this._pairs.push([e, t]) }, zf.toString = function (e) { const t = e ? function (t) { return e.call(this, t, Vf) } : Vf; return this._pairs.map((function (e) { return t(e[0]) + "=" + t(e[1]) }), "").join("&") }; class Kf { constructor() { this.handlers = [] } use(e, t, n) { return this.handlers.push({ fulfilled: e, rejected: t, synchronous: !!n && n.synchronous, runWhen: n ? n.runWhen : null }), this.handlers.length - 1 } eject(e) { this.handlers[e] && (this.handlers[e] = null) } clear() { this.handlers && (this.handlers = []) } forEach(e) { Lf.forEach(this.handlers, (function (t) { null !== t && e(t) })) } } const Yf = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, Qf = { isBrowser: !0, classes: { URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : Wf, FormData: "undefined" != typeof FormData ? FormData : null, Blob: "undefined" != typeof Blob ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] }, Xf = "undefined" != typeof window && "undefined" != typeof document, Zf = (eh = "undefined" != typeof navigator && navigator.product, Xf && ["ReactNative", "NativeScript", "NS"].indexOf(eh) < 0); var eh; const th = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts, nh = { ...Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: Xf, hasStandardBrowserEnv: Zf, hasStandardBrowserWebWorkerEnv: th }, Symbol.toStringTag, { value: "Module" })), ...Qf }; function rh(e) { function t(e, n, r, o) { let s = e[o++]; if ("__proto__" === s) return !0; const i = Number.isFinite(+s), a = o >= e.length; if (s = !s && Lf.isArray(r) ? r.length : s, a) return Lf.hasOwnProp(r, s) ? r[s] = [r[s], n] : r[s] = n, !i; r[s] && Lf.isObject(r[s]) || (r[s] = []); return t(e, n, r[s], o) && Lf.isArray(r[s]) && (r[s] = function (e) { const t = {}, n = Object.keys(e); let r; const o = n.length; let s; for (r = 0; r < o; r++)s = n[r], t[s] = e[s]; return t }(r[s])), !i } if (Lf.isFormData(e) && Lf.isFunction(e.entries)) { const n = {}; return Lf.forEachEntry(e, ((e, r) => { t(function (e) { return Lf.matchAll(/\w+|\[(\w*)]/g, e).map((e => "[]" === e[0] ? "" : e[1] || e[0])) }(e), r, n, 0) })), n } return null } const oh = { transitional: Yf, adapter: ["xhr", "http"], transformRequest: [function (e, t) { const n = t.getContentType() || "", r = n.indexOf("application/json") > -1, o = Lf.isObject(e); o && Lf.isHTMLForm(e) && (e = new FormData(e)); if (Lf.isFormData(e)) return r ? JSON.stringify(rh(e)) : e; if (Lf.isArrayBuffer(e) || Lf.isBuffer(e) || Lf.isStream(e) || Lf.isFile(e) || Lf.isBlob(e)) return e; if (Lf.isArrayBufferView(e)) return e.buffer; if (Lf.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString(); let s; if (o) { if (n.indexOf("application/x-www-form-urlencoded") > -1) return function (e, t) { return qf(e, new nh.classes.URLSearchParams, Object.assign({ visitor: function (e, t, n, r) { return nh.isNode && Lf.isBuffer(e) ? (this.append(t, e.toString("base64")), !1) : r.defaultVisitor.apply(this, arguments) } }, t)) }(e, this.formSerializer).toString(); if ((s = Lf.isFileList(e)) || n.indexOf("multipart/form-data") > -1) { const t = this.env && this.env.FormData; return qf(s ? { "files[]": e } : e, t && new t, this.formSerializer) } } return o || r ? (t.setContentType("application/json", !1), function (e, t, n) { if (Lf.isString(e)) try { return (t || JSON.parse)(e), Lf.trim(e) } catch (r) { if ("SyntaxError" !== r.name) throw r } return (n || JSON.stringify)(e) }(e)) : e }], transformResponse: [function (e) { const t = this.transitional || oh.transitional, n = t && t.forcedJSONParsing, r = "json" === this.responseType; if (e && Lf.isString(e) && (n && !this.responseType || r)) { const n = !(t && t.silentJSONParsing) && r; try { return JSON.parse(e) } catch (o) { if (n) { if ("SyntaxError" === o.name) throw Df.from(o, Df.ERR_BAD_RESPONSE, this, null, this.response); throw o } } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: nh.classes.FormData, Blob: nh.classes.Blob }, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; Lf.forEach(["delete", "get", "head", "post", "put", "patch"], (e => { oh.headers[e] = {} })); const sh = oh, ih = Lf.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), ah = Symbol("internals"); function ch(e) { return e && String(e).trim().toLowerCase() } function lh(e) { return !1 === e || null == e ? e : Lf.isArray(e) ? e.map(lh) : String(e) } function uh(e, t, n, r, o) { return Lf.isFunction(r) ? r.call(this, t, n) : (o && (t = n), Lf.isString(t) ? Lf.isString(r) ? -1 !== t.indexOf(r) : Lf.isRegExp(r) ? r.test(t) : void 0 : void 0) } class dh { constructor(e) { e && this.set(e) } set(e, t, n) { const r = this; function o(e, t, n) { const o = ch(t); if (!o) throw new Error("header name must be a non-empty string"); const s = Lf.findKey(r, o); (!s || void 0 === r[s] || !0 === n || void 0 === n && !1 !== r[s]) && (r[s || t] = lh(e)) } const s = (e, t) => Lf.forEach(e, ((e, n) => o(e, n, t))); return Lf.isPlainObject(e) || e instanceof this.constructor ? s(e, t) : Lf.isString(e) && (e = e.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()) ? s((e => { const t = {}; let n, r, o; return e && e.split("\n").forEach((function (e) { o = e.indexOf(":"), n = e.substring(0, o).trim().toLowerCase(), r = e.substring(o + 1).trim(), !n || t[n] && ih[n] || ("set-cookie" === n ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r) })), t })(e), t) : null != e && o(t, e, n), this } get(e, t) { if (e = ch(e)) { const n = Lf.findKey(this, e); if (n) { const e = this[n]; if (!t) return e; if (!0 === t) return function (e) { const t = Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let r; for (; r = n.exec(e);)t[r[1]] = r[2]; return t }(e); if (Lf.isFunction(t)) return t.call(this, e, n); if (Lf.isRegExp(t)) return t.exec(e); throw new TypeError("parser must be boolean|regexp|function") } } } has(e, t) { if (e = ch(e)) { const n = Lf.findKey(this, e); return !(!n || void 0 === this[n] || t && !uh(0, this[n], n, t)) } return !1 } delete(e, t) { const n = this; let r = !1; function o(e) { if (e = ch(e)) { const o = Lf.findKey(n, e); !o || t && !uh(0, n[o], o, t) || (delete n[o], r = !0) } } return Lf.isArray(e) ? e.forEach(o) : o(e), r } clear(e) { const t = Object.keys(this); let n = t.length, r = !1; for (; n--;) { const o = t[n]; e && !uh(0, this[o], o, e, !0) || (delete this[o], r = !0) } return r } normalize(e) { const t = this, n = {}; return Lf.forEach(this, ((r, o) => { const s = Lf.findKey(n, o); if (s) return t[s] = lh(r), void delete t[o]; const i = e ? function (e) { return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ((e, t, n) => t.toUpperCase() + n)) }(o) : String(o).trim(); i !== o && delete t[o], t[i] = lh(r), n[i] = !0 })), this } concat(...e) { return this.constructor.concat(this, ...e) } toJSON(e) { const t = Object.create(null); return Lf.forEach(this, ((n, r) => { null != n && !1 !== n && (t[r] = e && Lf.isArray(n) ? n.join(", ") : n) })), t } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() { return Object.entries(this.toJSON()).map((([e, t]) => e + ": " + t)).join("\n") } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(e) { return e instanceof this ? e : new this(e) } static concat(e, ...t) { const n = new this(e); return t.forEach((e => n.set(e))), n } static accessor(e) { const t = (this[ah] = this[ah] = { accessors: {} }).accessors, n = this.prototype; function r(e) { const r = ch(e); t[r] || (!function (e, t) { const n = Lf.toCamelCase(" " + t);["get", "set", "has"].forEach((r => { Object.defineProperty(e, r + n, { value: function (e, n, o) { return this[r].call(this, t, e, n, o) }, configurable: !0 }) })) }(n, e), t[r] = !0) } return Lf.isArray(e) ? e.forEach(r) : r(e), this } } dh.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), Lf.reduceDescriptors(dh.prototype, (({ value: e }, t) => { let n = t[0].toUpperCase() + t.slice(1); return { get: () => e, set(e) { this[n] = e } } })), Lf.freezeMethods(dh); const ph = dh; function fh(e, t) { const n = this || sh, r = t || n, o = ph.from(r.headers); let s = r.data; return Lf.forEach(e, (function (e) { s = e.call(n, s, o.normalize(), t ? t.status : void 0) })), o.normalize(), s } function hh(e) { return !(!e || !e.__CANCEL__) } function mh(e, t, n) { Df.call(this, null == e ? "canceled" : e, Df.ERR_CANCELED, t, n), this.name = "CanceledError" } Lf.inherits(mh, Df, { __CANCEL__: !0 }); const gh = nh.hasStandardBrowserEnv ? { write(e, t, n, r, o, s) { const i = [e + "=" + encodeURIComponent(t)]; Lf.isNumber(n) && i.push("expires=" + new Date(n).toGMTString()), Lf.isString(r) && i.push("path=" + r), Lf.isString(o) && i.push("domain=" + o), !0 === s && i.push("secure"), document.cookie = i.join("; ") }, read(e) { const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")); return t ? decodeURIComponent(t[3]) : null }, remove(e) { this.write(e, "", Date.now() - 864e5) } } : { write() { }, read: () => null, remove() { } }; function yh(e, t) { return e && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) ? function (e, t) { return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e }(e, t) : t } const _h = nh.hasStandardBrowserEnv ? function () { const e = /(msie|trident)/i.test(navigator.userAgent), t = document.createElement("a"); let n; function r(n) { let r = n; return e && (t.setAttribute("href", r), r = t.href), t.setAttribute("href", r), { href: t.href, protocol: t.protocol ? t.protocol.replace(/:$/, "") : "", host: t.host, search: t.search ? t.search.replace(/^\?/, "") : "", hash: t.hash ? t.hash.replace(/^#/, "") : "", hostname: t.hostname, port: t.port, pathname: "/" === t.pathname.charAt(0) ? t.pathname : "/" + t.pathname } } return n = r(window.location.href), function (e) { const t = Lf.isString(e) ? r(e) : e; return t.protocol === n.protocol && t.host === n.host } }() : function () { return function () { return !0 } }(); function vh(e, t) { let n = 0; const r = function (e, t) { e = e || 10; const n = new Array(e), r = new Array(e); let o, s = 0, i = 0; return t = void 0 !== t ? t : 1e3, function (a) { const c = Date.now(), l = r[i]; o || (o = c), n[s] = a, r[s] = c; let u = i, d = 0; for (; u !== s;)d += n[u++], u %= e; if (s = (s + 1) % e, s === i && (i = (i + 1) % e), c - o < t) return; const p = l && c - l; return p ? Math.round(1e3 * d / p) : void 0 } }(50, 250); return o => { const s = o.loaded, i = o.lengthComputable ? o.total : void 0, a = s - n, c = r(a); n = s; const l = { loaded: s, total: i, progress: i ? s / i : void 0, bytes: a, rate: c || void 0, estimated: c && i && s <= i ? (i - s) / c : void 0, event: o }; l[t ? "download" : "upload"] = !0, e(l) } } const bh = "undefined" != typeof XMLHttpRequest && function (e) { return new Promise((function (t, n) { let r = e.data; const o = ph.from(e.headers).normalize(); let s, i, { responseType: a, withXSRFToken: c } = e; function l() { e.cancelToken && e.cancelToken.unsubscribe(s), e.signal && e.signal.removeEventListener("abort", s) } if (Lf.isFormData(r)) if (nh.hasStandardBrowserEnv || nh.hasStandardBrowserWebWorkerEnv) o.setContentType(!1); else if (!1 !== (i = o.getContentType())) { const [e, ...t] = i ? i.split(";").map((e => e.trim())).filter(Boolean) : []; o.setContentType([e || "multipart/form-data", ...t].join("; ")) } let u = new XMLHttpRequest; if (e.auth) { const t = e.auth.username || "", n = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : ""; o.set("Authorization", "Basic " + btoa(t + ":" + n)) } const d = yh(e.baseURL, e.url); function p() { if (!u) return; const r = ph.from("getAllResponseHeaders" in u && u.getAllResponseHeaders()); !function (e, t, n) { const r = n.config.validateStatus; n.status && r && !r(n.status) ? t(new Df("Request failed with status code " + n.status, [Df.ERR_BAD_REQUEST, Df.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) : e(n) }((function (e) { t(e), l() }), (function (e) { n(e), l() }), { data: a && "text" !== a && "json" !== a ? u.response : u.responseText, status: u.status, statusText: u.statusText, headers: r, config: e, request: u }), u = null } if (u.open(e.method.toUpperCase(), Jf(d, e.params, e.paramsSerializer), !0), u.timeout = e.timeout, "onloadend" in u ? u.onloadend = p : u.onreadystatechange = function () { u && 4 === u.readyState && (0 !== u.status || u.responseURL && 0 === u.responseURL.indexOf("file:")) && setTimeout(p) }, u.onabort = function () { u && (n(new Df("Request aborted", Df.ECONNABORTED, e, u)), u = null) }, u.onerror = function () { n(new Df("Network Error", Df.ERR_NETWORK, e, u)), u = null }, u.ontimeout = function () { let t = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded"; const r = e.transitional || Yf; e.timeoutErrorMessage && (t = e.timeoutErrorMessage), n(new Df(t, r.clarifyTimeoutError ? Df.ETIMEDOUT : Df.ECONNABORTED, e, u)), u = null }, nh.hasStandardBrowserEnv && (c && Lf.isFunction(c) && (c = c(e)), c || !1 !== c && _h(d))) { const t = e.xsrfHeaderName && e.xsrfCookieName && gh.read(e.xsrfCookieName); t && o.set(e.xsrfHeaderName, t) } void 0 === r && o.setContentType(null), "setRequestHeader" in u && Lf.forEach(o.toJSON(), (function (e, t) { u.setRequestHeader(t, e) })), Lf.isUndefined(e.withCredentials) || (u.withCredentials = !!e.withCredentials), a && "json" !== a && (u.responseType = e.responseType), "function" == typeof e.onDownloadProgress && u.addEventListener("progress", vh(e.onDownloadProgress, !0)), "function" == typeof e.onUploadProgress && u.upload && u.upload.addEventListener("progress", vh(e.onUploadProgress)), (e.cancelToken || e.signal) && (s = t => { u && (n(!t || t.type ? new mh(null, e, u) : t), u.abort(), u = null) }, e.cancelToken && e.cancelToken.subscribe(s), e.signal && (e.signal.aborted ? s() : e.signal.addEventListener("abort", s))); const f = function (e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" }(d); f && -1 === nh.protocols.indexOf(f) ? n(new Df("Unsupported protocol " + f + ":", Df.ERR_BAD_REQUEST, e)) : u.send(r || null) })) }, wh = { http: null, xhr: bh }; Lf.forEach(wh, ((e, t) => { if (e) { try { Object.defineProperty(e, "name", { value: t }) } catch (n) { } Object.defineProperty(e, "adapterName", { value: t }) } })); const Sh = e => `- ${e}`, kh = e => Lf.isFunction(e) || null === e || !1 === e, Eh = e => { e = Lf.isArray(e) ? e : [e]; const { length: t } = e; let n, r; const o = {}; for (let s = 0; s < t; s++) { let t; if (n = e[s], r = n, !kh(n) && (r = wh[(t = String(n)).toLowerCase()], void 0 === r)) throw new Df(`Unknown adapter '${t}'`); if (r) break; o[t || "#" + s] = r } if (!r) { const e = Object.entries(o).map((([e, t]) => `adapter ${e} ` + (!1 === t ? "is not supported by the environment" : "is not available in the build"))); throw new Df("There is no suitable adapter to dispatch the request " + (t ? e.length > 1 ? "since :\n" + e.map(Sh).join("\n") : " " + Sh(e[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT") } return r }; function Th(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new mh(null, e) } function xh(e) { Th(e), e.headers = ph.from(e.headers), e.data = fh.call(e, e.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1); return Eh(e.adapter || sh.adapter)(e).then((function (t) { return Th(e), t.data = fh.call(e, e.transformResponse, t), t.headers = ph.from(t.headers), t }), (function (t) { return hh(t) || (Th(e), t && t.response && (t.response.data = fh.call(e, e.transformResponse, t.response), t.response.headers = ph.from(t.response.headers))), Promise.reject(t) })) } const Ch = e => e instanceof ph ? { ...e } : e; function Oh(e, t) { t = t || {}; const n = {}; function r(e, t, n) { return Lf.isPlainObject(e) && Lf.isPlainObject(t) ? Lf.merge.call({ caseless: n }, e, t) : Lf.isPlainObject(t) ? Lf.merge({}, t) : Lf.isArray(t) ? t.slice() : t } function o(e, t, n) { return Lf.isUndefined(t) ? Lf.isUndefined(e) ? void 0 : r(void 0, e, n) : r(e, t, n) } function s(e, t) { if (!Lf.isUndefined(t)) return r(void 0, t) } function i(e, t) { return Lf.isUndefined(t) ? Lf.isUndefined(e) ? void 0 : r(void 0, e) : r(void 0, t) } function a(n, o, s) { return s in t ? r(n, o) : s in e ? r(void 0, n) : void 0 } const c = { url: s, method: s, data: s, baseURL: i, transformRequest: i, transformResponse: i, paramsSerializer: i, timeout: i, timeoutMessage: i, withCredentials: i, withXSRFToken: i, adapter: i, responseType: i, xsrfCookieName: i, xsrfHeaderName: i, onUploadProgress: i, onDownloadProgress: i, decompress: i, maxContentLength: i, maxBodyLength: i, beforeRedirect: i, transport: i, httpAgent: i, httpsAgent: i, cancelToken: i, socketPath: i, responseEncoding: i, validateStatus: a, headers: (e, t) => o(Ch(e), Ch(t), !0) }; return Lf.forEach(Object.keys(Object.assign({}, e, t)), (function (r) { const s = c[r] || o, i = s(e[r], t[r], r); Lf.isUndefined(i) && s !== a || (n[r] = i) })), n } const Ah = "1.6.8", Rh = {};["object", "boolean", "number", "function", "string", "symbol"].forEach(((e, t) => { Rh[e] = function (n) { return typeof n === e || "a" + (t < 1 ? "n " : " ") + e } })); const Ih = {}; Rh.transitional = function (e, t, n) { function r(e, t) { return "[Axios v1.6.8] Transitional option '" + e + "'" + t + (n ? ". " + n : "") } return (n, o, s) => { if (!1 === e) throw new Df(r(o, " has been removed" + (t ? " in " + t : "")), Df.ERR_DEPRECATED); return t && !Ih[o] && (Ih[o] = !0, console.warn(r(o, " has been deprecated since v" + t + " and will be removed in the near future"))), !e || e(n, o, s) } }; const $h = { assertOptions: function (e, t, n) { if ("object" != typeof e) throw new Df("options must be an object", Df.ERR_BAD_OPTION_VALUE); const r = Object.keys(e); let o = r.length; for (; o-- > 0;) { const s = r[o], i = t[s]; if (i) { const t = e[s], n = void 0 === t || i(t, s, e); if (!0 !== n) throw new Df("option " + s + " must be " + n, Df.ERR_BAD_OPTION_VALUE) } else if (!0 !== n) throw new Df("Unknown option " + s, Df.ERR_BAD_OPTION) } }, validators: Rh }, Ph = $h.validators; class jh { constructor(e) { this.defaults = e, this.interceptors = { request: new Kf, response: new Kf } } async request(e, t) { try { return await this._request(e, t) } catch (n) { if (n instanceof Error) { let e; Error.captureStackTrace ? Error.captureStackTrace(e = {}) : e = new Error; const t = e.stack ? e.stack.replace(/^.+\n/, "") : ""; n.stack ? t && !String(n.stack).endsWith(t.replace(/^.+\n.+\n/, "")) && (n.stack += "\n" + t) : n.stack = t } throw n } } _request(e, t) { "string" == typeof e ? (t = t || {}).url = e : t = e || {}, t = Oh(this.defaults, t); const { transitional: n, paramsSerializer: r, headers: o } = t; void 0 !== n && $h.assertOptions(n, { silentJSONParsing: Ph.transitional(Ph.boolean), forcedJSONParsing: Ph.transitional(Ph.boolean), clarifyTimeoutError: Ph.transitional(Ph.boolean) }, !1), null != r && (Lf.isFunction(r) ? t.paramsSerializer = { serialize: r } : $h.assertOptions(r, { encode: Ph.function, serialize: Ph.function }, !0)), t.method = (t.method || this.defaults.method || "get").toLowerCase(); let s = o && Lf.merge(o.common, o[t.method]); o && Lf.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e => { delete o[e] })), t.headers = ph.concat(s, o); const i = []; let a = !0; this.interceptors.request.forEach((function (e) { "function" == typeof e.runWhen && !1 === e.runWhen(t) || (a = a && e.synchronous, i.unshift(e.fulfilled, e.rejected)) })); const c = []; let l; this.interceptors.response.forEach((function (e) { c.push(e.fulfilled, e.rejected) })); let u, d = 0; if (!a) { const e = [xh.bind(this), void 0]; for (e.unshift.apply(e, i), e.push.apply(e, c), u = e.length, l = Promise.resolve(t); d < u;)l = l.then(e[d++], e[d++]); return l } u = i.length; let p = t; for (d = 0; d < u;) { const e = i[d++], t = i[d++]; try { p = e(p) } catch (f) { t.call(this, f); break } } try { l = xh.call(this, p) } catch (f) { return Promise.reject(f) } for (d = 0, u = c.length; d < u;)l = l.then(c[d++], c[d++]); return l } getUri(e) { return Jf(yh((e = Oh(this.defaults, e)).baseURL, e.url), e.params, e.paramsSerializer) } } Lf.forEach(["delete", "get", "head", "options"], (function (e) { jh.prototype[e] = function (t, n) { return this.request(Oh(n || {}, { method: e, url: t, data: (n || {}).data })) } })), Lf.forEach(["post", "put", "patch"], (function (e) { function t(t) { return function (n, r, o) { return this.request(Oh(o || {}, { method: e, headers: t ? { "Content-Type": "multipart/form-data" } : {}, url: n, data: r })) } } jh.prototype[e] = t(), jh.prototype[e + "Form"] = t(!0) })); const Lh = jh; class Dh { constructor(e) { if ("function" != typeof e) throw new TypeError("executor must be a function."); let t; this.promise = new Promise((function (e) { t = e })); const n = this; this.promise.then((e => { if (!n._listeners) return; let t = n._listeners.length; for (; t-- > 0;)n._listeners[t](e); n._listeners = null })), this.promise.then = e => { let t; const r = new Promise((e => { n.subscribe(e), t = e })).then(e); return r.cancel = function () { n.unsubscribe(t) }, r }, e((function (e, r, o) { n.reason || (n.reason = new mh(e, r, o), t(n.reason)) })) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(e) { this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e] } unsubscribe(e) { if (!this._listeners) return; const t = this._listeners.indexOf(e); -1 !== t && this._listeners.splice(t, 1) } static source() { let e; return { token: new Dh((function (t) { e = t })), cancel: e } } } const Nh = Dh; const Mh = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(Mh).forEach((([e, t]) => { Mh[t] = e })); const Fh = Mh; const Uh = function e(t) { const n = new Lh(t), r = nf(Lh.prototype.request, n); return Lf.extend(r, Lh.prototype, n, { allOwnKeys: !0 }), Lf.extend(r, n, null, { allOwnKeys: !0 }), r.create = function (n) { return e(Oh(t, n)) }, r }(sh); Uh.Axios = Lh, Uh.CanceledError = mh, Uh.CancelToken = Nh, Uh.isCancel = hh, Uh.VERSION = Ah, Uh.toFormData = qf, Uh.AxiosError = Df, Uh.Cancel = Uh.CanceledError, Uh.all = function (e) { return Promise.all(e) }, Uh.spread = function (e) { return function (t) { return e.apply(null, t) } }, Uh.isAxiosError = function (e) { return Lf.isObject(e) && !0 === e.isAxiosError }, Uh.mergeConfig = Oh, Uh.AxiosHeaders = ph, Uh.formToJSON = e => rh(Lf.isHTMLForm(e) ? new FormData(e) : e), Uh.getAdapter = Eh, Uh.HttpStatusCode = Fh, Uh.default = Uh; const Hh = Oc((() => { const e = mu(), t = Bp(), n = Uh.create({ baseURL: "https://steam.kupikod.com/backend/api/" }); return n.interceptors.request.use((async e => { const t = JSON.parse(localStorage.getItem("access_token")), n = "context-2" === localStorage.getItem("SiteRole") ? "context" : localStorage.getItem("SiteRole"), r = localStorage.getItem("digiseller"); return t && (e.headers = { ...e.headers, authorization: `Bearer ${t}` }), Intl && Intl.DateTimeFormat().resolvedOptions().timeZone && (e.headers = { ...e.headers, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone }), n && (e.headers = { ...e.headers, vsn: n }), r && (e.headers = { ...e.headers, digiseller: r }), e }), (e => Promise.reject(e))), n.interceptors.response.use((e => e), (async n => (401 === n.response.status && "/" !== e.path && -1 === Vp.findIndex((t => e.path.includes(t))) && await t.openModal("telegram"), 500 === n.response.status && console.log("error"), Promise.reject(n.response)))), { provide: { axios: n } } })), Bh = Object.prototype.toString; function qh(e) { switch (Bh.call(e)) { case "[object Error]": case "[object Exception]": case "[object DOMException]": return !0; default: return tm(e, Error) } } function Vh(e, t) { return Bh.call(e) === `[object ${t}]` } function Wh(e) { return Vh(e, "ErrorEvent") } function zh(e) { return Vh(e, "DOMError") } function Gh(e) { return Vh(e, "String") } function Jh(e) { return "object" == typeof e && null !== e && "__sentry_template_string__" in e && "__sentry_template_values__" in e } function Kh(e) { return null === e || Jh(e) || "object" != typeof e && "function" != typeof e } function Yh(e) { return Vh(e, "Object") } function Qh(e) { return "undefined" != typeof Event && tm(e, Event) } function Xh(e) { return Vh(e, "RegExp") } function Zh(e) { return Boolean(e && e.then && "function" == typeof e.then) } function em(e) { return "number" == typeof e && e != e } function tm(e, t) { try { return e instanceof t } catch (n) { return !1 } } function nm(e) { return !("object" != typeof e || null === e || !e.__isVue && !e._isVue) } function rm(e, t = 0) { return "string" != typeof e || 0 === t || e.length <= t ? e : `${e.slice(0, t)}...` } function om(e, t) { if (!Array.isArray(e)) return ""; const n = []; for (let o = 0; o < e.length; o++) { const t = e[o]; try { nm(t) ? n.push("[VueViewModel]") : n.push(String(t)) } catch (r) { n.push("[value cannot be serialized]") } } return n.join(t) } function sm(e, t = [], n = !1) { return t.some((t => function (e, t, n = !1) { return !!Gh(e) && (Xh(t) ? t.test(e) : !!Gh(t) && (n ? e === t : e.includes(t))) }(e, t, n))) } function im(e, t, n = 250, r, o, s, i) { if (!(s.exception && s.exception.values && i && tm(i.originalException, Error))) return; const a = s.exception.values.length > 0 ? s.exception.values[s.exception.values.length - 1] : void 0; var c, l; a && (s.exception.values = (c = am(e, t, o, i.originalException, r, s.exception.values, a, 0), l = n, c.map((e => (e.value && (e.value = rm(e.value, l)), e))))) } function am(e, t, n, r, o, s, i, a) { if (s.length >= n + 1) return s; let c = [...s]; if (tm(r[o], Error)) { cm(i, a); const s = e(t, r[o]), l = c.length; lm(s, o, l, a), c = am(e, t, n, r[o], o, [s, ...c], s, l) } return Array.isArray(r.errors) && r.errors.forEach(((r, s) => { if (tm(r, Error)) { cm(i, a); const l = e(t, r), u = c.length; lm(l, `errors[${s}]`, u, a), c = am(e, t, n, r, o, [l, ...c], l, u) } })), c } function cm(e, t) { e.mechanism = e.mechanism || { type: "generic", handled: !0 }, e.mechanism = { ...e.mechanism, ..."AggregateError" === e.type && { is_exception_group: !0 }, exception_id: t } } function lm(e, t, n, r) { e.mechanism = e.mechanism || { type: "generic", handled: !0 }, e.mechanism = { ...e.mechanism, type: "chained", source: t, exception_id: n, parent_id: r } } function um(e) { return e && e.Math == Math ? e : void 0 } const dm = "object" == typeof globalThis && um(globalThis) || "object" == typeof window && um(window) || "object" == typeof self && um(self) || "object" == typeof global && um(global) || function () { return this }() || {}; function pm() { return dm } function fm(e, t, n) { const r = n || dm, o = r.__SENTRY__ = r.__SENTRY__ || {}; return o[e] || (o[e] = t()) } const hm = pm(), mm = 80; function gm(e, t = {}) { if (!e) return "<unknown>"; try { let n = e; const r = 5, o = []; let s = 0, i = 0; const a = " > ", c = a.length; let l; const u = Array.isArray(t) ? t : t.keyAttrs, d = !Array.isArray(t) && t.maxStringLength || mm; for (; n && s++ < r && (l = _m(n, u), !("html" === l || s > 1 && i + o.length * c + l.length >= d));)o.push(l), i += l.length, n = n.parentNode; return o.reverse().join(a) } catch (n) { return "<unknown>" } } function _m(e, t) { const n = e, r = []; let o, s, i, a, c; if (!n || !n.tagName) return ""; if (hm.HTMLElement && n instanceof HTMLElement && n.dataset && n.dataset.sentryComponent) return n.dataset.sentryComponent; r.push(n.tagName.toLowerCase()); const l = t && t.length ? t.filter((e => n.getAttribute(e))).map((e => [e, n.getAttribute(e)])) : null; if (l && l.length) l.forEach((e => { r.push(`[${e[0]}="${e[1]}"]`) })); else if (n.id && r.push(`#${n.id}`), o = n.className, o && Gh(o)) for (s = o.split(/\s+/), c = 0; c < s.length; c++)r.push(`.${s[c]}`); const u = ["aria-label", "type", "name", "title", "alt"]; for (c = 0; c < u.length; c++)i = u[c], a = n.getAttribute(i), a && r.push(`[${i}="${a}"]`); return r.join("") } function vm(e) { if (!hm.HTMLElement) return null; let t = e; for (let n = 0; n < 5; n++) { if (!t) return null; if (t instanceof HTMLElement && t.dataset.sentryComponent) return t.dataset.sentryComponent; t = t.parentNode } return null } const bm = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__, wm = ["debug", "info", "warn", "error", "log", "assert", "trace"], Sm = {}; function km(e) { if (!("console" in dm)) return e(); const t = dm.console, n = {}, r = Object.keys(Sm); r.forEach((e => { const r = Sm[e]; n[e] = t[e], t[e] = r })); try { return e() } finally { r.forEach((e => { t[e] = n[e] })) } } const Em = function () { let e = !1; const t = { enable: () => { e = !0 }, disable: () => { e = !1 }, isEnabled: () => e }; return bm ? wm.forEach((n => { t[n] = (...t) => { e && km((() => { dm.console[n](`Sentry Logger [${n}]:`, ...t) })) } })) : wm.forEach((e => { t[e] = () => { } })), t }(), Tm = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/; function xm(e, t = !1) { const { host: n, path: r, pass: o, port: s, projectId: i, protocol: a, publicKey: c } = e; return `${a}://${c}${t && o ? `:${o}` : ""}@${n}${s ? `:${s}` : ""}/${r ? `${r}/` : r}${i}` } function Cm(e) { return { protocol: e.protocol, publicKey: e.publicKey || "", pass: e.pass || "", host: e.host, port: e.port || "", path: e.path || "", projectId: e.projectId } } function Om(e) { const t = "string" == typeof e ? function (e) { const t = Tm.exec(e); if (!t) return void km((() => { console.error(`Invalid Sentry Dsn: ${e}`) })); const [n, r, o = "", s, i = "", a] = t.slice(1); let c = "", l = a; const u = l.split("/"); if (u.length > 1 && (c = u.slice(0, -1).join("/"), l = u.pop()), l) { const e = l.match(/^\d+/); e && (l = e[0]) } return Cm({ host: s, pass: o, path: c, projectId: l, port: i, protocol: n, publicKey: r }) }(e) : Cm(e); if (t && function (e) { if (!bm) return !0; const { port: t, projectId: n, protocol: r } = e; return !(["protocol", "publicKey", "host", "projectId"].find((t => !e[t] && (Em.error(`Invalid Sentry Dsn: ${t} missing`), !0))) || (n.match(/^\d+$/) ? function (e) { return "http" === e || "https" === e }(r) ? t && isNaN(parseInt(t, 10)) && (Em.error(`Invalid Sentry Dsn: Invalid port ${t}`), 1) : (Em.error(`Invalid Sentry Dsn: Invalid protocol ${r}`), 1) : (Em.error(`Invalid Sentry Dsn: Invalid projectId ${n}`), 1))) }(t)) return t } class Am extends Error { constructor(e, t = "warn") { super(e), this.message = e, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = t } } function Rm(e, t, n) { if (!(t in e)) return; const r = e[t], o = n(r); "function" == typeof o && $m(o, r), e[t] = o } function Im(e, t, n) { try { Object.defineProperty(e, t, { value: n, writable: !0, configurable: !0 }) } catch (r) { bm && Em.log(`Failed to add non-enumerable property "${t}" to object`, e) } } function $m(e, t) { try { const n = t.prototype || {}; e.prototype = t.prototype = n, Im(e, "__sentry_original__", t) } catch (n) { } } function Pm(e) { return e.__sentry_original__ } function jm(e) { if (qh(e)) return { message: e.message, name: e.name, stack: e.stack, ...Dm(e) }; if (Qh(e)) { const t = { type: e.type, target: Lm(e.target), currentTarget: Lm(e.currentTarget), ...Dm(e) }; return "undefined" != typeof CustomEvent && tm(e, CustomEvent) && (t.detail = e.detail), t } return e } function Lm(e) { try { return t = e, "undefined" != typeof Element && tm(t, Element) ? gm(e) : Object.prototype.toString.call(e) } catch (n) { return "<unknown>" } var t } function Dm(e) { if ("object" == typeof e && null !== e) { const t = {}; for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]); return t } return {} } function Nm(e) { return Mm(e, new Map) } function Mm(e, t) { if (function (e) { if (!Yh(e)) return !1; try { const t = Object.getPrototypeOf(e).constructor.name; return !t || "Object" === t } catch (t) { return !0 } }(e)) { const n = t.get(e); if (void 0 !== n) return n; const r = {}; t.set(e, r); for (const o of Object.keys(e)) void 0 !== e[o] && (r[o] = Mm(e[o], t)); return r } if (Array.isArray(e)) { const n = t.get(e); if (void 0 !== n) return n; const r = []; return t.set(e, r), e.forEach((e => { r.push(Mm(e, t)) })), r } return e } const Fm = 50, Um = /\(error: (.*)\)/, Hm = /captureMessage|captureException/; function Bm(...e) { const t = e.sort(((e, t) => e[0] - t[0])).map((e => e[1])); return (e, n = 0) => { const r = [], o = e.split("\n"); for (let s = n; s < o.length; s++) { const e = o[s]; if (e.length > 1024) continue; const n = Um.test(e) ? e.replace(Um, "$1") : e; if (!n.match(/\S*Error: /)) { for (const e of t) { const t = e(n); if (t) { r.push(t); break } } if (r.length >= Fm) break } } return function (e) { if (!e.length) return []; const t = Array.from(e); /sentryWrapped/.test(t[t.length - 1].function || "") && t.pop(); t.reverse(), Hm.test(t[t.length - 1].function || "") && (t.pop(), Hm.test(t[t.length - 1].function || "") && t.pop()); return t.slice(0, Fm).map((e => ({ ...e, filename: e.filename || t[t.length - 1].filename, function: e.function || "?" }))) }(r) } } const qm = "<anonymous>"; function Vm(e) { try { return e && "function" == typeof e && e.name || qm } catch (t) { return qm } } const Wm = {}, zm = {}; function Gm(e, t) { Wm[e] = Wm[e] || [], Wm[e].push(t) } function Jm(e, t) { zm[e] || (t(), zm[e] = !0) } function Km(e, t) { const n = e && Wm[e]; if (n) for (const o of n) try { o(t) } catch (r) { bm && Em.error(`Error while triggering instrumentation handler.\nType: ${e}\nName: ${Vm(o)}\nError:`, r) } } function Ym() { "console" in dm && wm.forEach((function (e) { e in dm.console && Rm(dm.console, e, (function (t) { return Sm[e] = t, function (...t) { Km("console", { args: t, level: e }); const n = Sm[e]; n && n.apply(dm.console, t) } })) })) } function Qm() { const e = dm, t = e.crypto || e.msCrypto; let n = () => 16 * Math.random(); try { if (t && t.randomUUID) return t.randomUUID().replace(/-/g, ""); t && t.getRandomValues && (n = () => { const e = new Uint8Array(1); return t.getRandomValues(e), e[0] }) } catch (r) { } return "10000000100040008000100000000000".replace(/[018]/g, (e => (e ^ (15 & n()) >> e / 4).toString(16))) } function Xm(e) { return e.exception && e.exception.values ? e.exception.values[0] : void 0 } function Zm(e) { const { message: t, event_id: n } = e; if (t) return t; const r = Xm(e); return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>" } function eg(e, t, n) { const r = e.exception = e.exception || {}, o = r.values = r.values || [], s = o[0] = o[0] || {}; s.value || (s.value = t || ""), s.type || (s.type = n || "Error") } function tg(e, t) { const n = Xm(e); if (!n) return; const r = n.mechanism; if (n.mechanism = { type: "generic", handled: !0, ...r, ...t }, t && "data" in t) { const e = { ...r && r.data, ...t.data }; n.mechanism.data = e } } function ng(e) { if (e && e.__sentry_captured__) return !0; try { Im(e, "__sentry_captured__", !0) } catch (t) { } return !1 } function rg(e) { return Array.isArray(e) ? e : [e] } const og = dm, sg = 1e3; let ig, ag, cg; function lg() { if (!og.document) return; const e = Km.bind(null, "dom"), t = ug(e, !0); og.document.addEventListener("click", t, !1), og.document.addEventListener("keypress", t, !1), ["EventTarget", "Node"].forEach((t => { const n = og[t] && og[t].prototype; n && n.hasOwnProperty && n.hasOwnProperty("addEventListener") && (Rm(n, "addEventListener", (function (t) { return function (n, r, o) { if ("click" === n || "keypress" == n) try { const r = this, s = r.__sentry_instrumentation_handlers__ = r.__sentry_instrumentation_handlers__ || {}, i = s[n] = s[n] || { refCount: 0 }; if (!i.handler) { const r = ug(e); i.handler = r, t.call(this, n, r, o) } i.refCount++ } catch (s) { } return t.call(this, n, r, o) } })), Rm(n, "removeEventListener", (function (e) { return function (t, n, r) { if ("click" === t || "keypress" == t) try { const n = this, o = n.__sentry_instrumentation_handlers__ || {}, s = o[t]; s && (s.refCount--, s.refCount <= 0 && (e.call(this, t, s.handler, r), s.handler = void 0, delete o[t]), 0 === Object.keys(o).length && delete n.__sentry_instrumentation_handlers__) } catch (o) { } return e.call(this, t, n, r) } }))) })) } function ug(e, t = !1) { return n => { if (!n || n._sentryCaptured) return; const r = function (e) { try { return e.target } catch (t) { return null } }(n); if (function (e, t) { return "keypress" === e && (!t || !t.tagName || "INPUT" !== t.tagName && "TEXTAREA" !== t.tagName && !t.isContentEditable) }(n.type, r)) return; Im(n, "_sentryCaptured", !0), r && !r._sentryId && Im(r, "_sentryId", Qm()); const o = "keypress" === n.type ? "input" : n.type; if (!function (e) { if (e.type !== ag) return !1; try { if (!e.target || e.target._sentryId !== cg) return !1 } catch (t) { } return !0 }(n)) { e({ event: n, name: o, global: t }), ag = n.type, cg = r ? r._sentryId : void 0 } clearTimeout(ig), ig = og.setTimeout((() => { cg = void 0, ag = void 0 }), sg) } } const dg = pm(); function pg() { if (!("fetch" in dg)) return !1; try { return new Headers, new Request("http://www.example.com"), new Response, !0 } catch (e) { return !1 } } function fg(e) { return e && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(e.toString()) } function hg(e) { const t = "fetch"; Gm(t, e), Jm(t, mg) } function mg() { (function () { if ("string" == typeof EdgeRuntime) return !0; if (!pg()) return !1; if (fg(dg.fetch)) return !0; let e = !1; const t = dg.document; if (t && "function" == typeof t.createElement) try { const n = t.createElement("iframe"); n.hidden = !0, t.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (e = fg(n.contentWindow.fetch)), t.head.removeChild(n) } catch (n) { bm && Em.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n) } return e })() && Rm(dm, "fetch", (function (e) { return function (...t) { const { method: n, url: r } = function (e) { if (0 === e.length) return { method: "GET", url: "" }; if (2 === e.length) { const [t, n] = e; return { url: yg(t), method: gg(n, "method") ? String(n.method).toUpperCase() : "GET" } } const t = e[0]; return { url: yg(t), method: gg(t, "method") ? String(t.method).toUpperCase() : "GET" } }(t), o = { args: t, fetchData: { method: n, url: r }, startTimestamp: Date.now() }; return Km("fetch", { ...o }), e.apply(dm, t).then((e => (Km("fetch", { ...o, endTimestamp: Date.now(), response: e }), e)), (e => { throw Km("fetch", { ...o, endTimestamp: Date.now(), error: e }), e })) } })) } function gg(e, t) { return !!e && "object" == typeof e && !!e[t] } function yg(e) { return "string" == typeof e ? e : e ? gg(e, "url") ? e.url : e.toString ? e.toString() : "" : "" } let _g = null; function vg(e) { const t = "error"; Gm(t, e), Jm(t, bg) } function bg() { _g = dm.onerror, dm.onerror = function (e, t, n, r, o) { return Km("error", { column: r, error: o, line: n, msg: e, url: t }), !(!_g || _g.__SENTRY_LOADER__) && _g.apply(this, arguments) }, dm.onerror.__SENTRY_INSTRUMENTED__ = !0 } let wg = null; function Sg(e) { const t = "unhandledrejection"; Gm(t, e), Jm(t, kg) } function kg() { wg = dm.onunhandledrejection, dm.onunhandledrejection = function (e) { return Km("unhandledrejection", e), !(wg && !wg.__SENTRY_LOADER__) || wg.apply(this, arguments) }, dm.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0 } const Eg = pm(); const Tg = dm; let xg; function Cg(e) { const t = "history"; Gm(t, e), Jm(t, Og) } function Og() { if (!function () { const e = Eg.chrome, t = e && e.app && e.app.runtime, n = "history" in Eg && !!Eg.history.pushState && !!Eg.history.replaceState; return !t && n }()) return; const e = Tg.onpopstate; function t(e) { return function (...t) { const n = t.length > 2 ? t[2] : void 0; if (n) { const e = xg, t = String(n); xg = t; Km("history", { from: e, to: t }) } return e.apply(this, t) } } Tg.onpopstate = function (...t) { const n = Tg.location.href, r = xg; xg = n; if (Km("history", { from: r, to: n }), e) try { return e.apply(this, t) } catch (o) { } }, Rm(Tg.history, "pushState", t), Rm(Tg.history, "replaceState", t) } const Ag = dm, Rg = "__sentry_xhr_v3__"; function Ig(e) { Gm("xhr", e), Jm("xhr", $g) } function $g() { if (!Ag.XMLHttpRequest) return; const e = XMLHttpRequest.prototype; Rm(e, "open", (function (e) { return function (...t) { const n = Date.now(), r = Gh(t[0]) ? t[0].toUpperCase() : void 0, o = function (e) { if (Gh(e)) return e; try { return e.toString() } catch (t) { } return }(t[1]); if (!r || !o) return e.apply(this, t); this[Rg] = { method: r, url: o, request_headers: {} }, "POST" === r && o.match(/sentry_key/) && (this.__sentry_own_request__ = !0); const s = () => { const e = this[Rg]; if (e && 4 === this.readyState) { try { e.status_code = this.status } catch (t) { } Km("xhr", { args: [r, o], endTimestamp: Date.now(), startTimestamp: n, xhr: this }) } }; return "onreadystatechange" in this && "function" == typeof this.onreadystatechange ? Rm(this, "onreadystatechange", (function (e) { return function (...t) { return s(), e.apply(this, t) } })) : this.addEventListener("readystatechange", s), Rm(this, "setRequestHeader", (function (e) { return function (...t) { const [n, r] = t, o = this[Rg]; return o && Gh(n) && Gh(r) && (o.request_headers[n.toLowerCase()] = r), e.apply(this, t) } })), e.apply(this, t) } })), Rm(e, "send", (function (e) { return function (...t) { const n = this[Rg]; if (!n) return e.apply(this, t); void 0 !== t[0] && (n.body = t[0]); return Km("xhr", { args: [n.method, n.url], startTimestamp: Date.now(), xhr: this }), e.apply(this, t) } })) } function Pg() { return !("undefined" != typeof __SENTRY_BROWSER_BUNDLE__ && __SENTRY_BROWSER_BUNDLE__) && "[object process]" === Object.prototype.toString.call("undefined" != typeof process ? process : 0) } function jg(e, t) { return e.require(t) } function Lg(e) { let t; try { t = jg(module, e) } catch (n) { } try { const { cwd: n } = jg(module, "process"); t = jg(module, `${n()}/node_modules/${e}`) } catch (n) { } return t } function Dg(e, t = 100, n = 1 / 0) { try { return Mg("", e, t, n) } catch (r) { return { ERROR: `**non-serializable** (${r})` } } } function Ng(e, t = 3, n = 102400) { const r = Dg(e, t); return o = r, function (e) { return ~-encodeURI(e).split(/%..|./).length }(JSON.stringify(o)) > n ? Ng(e, t - 1, n) : r; var o } function Mg(e, t, n = 1 / 0, r = 1 / 0, o = function () { const e = "function" == typeof WeakSet, t = e ? new WeakSet : []; return [function (n) { if (e) return !!t.has(n) || (t.add(n), !1); for (let e = 0; e < t.length; e++)if (t[e] === n) return !0; return t.push(n), !1 }, function (n) { if (e) t.delete(n); else for (let e = 0; e < t.length; e++)if (t[e] === n) { t.splice(e, 1); break } }] }()) { const [s, i] = o; if (null == t || ["number", "boolean", "string"].includes(typeof t) && !em(t)) return t; const a = function (e, t) { try { if ("domain" === e && t && "object" == typeof t && t._events) return "[Domain]"; if ("domainEmitter" === e) return "[DomainEmitter]"; if ("undefined" != typeof global && t === global) return "[Global]"; if ("undefined" != typeof window && t === window) return "[Window]"; if ("undefined" != typeof document && t === document) return "[Document]"; if (nm(t)) return "[VueViewModel]"; if (Yh(n = t) && "nativeEvent" in n && "preventDefault" in n && "stopPropagation" in n) return "[SyntheticEvent]"; if ("number" == typeof t && t != t) return "[NaN]"; if ("function" == typeof t) return `[Function: ${Vm(t)}]`; if ("symbol" == typeof t) return `[${String(t)}]`; if ("bigint" == typeof t) return `[BigInt: ${String(t)}]`; const r = function (e) { const t = Object.getPrototypeOf(e); return t ? t.constructor.name : "null prototype" }(t); return /^HTML(\w*)Element$/.test(r) ? `[HTMLElement: ${r}]` : `[object ${r}]` } catch (r) { return `**non-serializable** (${r})` } var n }(e, t); if (!a.startsWith("[object ")) return a; if (t.__sentry_skip_normalization__) return t; const c = "number" == typeof t.__sentry_override_normalization_depth__ ? t.__sentry_override_normalization_depth__ : n; if (0 === c) return a.replace("object ", ""); if (s(t)) return "[Circular ~]"; const l = t; if (l && "function" == typeof l.toJSON) try { return Mg("", l.toJSON(), c - 1, r, o) } catch (f) { } const u = Array.isArray(t) ? [] : {}; let d = 0; const p = jm(t); for (const h in p) { if (!Object.prototype.hasOwnProperty.call(p, h)) continue; if (d >= r) { u[h] = "[MaxProperties ~]"; break } const e = p[h]; u[h] = Mg(h, e, c - 1, r, o), d++ } return i(t), u } var Fg; function Ug(e) { return new Bg((t => { t(e) })) } function Hg(e) { return new Bg(((t, n) => { n(e) })) } !function (e) { e[e.PENDING = 0] = "PENDING"; e[e.RESOLVED = 1] = "RESOLVED"; e[e.REJECTED = 2] = "REJECTED" }(Fg || (Fg = {})); class Bg { constructor(e) { Bg.prototype.__init.call(this), Bg.prototype.__init2.call(this), Bg.prototype.__init3.call(this), Bg.prototype.__init4.call(this), this._state = Fg.PENDING, this._handlers = []; try { e(this._resolve, this._reject) } catch (t) { this._reject(t) } } then(e, t) { return new Bg(((n, r) => { this._handlers.push([!1, t => { if (e) try { n(e(t)) } catch (o) { r(o) } else n(t) }, e => { if (t) try { n(t(e)) } catch (o) { r(o) } else r(e) }]), this._executeHandlers() })) } catch(e) { return this.then((e => e), e) } finally(e) { return new Bg(((t, n) => { let r, o; return this.then((t => { o = !1, r = t, e && e() }), (t => { o = !0, r = t, e && e() })).then((() => { o ? n(r) : t(r) })) })) } __init() { this._resolve = e => { this._setResult(Fg.RESOLVED, e) } } __init2() { this._reject = e => { this._setResult(Fg.REJECTED, e) } } __init3() { this._setResult = (e, t) => { this._state === Fg.PENDING && (Zh(t) ? t.then(this._resolve, this._reject) : (this._state = e, this._value = t, this._executeHandlers())) } } __init4() { this._executeHandlers = () => { if (this._state === Fg.PENDING) return; const e = this._handlers.slice(); this._handlers = [], e.forEach((e => { e[0] || (this._state === Fg.RESOLVED && e[1](this._value), this._state === Fg.REJECTED && e[2](this._value), e[0] = !0) })) } } } function qg(e) { const t = []; function n(e) { return t.splice(t.indexOf(e), 1)[0] } return { $: t, add: function (r) { if (!(void 0 === e || t.length < e)) return Hg(new Am("Not adding Promise because buffer limit was reached.")); const o = r(); return -1 === t.indexOf(o) && t.push(o), o.then((() => n(o))).then(null, (() => n(o).then(null, (() => { })))), o }, drain: function (e) { return new Bg(((n, r) => { let o = t.length; if (!o) return n(!0); const s = setTimeout((() => { e && e > 0 && n(!1) }), e); t.forEach((e => { Ug(e).then((() => { --o || (clearTimeout(s), n(!0)) }), r) })) })) } } } function Vg(e) { if (!e) return {}; const t = e.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/); if (!t) return {}; const n = t[6] || "", r = t[8] || ""; return { host: t[4], path: t[5], protocol: t[2], search: n, hash: r, relative: t[5] + n + r } } function Wg(e) { return e.split(/[\?#]/, 1)[0] } function zg(e) { return e.split(/\\?\//).filter((e => e.length > 0 && "," !== e)).length } const Gg = ["fatal", "error", "warning", "log", "info", "debug"]; function Jg(e) { return "warn" === e ? "warning" : Gg.includes(e) ? e : "log" } const Kg = 1e3; function Yg() { return Date.now() / Kg } const Qg = function () { const { performance: e } = dm; if (!e || !e.now) return Yg; const t = Date.now() - e.now(), n = null == e.timeOrigin ? t : e.timeOrigin; return () => (n + e.now()) / Kg }(), Xg = (() => { const { performance: e } = dm; if (!e || !e.now) return; const t = 36e5, n = e.now(), r = Date.now(), o = e.timeOrigin ? Math.abs(e.timeOrigin + n - r) : t, s = o < t, i = e.timing && e.timing.navigationStart, a = "number" == typeof i ? Math.abs(i + n - r) : t; return s || a < t ? o <= a ? e.timeOrigin : i : r })(), Zg = "baggage", ey = "sentry-", ty = /^sentry-/, ny = 8192; function ry(e) { if (!e) return; return function (e) { if (0 === Object.keys(e).length) return; return Object.entries(e).reduce(((e, [t, n], r) => { const o = `${encodeURIComponent(t)}=${encodeURIComponent(n)}`, s = 0 === r ? o : `${e},${o}`; return s.length > ny ? (bm && Em.warn(`Not adding key: ${t} with val: ${n} to baggage header due to exceeding baggage size limits.`), e) : s }), "") }(Object.entries(e).reduce(((e, [t, n]) => (n && (e[`${ey}${t}`] = n), e)), {})) } function oy(e) { return e.split(",").map((e => e.split("=").map((e => decodeURIComponent(e.trim()))))).reduce(((e, [t, n]) => (e[t] = n, e)), {}) } const sy = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"); function iy(e, t) { const n = function (e) { if (!e) return; const t = e.match(sy); if (!t) return; let n; return "1" === t[3] ? n = !0 : "0" === t[3] && (n = !1), { traceId: t[1], parentSampled: n, parentSpanId: t[2] } }(e), r = function (e) { if (!Gh(e) && !Array.isArray(e)) return; let t = {}; if (Array.isArray(e)) t = e.reduce(((e, t) => { const n = oy(t); for (const r of Object.keys(n)) e[r] = n[r]; return e }), {}); else { if (!e) return; t = oy(e) } const n = Object.entries(t).reduce(((e, [t, n]) => (t.match(ty) && (e[t.slice(ey.length)] = n), e)), {}); return Object.keys(n).length > 0 ? n : void 0 }(t), { traceId: o, parentSpanId: s, parentSampled: i } = n || {}; return n ? { traceId: o || Qm(), parentSpanId: s || Qm().substring(16), spanId: Qm().substring(16), sampled: i, dsc: r || {} } : { traceId: o || Qm(), spanId: Qm().substring(16) } } function ay(e = Qm(), t = Qm().substring(16), n) { let r = ""; return void 0 !== n && (r = n ? "-1" : "-0"), `${e}-${t}${r}` } function cy(e, t = []) { return [e, t] } function ly(e, t) { const [n, r] = e; return [n, [...r, t]] } function uy(e, t) { const n = e[1]; for (const r of n) { if (t(r, r[0].type)) return !0 } return !1 } function dy(e, t) { return (t || new TextEncoder).encode(e) } function py(e, t) { const [n, r] = e; let o = JSON.stringify(n); function s(e) { "string" == typeof o ? o = "string" == typeof e ? o + e : [dy(o, t), e] : o.push("string" == typeof e ? dy(e, t) : e) } for (const a of r) { const [e, t] = a; if (s(`\n${JSON.stringify(e)}\n`), "string" == typeof t || t instanceof Uint8Array) s(t); else { let e; try { e = JSON.stringify(t) } catch (i) { e = JSON.stringify(Dg(t)) } s(e) } } return "string" == typeof o ? o : function (e) { const t = e.reduce(((e, t) => e + t.length), 0), n = new Uint8Array(t); let r = 0; for (const o of e) n.set(o, r), r += o.length; return n }(o) } function fy(e, t) { const n = "string" == typeof e.data ? dy(e.data, t) : e.data; return [Nm({ type: "attachment", length: n.length, filename: e.filename, content_type: e.contentType, attachment_type: e.attachmentType }), n] } const hy = { session: "session", sessions: "session", attachment: "attachment", transaction: "transaction", event: "error", client_report: "internal", user_report: "default", profile: "profile", replay_event: "replay", replay_recording: "replay", check_in: "monitor", feedback: "feedback", span: "span", statsd: "statsd" }; function my(e) { return hy[e] } function gy(e) { if (!e || !e.sdk) return; const { name: t, version: n } = e.sdk; return { name: t, version: n } } const yy = 6e4; function _y(e, { statusCode: t, headers: n }, r = Date.now()) { const o = { ...e }, s = n && n["x-sentry-rate-limits"], i = n && n["retry-after"]; if (s) for (const a of s.trim().split(",")) { const [e, t] = a.split(":", 2), n = parseInt(e, 10), s = 1e3 * (isNaN(n) ? 60 : n); if (t) for (const i of t.split(";")) o[i] = r + s; else o.all = r + s } else i ? o.all = r + function (e, t = Date.now()) { const n = parseInt(`${e}`, 10); if (!isNaN(n)) return 1e3 * n; const r = Date.parse(`${e}`); return isNaN(r) ? yy : r - t }(i, r) : 429 === t && (o.all = r + 6e4); return o } function vy(e) { let t, n = e[0], r = 1; for (; r < e.length;) { const o = e[r], s = e[r + 1]; if (r += 2, ("optionalAccess" === o || "optionalCall" === o) && null == n) return; "access" === o || "optionalAccess" === o ? (t = n, n = s(n)) : "call" !== o && "optionalCall" !== o || (n = s(((...e) => n.call(t, ...e))), t = void 0) } return n } const by = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__, wy = "production"; function Sy() { return fm("globalEventProcessors", (() => [])) } function ky(e) { Sy().push(e) } function Ey(e, t, n, r = 0) { return new Bg(((o, s) => { const i = e[r]; if (null === t || "function" != typeof i) o(t); else { const a = i({ ...t }, n); by && i.id && null === a && Em.log(`Event processor "${i.id}" dropped event`), Zh(a) ? a.then((t => Ey(e, t, n, r + 1).then(o))).then(null, s) : Ey(e, a, n, r + 1).then(o).then(null, s) } })) } function Ty(e) { const t = Qg(), n = { sid: Qm(), init: !0, timestamp: t, started: t, duration: 0, status: "ok", errors: 0, ignoreDuration: !1, toJSON: () => function (e) { return Nm({ sid: `${e.sid}`, init: e.init, started: new Date(1e3 * e.started).toISOString(), timestamp: new Date(1e3 * e.timestamp).toISOString(), status: e.status, errors: e.errors, did: "number" == typeof e.did || "string" == typeof e.did ? `${e.did}` : void 0, duration: e.duration, abnormal_mechanism: e.abnormal_mechanism, attrs: { release: e.release, environment: e.environment, ip_address: e.ipAddress, user_agent: e.userAgent } }) }(n) }; return e && xy(n, e), n } function xy(e, t = {}) { if (t.user && (!e.ipAddress && t.user.ip_address && (e.ipAddress = t.user.ip_address), e.did || t.did || (e.did = t.user.id || t.user.email || t.user.username)), e.timestamp = t.timestamp || Qg(), t.abnormal_mechanism && (e.abnormal_mechanism = t.abnormal_mechanism), t.ignoreDuration && (e.ignoreDuration = t.ignoreDuration), t.sid && (e.sid = 32 === t.sid.length ? t.sid : Qm()), void 0 !== t.init && (e.init = t.init), !e.did && t.did && (e.did = `${t.did}`), "number" == typeof t.started && (e.started = t.started), e.ignoreDuration) e.duration = void 0; else if ("number" == typeof t.duration) e.duration = t.duration; else { const t = e.timestamp - e.started; e.duration = t >= 0 ? t : 0 } t.release && (e.release = t.release), t.environment && (e.environment = t.environment), !e.ipAddress && t.ipAddress && (e.ipAddress = t.ipAddress), !e.userAgent && t.userAgent && (e.userAgent = t.userAgent), "number" == typeof t.errors && (e.errors = t.errors), t.status && (e.status = t.status) } function Cy(e, t) { let n = {}; t ? n = { status: t } : "ok" === e.status && (n = { status: "exited" }), xy(e, n) } const Oy = 1; function Ay(e) { const { spanId: t, traceId: n } = e.spanContext(), { data: r, op: o, parent_span_id: s, status: i, tags: a, origin: c } = Py(e); return Nm({ data: r, op: o, parent_span_id: s, span_id: t, status: i, tags: a, trace_id: n, origin: c }) } function Ry(e) { const { traceId: t, spanId: n } = e.spanContext(); return ay(t, n, jy(e)) } function Iy(e) { return "number" == typeof e ? $y(e) : Array.isArray(e) ? e[0] + e[1] / 1e9 : e instanceof Date ? $y(e.getTime()) : Qg() } function $y(e) { return e > 9999999999 ? e / 1e3 : e } function Py(e) { return function (e) { return "function" == typeof e.getSpanJSON }(e) ? e.getSpanJSON() : "function" == typeof e.toJSON ? e.toJSON() : {} } function jy(e) { const { traceFlags: t } = e.spanContext(); return Boolean(t & Oy) } function Ly(e, t, n, r, o, s) { const { normalizeDepth: i = 3, normalizeMaxBreadth: a = 1e3 } = e, c = { ...t, event_id: t.event_id || n.event_id || Qm(), timestamp: t.timestamp || Yg() }, l = n.integrations || e.integrations.map((e => e.name)); !function (e, t) { const { environment: n, release: r, dist: o, maxValueLength: s = 250 } = t; "environment" in e || (e.environment = "environment" in t ? n : wy); void 0 === e.release && void 0 !== r && (e.release = r); void 0 === e.dist && void 0 !== o && (e.dist = o); e.message && (e.message = rm(e.message, s)); const i = e.exception && e.exception.values && e.exception.values[0]; i && i.value && (i.value = rm(i.value, s)); const a = e.request; a && a.url && (a.url = rm(a.url, s)) }(c, e), function (e, t) { t.length > 0 && (e.sdk = e.sdk || {}, e.sdk.integrations = [...e.sdk.integrations || [], ...t]) }(c, l), void 0 === t.type && function (e, t) { const n = dm._sentryDebugIds; if (!n) return; let r; const o = Dy.get(t); o ? r = o : (r = new Map, Dy.set(t, r)); const s = Object.keys(n).reduce(((e, o) => { let s; const i = r.get(o); i ? s = i : (s = t(o), r.set(o, s)); for (let t = s.length - 1; t >= 0; t--) { const r = s[t]; if (r.filename) { e[r.filename] = n[o]; break } } return e }), {}); try { e.exception.values.forEach((e => { e.stacktrace.frames.forEach((e => { e.filename && (e.debug_id = s[e.filename]) })) })) } catch (i) { } }(c, e.stackParser); const u = function (e, t) { if (!t) return e; const n = e ? e.clone() : new n_; return n.update(t), n }(r, n.captureContext); n.mechanism && tg(c, n.mechanism); const d = o && o.getEventProcessors ? o.getEventProcessors() : [], p = function () { t_ || (t_ = new n_); return t_ }().getScopeData(); if (s) { Zy(p, s.getScopeData()) } if (u) { Zy(p, u.getScopeData()) } const f = [...n.attachments || [], ...p.attachments]; f.length && (n.attachments = f), Xy(c, p); return Ey([...d, ...Sy(), ...p.eventProcessors], c, n).then((e => (e && function (e) { const t = {}; try { e.exception.values.forEach((e => { e.stacktrace.frames.forEach((e => { e.debug_id && (e.abs_path ? t[e.abs_path] = e.debug_id : e.filename && (t[e.filename] = e.debug_id), delete e.debug_id) })) })) } catch (r) { } if (0 === Object.keys(t).length) return; e.debug_meta = e.debug_meta || {}, e.debug_meta.images = e.debug_meta.images || []; const n = e.debug_meta.images; Object.keys(t).forEach((e => { n.push({ type: "sourcemap", code_file: e, debug_id: t[e] }) })) }(e), "number" == typeof i && i > 0 ? function (e, t, n) { if (!e) return null; const r = { ...e, ...e.breadcrumbs && { breadcrumbs: e.breadcrumbs.map((e => ({ ...e, ...e.data && { data: Dg(e.data, t, n) } }))) }, ...e.user && { user: Dg(e.user, t, n) }, ...e.contexts && { contexts: Dg(e.contexts, t, n) }, ...e.extra && { extra: Dg(e.extra, t, n) } }; e.contexts && e.contexts.trace && r.contexts && (r.contexts.trace = e.contexts.trace, e.contexts.trace.data && (r.contexts.trace.data = Dg(e.contexts.trace.data, t, n))); e.spans && (r.spans = e.spans.map((e => { const r = Py(e).data; return r && (e.data = Dg(r, t, n)), e }))); return r }(e, i, a) : e))) } const Dy = new WeakMap; function Ny(e) { if (e) return function (e) { return e instanceof n_ || "function" == typeof e }(e) || function (e) { return Object.keys(e).some((e => My.includes(e))) }(e) ? { captureContext: e } : e } const My = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"]; function Fy(e, t) { return u_().captureException(e, Ny(t)) } function Uy(e, t) { return u_().captureEvent(e, t) } function Hy(e, t) { u_().addBreadcrumb(e, t) } function By(...e) { const t = u_(); if (2 === e.length) { const [n, r] = e; return n ? t.withScope((() => (t.getStackTop().scope = n, r(n)))) : t.withScope(r) } return t.withScope(e[0]) } function qy() { return u_().getClient() } function Vy() { return u_().getScope() } function Wy(e) { const t = qy(), n = d_(), r = Vy(), { release: o, environment: s = wy } = t && t.getOptions() || {}, { userAgent: i } = dm.navigator || {}, a = Ty({ release: o, environment: s, user: r.getUser() || n.getUser(), ...i && { userAgent: i }, ...e }), c = n.getSession(); return c && "ok" === c.status && xy(c, { status: "exited" }), zy(), n.setSession(a), r.setSession(a), a } function zy() { const e = d_(), t = Vy(), n = t.getSession() || e.getSession(); n && Cy(n), Gy(), e.setSession(), t.setSession() } function Gy() { const e = d_(), t = Vy(), n = qy(), r = t.getSession() || e.getSession(); r && n && n.captureSession && n.captureSession(r) } function Jy(e = !1) { e ? zy() : Gy() } function Ky(e) { return e.transaction } function Yy(e, t, n) { const r = t.getOptions(), { publicKey: o } = t.getDsn() || {}, { segment: s } = n && n.getUser() || {}, i = Nm({ environment: r.environment || wy, release: r.release, user_segment: s, public_key: o, trace_id: e }); return t.emit && t.emit("createDsc", i), i } function Qy(e) { const t = qy(); if (!t) return {}; const n = Yy(Py(e).trace_id || "", t, Vy()), r = Ky(e); if (!r) return n; const o = r && r._frozenDynamicSamplingContext; if (o) return o; const { sampleRate: s, source: i } = r.metadata; null != s && (n.sample_rate = `${s}`); const a = Py(r); return i && "url" !== i && (n.transaction = a.description), n.sampled = String(jy(r)), t.emit && t.emit("createDsc", n), n } function Xy(e, t) { const { fingerprint: n, span: r, breadcrumbs: o, sdkProcessingMetadata: s } = t; !function (e, t) { const { extra: n, tags: r, user: o, contexts: s, level: i, transactionName: a } = t, c = Nm(n); c && Object.keys(c).length && (e.extra = { ...c, ...e.extra }); const l = Nm(r); l && Object.keys(l).length && (e.tags = { ...l, ...e.tags }); const u = Nm(o); u && Object.keys(u).length && (e.user = { ...u, ...e.user }); const d = Nm(s); d && Object.keys(d).length && (e.contexts = { ...d, ...e.contexts }); i && (e.level = i); a && (e.transaction = a) }(e, t), r && function (e, t) { e.contexts = { trace: Ay(t), ...e.contexts }; const n = Ky(t); if (n) { e.sdkProcessingMetadata = { dynamicSamplingContext: Qy(t), ...e.sdkProcessingMetadata }; const r = Py(n).description; r && (e.tags = { transaction: r, ...e.tags }) } }(e, r), function (e, t) { e.fingerprint = e.fingerprint ? rg(e.fingerprint) : [], t && (e.fingerprint = e.fingerprint.concat(t)); e.fingerprint && !e.fingerprint.length && delete e.fingerprint }(e, n), function (e, t) { const n = [...e.breadcrumbs || [], ...t]; e.breadcrumbs = n.length ? n : void 0 }(e, o), function (e, t) { e.sdkProcessingMetadata = { ...e.sdkProcessingMetadata, ...t } }(e, s) } function Zy(e, t) { const { extra: n, tags: r, user: o, contexts: s, level: i, sdkProcessingMetadata: a, breadcrumbs: c, fingerprint: l, eventProcessors: u, attachments: d, propagationContext: p, transactionName: f, span: h } = t; e_(e, "extra", n), e_(e, "tags", r), e_(e, "user", o), e_(e, "contexts", s), e_(e, "sdkProcessingMetadata", a), i && (e.level = i), f && (e.transactionName = f), h && (e.span = h), c.length && (e.breadcrumbs = [...e.breadcrumbs, ...c]), l.length && (e.fingerprint = [...e.fingerprint, ...l]), u.length && (e.eventProcessors = [...e.eventProcessors, ...u]), d.length && (e.attachments = [...e.attachments, ...d]), e.propagationContext = { ...e.propagationContext, ...p } } function e_(e, t, n) { if (n && Object.keys(n).length) { e[t] = { ...e[t] }; for (const r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[t][r] = n[r]) } } let t_; class n_ { constructor() { this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = r_() } static clone(e) { return e ? e.clone() : new n_ } clone() { const e = new n_; return e._breadcrumbs = [...this._breadcrumbs], e._tags = { ...this._tags }, e._extra = { ...this._extra }, e._contexts = { ...this._contexts }, e._user = this._user, e._level = this._level, e._span = this._span, e._session = this._session, e._transactionName = this._transactionName, e._fingerprint = this._fingerprint, e._eventProcessors = [...this._eventProcessors], e._requestSession = this._requestSession, e._attachments = [...this._attachments], e._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, e._propagationContext = { ...this._propagationContext }, e._client = this._client, e } setClient(e) { this._client = e } getClient() { return this._client } addScopeListener(e) { this._scopeListeners.push(e) } addEventProcessor(e) { return this._eventProcessors.push(e), this } setUser(e) { return this._user = e || { email: void 0, id: void 0, ip_address: void 0, segment: void 0, username: void 0 }, this._session && xy(this._session, { user: e }), this._notifyScopeListeners(), this } getUser() { return this._user } getRequestSession() { return this._requestSession } setRequestSession(e) { return this._requestSession = e, this } setTags(e) { return this._tags = { ...this._tags, ...e }, this._notifyScopeListeners(), this } setTag(e, t) { return this._tags = { ...this._tags, [e]: t }, this._notifyScopeListeners(), this } setExtras(e) { return this._extra = { ...this._extra, ...e }, this._notifyScopeListeners(), this } setExtra(e, t) { return this._extra = { ...this._extra, [e]: t }, this._notifyScopeListeners(), this } setFingerprint(e) { return this._fingerprint = e, this._notifyScopeListeners(), this } setLevel(e) { return this._level = e, this._notifyScopeListeners(), this } setTransactionName(e) { return this._transactionName = e, this._notifyScopeListeners(), this } setContext(e, t) { return null === t ? delete this._contexts[e] : this._contexts[e] = t, this._notifyScopeListeners(), this } setSpan(e) { return this._span = e, this._notifyScopeListeners(), this } getSpan() { return this._span } getTransaction() { const e = this._span; return e && e.transaction } setSession(e) { return e ? this._session = e : delete this._session, this._notifyScopeListeners(), this } getSession() { return this._session } update(e) { if (!e) return this; const t = "function" == typeof e ? e(this) : e; if (t instanceof n_) { const e = t.getScopeData(); this._tags = { ...this._tags, ...e.tags }, this._extra = { ...this._extra, ...e.extra }, this._contexts = { ...this._contexts, ...e.contexts }, e.user && Object.keys(e.user).length && (this._user = e.user), e.level && (this._level = e.level), e.fingerprint.length && (this._fingerprint = e.fingerprint), t.getRequestSession() && (this._requestSession = t.getRequestSession()), e.propagationContext && (this._propagationContext = e.propagationContext) } else if (Yh(t)) { const t = e; this._tags = { ...this._tags, ...t.tags }, this._extra = { ...this._extra, ...t.extra }, this._contexts = { ...this._contexts, ...t.contexts }, t.user && (this._user = t.user), t.level && (this._level = t.level), t.fingerprint && (this._fingerprint = t.fingerprint), t.requestSession && (this._requestSession = t.requestSession), t.propagationContext && (this._propagationContext = t.propagationContext) } return this } clear() { return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), this._attachments = [], this._propagationContext = r_(), this } addBreadcrumb(e, t) { const n = "number" == typeof t ? t : 100; if (n <= 0) return this; const r = { timestamp: Yg(), ...e }, o = this._breadcrumbs; return o.push(r), this._breadcrumbs = o.length > n ? o.slice(-n) : o, this._notifyScopeListeners(), this } getLastBreadcrumb() { return this._breadcrumbs[this._breadcrumbs.length - 1] } clearBreadcrumbs() { return this._breadcrumbs = [], this._notifyScopeListeners(), this } addAttachment(e) { return this._attachments.push(e), this } getAttachments() { return this.getScopeData().attachments } clearAttachments() { return this._attachments = [], this } getScopeData() { const { _breadcrumbs: e, _attachments: t, _contexts: n, _tags: r, _extra: o, _user: s, _level: i, _fingerprint: a, _eventProcessors: c, _propagationContext: l, _sdkProcessingMetadata: u, _transactionName: d, _span: p } = this; return { breadcrumbs: e, attachments: t, contexts: n, tags: r, extra: o, user: s, level: i, fingerprint: a || [], eventProcessors: c, propagationContext: l, sdkProcessingMetadata: u, transactionName: d, span: p } } applyToEvent(e, t = {}, n = []) { Xy(e, this.getScopeData()); return Ey([...n, ...Sy(), ...this._eventProcessors], e, t) } setSDKProcessingMetadata(e) { return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...e }, this } setPropagationContext(e) { return this._propagationContext = e, this } getPropagationContext() { return this._propagationContext } captureException(e, t) { const n = t && t.event_id ? t.event_id : Qm(); if (!this._client) return Em.warn("No client configured on scope - will not capture exception!"), n; const r = new Error("Sentry syntheticException"); return this._client.captureException(e, { originalException: e, syntheticException: r, ...t, event_id: n }, this), n } captureMessage(e, t, n) { const r = n && n.event_id ? n.event_id : Qm(); if (!this._client) return Em.warn("No client configured on scope - will not capture message!"), r; const o = new Error(e); return this._client.captureMessage(e, t, { originalException: e, syntheticException: o, ...n, event_id: r }, this), r } captureEvent(e, t) { const n = t && t.event_id ? t.event_id : Qm(); return this._client ? (this._client.captureEvent(e, { ...t, event_id: n }, this), n) : (Em.warn("No client configured on scope - will not capture event!"), n) } _notifyScopeListeners() { this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((e => { e(this) })), this._notifyingListeners = !1) } } function r_() { return { traceId: Qm(), spanId: Qm().substring(16) } } const o_ = "7.109.0", s_ = parseFloat(o_), i_ = 100; class a_ { constructor(e, t, n, r = s_) { let o, s; this._version = r, t ? o = t : (o = new n_, o.setClient(e)), n ? s = n : (s = new n_, s.setClient(e)), this._stack = [{ scope: o }], e && this.bindClient(e), this._isolationScope = s } isOlderThan(e) { return this._version < e } bindClient(e) { const t = this.getStackTop(); t.client = e, t.scope.setClient(e), e && e.setupIntegrations && e.setupIntegrations() } pushScope() { const e = this.getScope().clone(); return this.getStack().push({ client: this.getClient(), scope: e }), e } popScope() { return !(this.getStack().length <= 1) && !!this.getStack().pop() } withScope(e) { const t = this.pushScope(); let n; try { n = e(t) } catch (r) { throw this.popScope(), r } return Zh(n) ? n.then((e => (this.popScope(), e)), (e => { throw this.popScope(), e })) : (this.popScope(), n) } getClient() { return this.getStackTop().client } getScope() { return this.getStackTop().scope } getIsolationScope() { return this._isolationScope } getStack() { return this._stack } getStackTop() { return this._stack[this._stack.length - 1] } captureException(e, t) { const n = this._lastEventId = t && t.event_id ? t.event_id : Qm(), r = new Error("Sentry syntheticException"); return this.getScope().captureException(e, { originalException: e, syntheticException: r, ...t, event_id: n }), n } captureMessage(e, t, n) { const r = this._lastEventId = n && n.event_id ? n.event_id : Qm(), o = new Error(e); return this.getScope().captureMessage(e, t, { originalException: e, syntheticException: o, ...n, event_id: r }), r } captureEvent(e, t) { const n = t && t.event_id ? t.event_id : Qm(); return e.type || (this._lastEventId = n), this.getScope().captureEvent(e, { ...t, event_id: n }), n } lastEventId() { return this._lastEventId } addBreadcrumb(e, t) { const { scope: n, client: r } = this.getStackTop(); if (!r) return; const { beforeBreadcrumb: o = null, maxBreadcrumbs: s = i_ } = r.getOptions && r.getOptions() || {}; if (s <= 0) return; const i = { timestamp: Yg(), ...e }, a = o ? km((() => o(i, t))) : i; null !== a && (r.emit && r.emit("beforeAddBreadcrumb", a, t), n.addBreadcrumb(a, s)) } setUser(e) { this.getScope().setUser(e), this.getIsolationScope().setUser(e) } setTags(e) { this.getScope().setTags(e), this.getIsolationScope().setTags(e) } setExtras(e) { this.getScope().setExtras(e), this.getIsolationScope().setExtras(e) } setTag(e, t) { this.getScope().setTag(e, t), this.getIsolationScope().setTag(e, t) } setExtra(e, t) { this.getScope().setExtra(e, t), this.getIsolationScope().setExtra(e, t) } setContext(e, t) { this.getScope().setContext(e, t), this.getIsolationScope().setContext(e, t) } configureScope(e) { const { scope: t, client: n } = this.getStackTop(); n && e(t) } run(e) { const t = l_(this); try { e(this) } finally { l_(t) } } getIntegration(e) { const t = this.getClient(); if (!t) return null; try { return t.getIntegration(e) } catch (n) { return by && Em.warn(`Cannot retrieve integration ${e.id} from the current Hub`), null } } startTransaction(e, t) { const n = this._callExtensionMethod("startTransaction", e, t); if (by && !n) { this.getClient() ? Em.warn("Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':\nSentry.addTracingExtensions();\nSentry.init({...});\n") : Em.warn("Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'") } return n } traceHeaders() { return this._callExtensionMethod("traceHeaders") } captureSession(e = !1) { if (e) return this.endSession(); this._sendSessionUpdate() } endSession() { const e = this.getStackTop().scope, t = e.getSession(); t && Cy(t), this._sendSessionUpdate(), e.setSession() } startSession(e) { const { scope: t, client: n } = this.getStackTop(), { release: r, environment: o = wy } = n && n.getOptions() || {}, { userAgent: s } = dm.navigator || {}, i = Ty({ release: r, environment: o, user: t.getUser(), ...s && { userAgent: s }, ...e }), a = t.getSession && t.getSession(); return a && "ok" === a.status && xy(a, { status: "exited" }), this.endSession(), t.setSession(i), i } shouldSendDefaultPii() { const e = this.getClient(), t = e && e.getOptions(); return Boolean(t && t.sendDefaultPii) } _sendSessionUpdate() { const { scope: e, client: t } = this.getStackTop(), n = e.getSession(); n && t && t.captureSession && t.captureSession(n) } _callExtensionMethod(e, ...t) { const n = c_().__SENTRY__; if (n && n.extensions && "function" == typeof n.extensions[e]) return n.extensions[e].apply(this, t); by && Em.warn(`Extension method ${e} couldn't be found, doing nothing.`) } } function c_() { return dm.__SENTRY__ = dm.__SENTRY__ || { extensions: {}, hub: void 0 }, dm } function l_(e) { const t = c_(), n = p_(t); return f_(t, e), n } function u_() { const e = c_(); if (e.__SENTRY__ && e.__SENTRY__.acs) { const t = e.__SENTRY__.acs.getCurrentHub(); if (t) return t } return function (e = c_()) { t = e, t && t.__SENTRY__ && t.__SENTRY__.hub && !p_(e).isOlderThan(s_) || f_(e, new a_); var t; return p_(e) }(e) } function d_() { return u_().getIsolationScope() } function p_(e) { return fm("hub", (() => new a_), e) } function f_(e, t) { if (!e) return !1; return (e.__SENTRY__ = e.__SENTRY__ || {}).hub = t, !0 } function h_(e) { return (e || u_()).getScope().getTransaction() } let m_ = !1; function g_() { const e = h_(); if (e) { const t = "internal_error"; by && Em.log(`[Tracing] Transaction: ${t} -> Global error occured`), e.setStatus(t) } } var y_; function __(e, t) { e.setTag("http.status_code", String(t)), e.setData("http.response.status_code", t); const n = function (e) { if (e < 400 && e >= 100) return "ok"; if (e >= 400 && e < 500) switch (e) { case 401: return "unauthenticated"; case 403: return "permission_denied"; case 404: return "not_found"; case 409: return "already_exists"; case 413: return "failed_precondition"; case 429: return "resource_exhausted"; default: return "invalid_argument" }if (e >= 500 && e < 600) switch (e) { case 501: return "unimplemented"; case 503: return "unavailable"; case 504: return "deadline_exceeded"; default: return "internal_error" }return "unknown_error" }(t); "unknown_error" !== n && e.setStatus(n) } function v_(e, t, n = (() => { })) { let r; try { r = e() } catch (o) { throw t(o), n(), o } return function (e, t, n) { if (Zh(e)) return e.then((e => (n(), e)), (e => { throw t(e), n(), e })); return n(), e }(r, t, n) } function b_(e) { if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__) return !1; const t = qy(), n = e || t && t.getOptions(); return !!n && (n.enableTracing || "tracesSampleRate" in n || "tracesSampler" in n) } function w_(e, t) { const n = T_(e); return function (e, t = {}) { const n = c_(); return n.__SENTRY__ && n.__SENTRY__.acs ? n.__SENTRY__.acs.runWithAsyncContext(e, t) : e() }((() => By(e.scope, (r => { const o = u_(), s = r.getSpan(), i = e.onlyIfParent && !s ? void 0 : E_(o, { parentSpan: s, spanContext: n, forceTransaction: e.forceTransaction, scope: r }); return v_((() => t(i)), (() => { if (i) { const { status: e } = Py(i); e && "ok" !== e || i.setStatus("internal_error") } }), (() => i && i.end())) })))) } function S_(e) { if (!b_()) return; const t = T_(e), n = u_(), r = e.scope ? e.scope.getSpan() : k_(); if (e.onlyIfParent && !r) return; const o = (e.scope || Vy()).clone(); return E_(n, { parentSpan: r, spanContext: t, forceTransaction: e.forceTransaction, scope: o }) } function k_() { return Vy().getSpan() } function E_(e, { parentSpan: t, spanContext: n, forceTransaction: r, scope: o }) { if (!b_()) return; const s = d_(); let i; if (t && !r) i = t.startChild(n); else if (t) { const r = Qy(t), { traceId: o, spanId: s } = t.spanContext(), a = jy(t); i = e.startTransaction({ traceId: o, parentSpanId: s, parentSampled: a, ...n, metadata: { dynamicSamplingContext: r, ...n.metadata } }) } else { const { traceId: t, dsc: r, parentSpanId: a, sampled: c } = { ...s.getPropagationContext(), ...o.getPropagationContext() }; i = e.startTransaction({ traceId: t, parentSpanId: a, parentSampled: c, ...n, metadata: { dynamicSamplingContext: r, ...n.metadata } }) } return o.setSpan(i), function (e, t, n) { e && (Im(e, C_, n), Im(e, x_, t)) }(i, o, s), i } function T_(e) { if (e.startTime) { const t = { ...e }; return t.startTimestamp = Iy(e.startTime), delete t.startTime, t } return e } g_.tag = "sentry_tracingErrorCallback", function (e) { e.Ok = "ok"; e.DeadlineExceeded = "deadline_exceeded"; e.Unauthenticated = "unauthenticated"; e.PermissionDenied = "permission_denied"; e.NotFound = "not_found"; e.ResourceExhausted = "resource_exhausted"; e.InvalidArgument = "invalid_argument"; e.Unimplemented = "unimplemented"; e.Unavailable = "unavailable"; e.InternalError = "internal_error"; e.UnknownError = "unknown_error"; e.Cancelled = "cancelled"; e.AlreadyExists = "already_exists"; e.FailedPrecondition = "failed_precondition"; e.Aborted = "aborted"; e.OutOfRange = "out_of_range"; e.DataLoss = "data_loss" }(y_ || (y_ = {})); const x_ = "_sentryScope", C_ = "_sentryIsolationScope"; const O_ = "sentry.source", A_ = "sentry.sample_rate", R_ = "sentry.op", I_ = "sentry.origin"; class $_ { constructor(e = 1e3) { this._maxlen = e, this.spans = [] } add(e) { this.spans.length > this._maxlen ? e.spanRecorder = void 0 : this.spans.push(e) } } class P_ { constructor(e = {}) { this._traceId = e.traceId || Qm(), this._spanId = e.spanId || Qm().substring(16), this._startTime = e.startTimestamp || Qg(), this.tags = e.tags ? { ...e.tags } : {}, this.data = e.data ? { ...e.data } : {}, this.instrumenter = e.instrumenter || "sentry", this._attributes = {}, this.setAttributes({ [I_]: e.origin || "manual", [R_]: e.op, ...e.attributes }), this._name = e.name || e.description, e.parentSpanId && (this._parentSpanId = e.parentSpanId), "sampled" in e && (this._sampled = e.sampled), e.status && (this._status = e.status), e.endTimestamp && (this._endTime = e.endTimestamp), e.exclusiveTime && (this._exclusiveTime = e.exclusiveTime), this._measurements = e.measurements ? { ...e.measurements } : {} } get name() { return this._name || "" } set name(e) { this.updateName(e) } get description() { return this._name } set description(e) { this._name = e } get traceId() { return this._traceId } set traceId(e) { this._traceId = e } get spanId() { return this._spanId } set spanId(e) { this._spanId = e } set parentSpanId(e) { this._parentSpanId = e } get parentSpanId() { return this._parentSpanId } get sampled() { return this._sampled } set sampled(e) { this._sampled = e } get attributes() { return this._attributes } set attributes(e) { this._attributes = e } get startTimestamp() { return this._startTime } set startTimestamp(e) { this._startTime = e } get endTimestamp() { return this._endTime } set endTimestamp(e) { this._endTime = e } get status() { return this._status } set status(e) { this._status = e } get op() { return this._attributes[R_] } set op(e) { this.setAttribute(R_, e) } get origin() { return this._attributes[I_] } set origin(e) { this.setAttribute(I_, e) } spanContext() { const { _spanId: e, _traceId: t, _sampled: n } = this; return { spanId: e, traceId: t, traceFlags: n ? Oy : 0 } } startChild(e) { const t = new P_({ ...e, parentSpanId: this._spanId, sampled: this._sampled, traceId: this._traceId }); t.spanRecorder = this.spanRecorder, t.spanRecorder && t.spanRecorder.add(t); const n = Ky(this); if (t.transaction = n, by && n) { const r = `[Tracing] Starting '${e && e.op || "< unknown op >"}' span on transaction '${Py(t).description || "< unknown name >"}' (${n.spanContext().spanId}).`; Em.log(r), this._logMessage = r } return t } setTag(e, t) { return this.tags = { ...this.tags, [e]: t }, this } setData(e, t) { return this.data = { ...this.data, [e]: t }, this } setAttribute(e, t) { void 0 === t ? delete this._attributes[e] : this._attributes[e] = t } setAttributes(e) { Object.keys(e).forEach((t => this.setAttribute(t, e[t]))) } setStatus(e) { return this._status = e, this } setHttpStatus(e) { return __(this, e), this } setName(e) { this.updateName(e) } updateName(e) { return this._name = e, this } isSuccess() { return "ok" === this._status } finish(e) { return this.end(e) } end(e) { if (this._endTime) return; const t = Ky(this); if (by && t && t.spanContext().spanId !== this._spanId) { const e = this._logMessage; e && Em.log(e.replace("Starting", "Finishing")) } this._endTime = Iy(e) } toTraceparent() { return Ry(this) } toContext() { return Nm({ data: this._getData(), description: this._name, endTimestamp: this._endTime, op: this.op, parentSpanId: this._parentSpanId, sampled: this._sampled, spanId: this._spanId, startTimestamp: this._startTime, status: this._status, tags: this.tags, traceId: this._traceId }) } updateWithContext(e) { return this.data = e.data || {}, this._name = e.name || e.description, this._endTime = e.endTimestamp, this.op = e.op, this._parentSpanId = e.parentSpanId, this._sampled = e.sampled, this._spanId = e.spanId || this._spanId, this._startTime = e.startTimestamp || this._startTime, this._status = e.status, this.tags = e.tags || {}, this._traceId = e.traceId || this._traceId, this } getTraceContext() { return Ay(this) } getSpanJSON() { return Nm({ data: this._getData(), description: this._name, op: this._attributes[R_], parent_span_id: this._parentSpanId, span_id: this._spanId, start_timestamp: this._startTime, status: this._status, tags: Object.keys(this.tags).length > 0 ? this.tags : void 0, timestamp: this._endTime, trace_id: this._traceId, origin: this._attributes[I_], _metrics_summary: void 0, profile_id: this._attributes.profile_id, exclusive_time: this._exclusiveTime, measurements: Object.keys(this._measurements).length > 0 ? this._measurements : void 0 }) } isRecording() { return !this._endTime && !!this._sampled } toJSON() { return this.getSpanJSON() } _getData() { const { data: e, _attributes: t } = this, n = Object.keys(e).length > 0, r = Object.keys(t).length > 0; if (n || r) return n && r ? { ...e, ...t } : n ? e : t } } class j_ extends P_ { constructor(e, t) { super(e), this._contexts = {}, this._hub = t || u_(), this._name = e.name || "", this._metadata = { ...e.metadata }, this._trimEnd = e.trimEnd, this.transaction = this; const n = this._metadata.dynamicSamplingContext; n && (this._frozenDynamicSamplingContext = { ...n }) } get name() { return this._name } set name(e) { this.setName(e) } get metadata() { return { source: "custom", spanMetadata: {}, ...this._metadata, ...this._attributes[O_] && { source: this._attributes[O_] }, ...this._attributes[A_] && { sampleRate: this._attributes[A_] } } } set metadata(e) { this._metadata = e } setName(e, t = "custom") { this._name = e, this.setAttribute(O_, t) } updateName(e) { return this._name = e, this } initSpanRecorder(e = 1e3) { this.spanRecorder || (this.spanRecorder = new $_(e)), this.spanRecorder.add(this) } setContext(e, t) { null === t ? delete this._contexts[e] : this._contexts[e] = t } setMeasurement(e, t, n = "") { this._measurements[e] = { value: t, unit: n } } setMetadata(e) { this._metadata = { ...this._metadata, ...e } } end(e) { const t = Iy(e), n = this._finishTransaction(t); if (n) return this._hub.captureEvent(n) } toContext() { return Nm({ ...super.toContext(), name: this._name, trimEnd: this._trimEnd }) } updateWithContext(e) { return super.updateWithContext(e), this._name = e.name || "", this._trimEnd = e.trimEnd, this } getDynamicSamplingContext() { return Qy(this) } setHub(e) { this._hub = e } getProfileId() { if (void 0 !== this._contexts && void 0 !== this._contexts.profile) return this._contexts.profile.profile_id } _finishTransaction(e) { if (void 0 !== this._endTime) return; this._name || (by && Em.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this._name = "<unlabeled transaction>"), super.end(e); const t = this._hub.getClient(); if (t && t.emit && t.emit("finishTransaction", this), !0 !== this._sampled) return by && Em.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."), void (t && t.recordDroppedEvent("sample_rate", "transaction")); const n = this.spanRecorder ? this.spanRecorder.spans.filter((e => e !== this && Py(e).timestamp)) : []; if (this._trimEnd && n.length > 0) { const e = n.map((e => Py(e).timestamp)).filter(Boolean); this._endTime = e.reduce(((e, t) => e > t ? e : t)) } const { scope: r, isolationScope: o } = { scope: (s = this)[x_], isolationScope: s[C_] }; var s; const { metadata: i } = this, { source: a } = i, c = { contexts: { ...this._contexts, trace: Ay(this) }, spans: n, start_timestamp: this._startTime, tags: this.tags, timestamp: this._endTime, transaction: this._name, type: "transaction", sdkProcessingMetadata: { ...i, capturedSpanScope: r, capturedSpanIsolationScope: o, ...Nm({ dynamicSamplingContext: Qy(this) }) }, _metrics_summary: void 0, ...a && { transaction_info: { source: a } } }; return Object.keys(this._measurements).length > 0 && (by && Em.log("[Measurements] Adding measurements to transaction", JSON.stringify(this._measurements, void 0, 2)), c.measurements = this._measurements), by && Em.log(`[Tracing] Finishing ${this.op} transaction: ${this._name}.`), c } } const L_ = { idleTimeout: 1e3, finalTimeout: 3e4, heartbeatInterval: 5e3 }, D_ = ["heartbeatFailed", "idleTimeout", "documentHidden", "finalTimeout", "externalFinish", "cancelled"]; class N_ extends $_ { constructor(e, t, n, r) { super(r), this._pushActivity = e, this._popActivity = t, this.transactionSpanId = n } add(e) { if (e.spanContext().spanId !== this.transactionSpanId) { const t = e.end; e.end = (...n) => (this._popActivity(e.spanContext().spanId), t.apply(e, n)), void 0 === Py(e).timestamp && this._pushActivity(e.spanContext().spanId) } super.add(e) } } class M_ extends j_ { constructor(e, t, n = L_.idleTimeout, r = L_.finalTimeout, o = L_.heartbeatInterval, s = !1, i = !1) { super(e, t), this._idleHub = t, this._idleTimeout = n, this._finalTimeout = r, this._heartbeatInterval = o, this._onScope = s, this.activities = {}, this._heartbeatCounter = 0, this._finished = !1, this._idleTimeoutCanceledPermanently = !1, this._beforeFinishCallbacks = [], this._finishReason = D_[4], this._autoFinishAllowed = !i, s && (by && Em.log(`Setting idle transaction on scope. Span ID: ${this.spanContext().spanId}`), t.getScope().setSpan(this)), i || this._restartIdleTimeout(), setTimeout((() => { this._finished || (this.setStatus("deadline_exceeded"), this._finishReason = D_[3], this.end()) }), this._finalTimeout) } end(e) { const t = Iy(e); if (this._finished = !0, this.activities = {}, "ui.action.click" === this.op && this.setAttribute("finishReason", this._finishReason), this.spanRecorder) { by && Em.log("[Tracing] finishing IdleTransaction", new Date(1e3 * t).toISOString(), this.op); for (const e of this._beforeFinishCallbacks) e(this, t); this.spanRecorder.spans = this.spanRecorder.spans.filter((e => { if (e.spanContext().spanId === this.spanContext().spanId) return !0; Py(e).timestamp || (e.setStatus("cancelled"), e.end(t), by && Em.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(e, void 0, 2))); const { start_timestamp: n, timestamp: r } = Py(e), o = n && n < t, s = (this._finalTimeout + this._idleTimeout) / 1e3, i = r && n && r - n < s; if (by) { const t = JSON.stringify(e, void 0, 2); o ? i || Em.log("[Tracing] discarding Span since it finished after Transaction final timeout", t) : Em.log("[Tracing] discarding Span since it happened after Transaction was finished", t) } return o && i })), by && Em.log("[Tracing] flushing IdleTransaction") } else by && Em.log("[Tracing] No active IdleTransaction"); if (this._onScope) { const e = this._idleHub.getScope(); e.getTransaction() === this && e.setSpan(void 0) } return super.end(e) } registerBeforeFinishCallback(e) { this._beforeFinishCallbacks.push(e) } initSpanRecorder(e) { if (!this.spanRecorder) { const t = e => { this._finished || this._pushActivity(e) }, n = e => { this._finished || this._popActivity(e) }; this.spanRecorder = new N_(t, n, this.spanContext().spanId, e), by && Em.log("Starting heartbeat"), this._pingHeartbeat() } this.spanRecorder.add(this) } cancelIdleTimeout(e, { restartOnChildSpanChange: t } = { restartOnChildSpanChange: !0 }) { this._idleTimeoutCanceledPermanently = !1 === t, this._idleTimeoutID && (clearTimeout(this._idleTimeoutID), this._idleTimeoutID = void 0, 0 === Object.keys(this.activities).length && this._idleTimeoutCanceledPermanently && (this._finishReason = D_[5], this.end(e))) } setFinishReason(e) { this._finishReason = e } sendAutoFinishSignal() { this._autoFinishAllowed || (by && Em.log("[Tracing] Received finish signal for idle transaction."), this._restartIdleTimeout(), this._autoFinishAllowed = !0) } _restartIdleTimeout(e) { this.cancelIdleTimeout(), this._idleTimeoutID = setTimeout((() => { this._finished || 0 !== Object.keys(this.activities).length || (this._finishReason = D_[1], this.end(e)) }), this._idleTimeout) } _pushActivity(e) { this.cancelIdleTimeout(void 0, { restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently }), by && Em.log(`[Tracing] pushActivity: ${e}`), this.activities[e] = !0, by && Em.log("[Tracing] new activities count", Object.keys(this.activities).length) } _popActivity(e) { if (this.activities[e] && (by && Em.log(`[Tracing] popActivity ${e}`), delete this.activities[e], by && Em.log("[Tracing] new activities count", Object.keys(this.activities).length)), 0 === Object.keys(this.activities).length) { const e = Qg(); this._idleTimeoutCanceledPermanently ? this._autoFinishAllowed && (this._finishReason = D_[5], this.end(e)) : this._restartIdleTimeout(e + this._idleTimeout / 1e3) } } _beat() { if (this._finished) return; const e = Object.keys(this.activities).join(""); e === this._prevHeartbeatString ? this._heartbeatCounter++ : this._heartbeatCounter = 1, this._prevHeartbeatString = e, this._heartbeatCounter >= 3 ? this._autoFinishAllowed && (by && Em.log("[Tracing] Transaction finished because of no change for 3 heart beats"), this.setStatus("deadline_exceeded"), this._finishReason = D_[0], this.end()) : this._pingHeartbeat() } _pingHeartbeat() { by && Em.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`), setTimeout((() => { this._beat() }), this._heartbeatInterval) } } function F_(e, t, n) { if (!b_(t)) return e.sampled = !1, e; if (void 0 !== e.sampled) return e.setAttribute(A_, Number(e.sampled)), e; let r; return "function" == typeof t.tracesSampler ? (r = t.tracesSampler(n), e.setAttribute(A_, Number(r))) : void 0 !== n.parentSampled ? r = n.parentSampled : void 0 !== t.tracesSampleRate ? (r = t.tracesSampleRate, e.setAttribute(A_, Number(r))) : (r = 1, e.setAttribute(A_, r)), U_(r) ? r ? (e.sampled = Math.random() < r, e.sampled ? (by && Em.log(`[Tracing] starting ${e.op} transaction - ${Py(e).description}`), e) : (by && Em.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(r)})`), e)) : (by && Em.log("[Tracing] Discarding transaction because " + ("function" == typeof t.tracesSampler ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0")), e.sampled = !1, e) : (by && Em.warn("[Tracing] Discarding transaction because of invalid sample rate."), e.sampled = !1, e) } function U_(e) { return em(e) || "number" != typeof e && "boolean" != typeof e ? (by && Em.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(e)} of type ${JSON.stringify(typeof e)}.`), !1) : !(e < 0 || e > 1) || (by && Em.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${e}.`), !1) } function H_() { const e = this.getScope().getSpan(); return e ? { "sentry-trace": Ry(e) } : {} } function B_(e, t) { const n = this.getClient(), r = n && n.getOptions() || {}, o = r.instrumenter || "sentry", s = e.instrumenter || "sentry"; o !== s && (by && Em.error(`A transaction was started with instrumenter=\`${s}\`, but the SDK is configured with the \`${o}\` instrumenter.\nThe transaction will not be sampled. Please use the ${o} instrumentation to start transactions.`), e.sampled = !1); let i = new j_(e, this); return i = F_(i, r, { name: e.name, parentSampled: e.parentSampled, transactionContext: e, attributes: { ...e.data, ...e.attributes }, ...t }), i.isRecording() && i.initSpanRecorder(r._experiments && r._experiments.maxSpans), n && n.emit && n.emit("startTransaction", i), i } function q_(e, t, n, r, o, s, i, a = !1) { const c = e.getClient(), l = c && c.getOptions() || {}; let u = new M_(t, e, n, r, i, o, a); return u = F_(u, l, { name: t.name, parentSampled: t.parentSampled, transactionContext: t, attributes: { ...t.data, ...t.attributes }, ...s }), u.isRecording() && u.initSpanRecorder(l._experiments && l._experiments.maxSpans), c && c.emit && c.emit("startTransaction", u), u } function V_() { const e = c_(); e.__SENTRY__ && (e.__SENTRY__.extensions = e.__SENTRY__.extensions || {}, e.__SENTRY__.extensions.startTransaction || (e.__SENTRY__.extensions.startTransaction = B_), e.__SENTRY__.extensions.traceHeaders || (e.__SENTRY__.extensions.traceHeaders = H_), m_ || (m_ = !0, vg(g_), Sg(g_))) } function W_(e, t, n, r) { const o = gy(n), s = e.type && "replay_event" !== e.type ? e.type : "event"; !function (e, t) { t && (e.sdk = e.sdk || {}, e.sdk.name = e.sdk.name || t.name, e.sdk.version = e.sdk.version || t.version, e.sdk.integrations = [...e.sdk.integrations || [], ...t.integrations || []], e.sdk.packages = [...e.sdk.packages || [], ...t.packages || []]) }(e, n && n.sdk); const i = function (e, t, n, r) { const o = e.sdkProcessingMetadata && e.sdkProcessingMetadata.dynamicSamplingContext; return { event_id: e.event_id, sent_at: (new Date).toISOString(), ...t && { sdk: t }, ...!!n && r && { dsn: xm(r) }, ...o && { trace: Nm({ ...o }) } } }(e, o, r, t); delete e.sdkProcessingMetadata; return cy(i, [[{ type: s }, e]]) } const z_ = "7"; function G_(e, t) { return n = { sentry_key: e.publicKey, sentry_version: z_, ...t && { sentry_client: `${t.name}/${t.version}` } }, Object.keys(n).map((e => `${encodeURIComponent(e)}=${encodeURIComponent(n[e])}`)).join("&"); var n } const J_ = []; function K_(e) { const t = e.defaultIntegrations || [], n = e.integrations; let r; t.forEach((e => { e.isDefaultInstance = !0 })), r = Array.isArray(n) ? [...t, ...n] : "function" == typeof n ? rg(n(t)) : t; const o = function (e) { const t = {}; return e.forEach((e => { const { name: n } = e, r = t[n]; r && !r.isDefaultInstance && e.isDefaultInstance || (t[n] = e) })), Object.keys(t).map((e => t[e])) }(r), s = function (e, t) { for (let n = 0; n < e.length; n++)if (!0 === t(e[n])) return n; return -1 }(o, (e => "Debug" === e.name)); if (-1 !== s) { const [e] = o.splice(s, 1); o.push(e) } return o } function Y_(e, t) { for (const n of t) n && n.afterAllSetup && n.afterAllSetup(e) } function Q_(e, t, n) { if (n[t.name]) by && Em.log(`Integration skipped because it was already installed: ${t.name}`); else { if (n[t.name] = t, -1 === J_.indexOf(t.name) && (t.setupOnce(ky, u_), J_.push(t.name)), t.setup && "function" == typeof t.setup && t.setup(e), e.on && "function" == typeof t.preprocessEvent) { const n = t.preprocessEvent.bind(t); e.on("preprocessEvent", ((t, r) => n(t, r, e))) } if (e.addEventProcessor && "function" == typeof t.processEvent) { const n = t.processEvent.bind(t), r = Object.assign(((t, r) => n(t, r, e)), { id: t.name }); e.addEventProcessor(r) } by && Em.log(`Integration installed: ${t.name}`) } } function X_(e, t) { return Object.assign((function (...e) { return t(...e) }), { id: e }) } function Z_(e, t, n, r) { const o = { sent_at: (new Date).toISOString() }; n && n.sdk && (o.sdk = { name: n.sdk.name, version: n.sdk.version }), r && t && (o.dsn = xm(t)); const s = function (e) { const t = function (e) { let t = ""; for (const n of e) { const e = Object.entries(n.tags), r = e.length > 0 ? `|#${e.map((([e, t]) => `${e}:${t}`)).join(",")}` : ""; t += `${n.name}@${n.unit}:${n.metric}|${n.metricType}${r}|T${n.timestamp}\n` } return t }(e); return [{ type: "statsd", length: t.length }, t] }(e); return cy(o, [s]) } const ev = "Not capturing exception because it's already been captured."; class tv { constructor(e) { if (this._options = e, this._integrations = {}, this._integrationsInitialized = !1, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], e.dsn ? this._dsn = Om(e.dsn) : by && Em.warn("No DSN provided, client will not send events."), this._dsn) { const t = function (e, t = {}) { const n = "string" == typeof t ? t : t.tunnel, r = "string" != typeof t && t._metadata ? t._metadata.sdk : void 0; return n || `${function (e) { return `${function (e) { const t = e.protocol ? `${e.protocol}:` : "", n = e.port ? `:${e.port}` : ""; return `${t}//${e.host}${n}${e.path ? `/${e.path}` : ""}/api/` }(e)}${e.projectId}/envelope/` }(e)}?${G_(e, r)}` }(this._dsn, e); this._transport = e.transport({ recordDroppedEvent: this.recordDroppedEvent.bind(this), ...e.transportOptions, url: t }) } } captureException(e, t, n) { if (ng(e)) return void (by && Em.log(ev)); let r = t && t.event_id; return this._process(this.eventFromException(e, t).then((e => this._captureEvent(e, t, n))).then((e => { r = e }))), r } captureMessage(e, t, n, r) { let o = n && n.event_id; const s = Jh(e) ? e : String(e), i = Kh(e) ? this.eventFromMessage(s, t, n) : this.eventFromException(e, n); return this._process(i.then((e => this._captureEvent(e, n, r))).then((e => { o = e }))), o } captureEvent(e, t, n) { if (t && t.originalException && ng(t.originalException)) return void (by && Em.log(ev)); let r = t && t.event_id; const o = (e.sdkProcessingMetadata || {}).capturedSpanScope; return this._process(this._captureEvent(e, t, o || n).then((e => { r = e }))), r } captureSession(e) { "string" != typeof e.release ? by && Em.warn("Discarded session because of missing or non-string release") : (this.sendSession(e), xy(e, { init: !1 })) } getDsn() { return this._dsn } getOptions() { return this._options } getSdkMetadata() { return this._options._metadata } getTransport() { return this._transport } flush(e) { const t = this._transport; return t ? (this.metricsAggregator && this.metricsAggregator.flush(), this._isClientDoneProcessing(e).then((n => t.flush(e).then((e => n && e))))) : Ug(!0) } close(e) { return this.flush(e).then((e => (this.getOptions().enabled = !1, this.metricsAggregator && this.metricsAggregator.close(), e))) } getEventProcessors() { return this._eventProcessors } addEventProcessor(e) { this._eventProcessors.push(e) } setupIntegrations(e) { (e && !this._integrationsInitialized || this._isEnabled() && !this._integrationsInitialized) && this._setupIntegrations() } init() { this._isEnabled() && this._setupIntegrations() } getIntegrationById(e) { return this.getIntegrationByName(e) } getIntegrationByName(e) { return this._integrations[e] } getIntegration(e) { try { return this._integrations[e.id] || null } catch (t) { return by && Em.warn(`Cannot retrieve integration ${e.id} from the current Client`), null } } addIntegration(e) { const t = this._integrations[e.name]; Q_(this, e, this._integrations), t || Y_(this, [e]) } sendEvent(e, t = {}) { this.emit("beforeSendEvent", e, t); let n = W_(e, this._dsn, this._options._metadata, this._options.tunnel); for (const o of t.attachments || []) n = ly(n, fy(o, this._options.transportOptions && this._options.transportOptions.textEncoder)); const r = this._sendEnvelope(n); r && r.then((t => this.emit("afterSendEvent", e, t)), null) } sendSession(e) { const t = function (e, t, n, r) { const o = gy(n); return cy({ sent_at: (new Date).toISOString(), ...o && { sdk: o }, ...!!r && t && { dsn: xm(t) } }, ["aggregates" in e ? [{ type: "sessions" }, e] : [{ type: "session" }, e.toJSON()]]) }(e, this._dsn, this._options._metadata, this._options.tunnel); this._sendEnvelope(t) } recordDroppedEvent(e, t, n) { if (this._options.sendClientReports) { const n = `${e}:${t}`; by && Em.log(`Adding outcome: "${n}"`), this._outcomes[n] = this._outcomes[n] + 1 || 1 } } captureAggregateMetrics(e) { by && Em.log(`Flushing aggregated metrics, number of metrics: ${e.length}`); const t = Z_(e, this._dsn, this._options._metadata, this._options.tunnel); this._sendEnvelope(t) } on(e, t) { this._hooks[e] || (this._hooks[e] = []), this._hooks[e].push(t) } emit(e, ...t) { this._hooks[e] && this._hooks[e].forEach((e => e(...t))) } _setupIntegrations() { const { integrations: e } = this._options; this._integrations = function (e, t) { const n = {}; return t.forEach((t => { t && Q_(e, t, n) })), n }(this, e), Y_(this, e), this._integrationsInitialized = !0 } _updateSessionFromEvent(e, t) { let n = !1, r = !1; const o = t.exception && t.exception.values; if (o) { r = !0; for (const e of o) { const t = e.mechanism; if (t && !1 === t.handled) { n = !0; break } } } const s = "ok" === e.status; (s && 0 === e.errors || s && n) && (xy(e, { ...n && { status: "crashed" }, errors: e.errors || Number(r || n) }), this.captureSession(e)) } _isClientDoneProcessing(e) { return new Bg((t => { let n = 0; const r = setInterval((() => { 0 == this._numProcessing ? (clearInterval(r), t(!0)) : (n += 1, e && n >= e && (clearInterval(r), t(!1))) }), 1) })) } _isEnabled() { return !1 !== this.getOptions().enabled && void 0 !== this._transport } _prepareEvent(e, t, n, r = d_()) { const o = this.getOptions(), s = Object.keys(this._integrations); return !t.integrations && s.length > 0 && (t.integrations = s), this.emit("preprocessEvent", e, t), Ly(o, e, t, n, this, r).then((e => { if (null === e) return e; const t = { ...r.getPropagationContext(), ...n ? n.getPropagationContext() : void 0 }; if (!(e.contexts && e.contexts.trace) && t) { const { traceId: r, spanId: o, parentSpanId: s, dsc: i } = t; e.contexts = { trace: { trace_id: r, span_id: o, parent_span_id: s }, ...e.contexts }; const a = i || Yy(r, this, n); e.sdkProcessingMetadata = { dynamicSamplingContext: a, ...e.sdkProcessingMetadata } } return e })) } _captureEvent(e, t = {}, n) { return this._processEvent(e, t, n).then((e => e.event_id), (e => { if (by) { const t = e; "log" === t.logLevel ? Em.log(t.message) : Em.warn(t) } })) } _processEvent(e, t, n) { const r = this.getOptions(), { sampleRate: o } = r, s = rv(e), i = nv(e), a = e.type || "error", c = `before send for type \`${a}\``; if (i && "number" == typeof o && Math.random() > o) return this.recordDroppedEvent("sample_rate", "error", e), Hg(new Am(`Discarding event because it's not included in the random sample (sampling rate = ${o})`, "log")); const l = "replay_event" === a ? "replay" : a, u = (e.sdkProcessingMetadata || {}).capturedSpanIsolationScope; return this._prepareEvent(e, t, n, u).then((n => { if (null === n) throw this.recordDroppedEvent("event_processor", l, e), new Am("An event processor returned `null`, will not send event.", "log"); if (t.data && !0 === t.data.__sentry__) return n; const o = function (e, t, n) { const { beforeSend: r, beforeSendTransaction: o } = e; if (nv(t) && r) return r(t, n); if (rv(t) && o) return o(t, n); return t }(r, n, t); return function (e, t) { const n = `${t} must return \`null\` or a valid event.`; if (Zh(e)) return e.then((e => { if (!Yh(e) && null !== e) throw new Am(n); return e }), (e => { throw new Am(`${t} rejected with ${e}`) })); if (!Yh(e) && null !== e) throw new Am(n); return e }(o, c) })).then((r => { if (null === r) throw this.recordDroppedEvent("before_send", l, e), new Am(`${c} returned \`null\`, will not send event.`, "log"); const o = n && n.getSession(); !s && o && this._updateSessionFromEvent(o, r); const i = r.transaction_info; if (s && i && r.transaction !== e.transaction) { const e = "custom"; r.transaction_info = { ...i, source: e } } return this.sendEvent(r, t), r })).then(null, (e => { if (e instanceof Am) throw e; throw this.captureException(e, { data: { __sentry__: !0 }, originalException: e }), new Am(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${e}`) })) } _process(e) { this._numProcessing++, e.then((e => (this._numProcessing--, e)), (e => (this._numProcessing--, e))) } _sendEnvelope(e) { if (this.emit("beforeEnvelope", e), this._isEnabled() && this._transport) return this._transport.send(e).then(null, (e => { by && Em.error("Error while sending event:", e) })); by && Em.error("Transport disabled") } _clearOutcomes() { const e = this._outcomes; return this._outcomes = {}, Object.keys(e).map((t => { const [n, r] = t.split(":"); return { reason: n, category: r, quantity: e[t] } })) } } function nv(e) { return void 0 === e.type } function rv(e) { return "transaction" === e.type } function ov(e, t) { !0 === t.debug && (by ? Em.enable() : km((() => { console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.") }))); Vy().update(t.initialScope); const n = new e(t); !function (e) { const t = u_().getStackTop(); t.client = e, t.scope.setClient(e) }(n), function (e) { e.init ? e.init() : e.setupIntegrations && e.setupIntegrations() }(n) } const sv = 30; function iv(e, t, n = qg(e.bufferSize || sv)) { let r = {}; function o(o) { const s = []; if (uy(o, ((t, n) => { const o = my(n); if (function (e, t, n = Date.now()) { return function (e, t) { return e[t] || e.all || 0 }(e, t) > n }(r, o)) { const r = av(t, n); e.recordDroppedEvent("ratelimit_backoff", o, r) } else s.push(t) })), 0 === s.length) return Ug(); const i = cy(o[0], s), a = t => { uy(i, ((n, r) => { const o = av(n, r); e.recordDroppedEvent(t, my(r), o) })) }; return n.add((() => t({ body: py(i, e.textEncoder) }).then((e => (void 0 !== e.statusCode && (e.statusCode < 200 || e.statusCode >= 300) && by && Em.warn(`Sentry responded with status code ${e.statusCode} to sent event.`), r = _y(r, e), e)), (e => { throw a("network_error"), e })))).then((e => e), (e => { if (e instanceof Am) return by && Em.error("Skipped sending event because buffer is full."), a("queue_overflow"), Ug(); throw e })) } return o.__sentry__baseTransport__ = !0, { send: o, flush: e => n.drain(e) } } function av(e, t) { if ("event" === t || "transaction" === t) return Array.isArray(e) ? e[1] : void 0 } function cv(e) { return [{ type: "span" }, e] } const lv = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/], uv = [/^.*\/healthcheck$/, /^.*\/healthy$/, /^.*\/live$/, /^.*\/ready$/, /^.*\/heartbeat$/, /^.*\/health$/, /^.*\/healthz$/], dv = "InboundFilters", pv = (e = {}) => ({ name: dv, setupOnce() { }, processEvent(t, n, r) { const o = r.getOptions(), s = function (e = {}, t = {}) { return { allowUrls: [...e.allowUrls || [], ...t.allowUrls || []], denyUrls: [...e.denyUrls || [], ...t.denyUrls || []], ignoreErrors: [...e.ignoreErrors || [], ...t.ignoreErrors || [], ...e.disableErrorDefaults ? [] : lv], ignoreTransactions: [...e.ignoreTransactions || [], ...t.ignoreTransactions || [], ...e.disableTransactionDefaults ? [] : uv], ignoreInternal: void 0 === e.ignoreInternal || e.ignoreInternal } }(e, o); return function (e, t) { if (t.ignoreInternal && function (e) { try { return "SentryError" === e.exception.values[0].type } catch (t) { } return !1 }(e)) return by && Em.warn(`Event dropped due to being internal Sentry Error.\nEvent: ${Zm(e)}`), !0; if (function (e, t) { if (e.type || !t || !t.length) return !1; return function (e) { const t = []; e.message && t.push(e.message); let n; try { n = e.exception.values[e.exception.values.length - 1] } catch (r) { } n && n.value && (t.push(n.value), n.type && t.push(`${n.type}: ${n.value}`)); by && 0 === t.length && Em.error(`Could not extract message for event ${Zm(e)}`); return t }(e).some((e => sm(e, t))) }(e, t.ignoreErrors)) return by && Em.warn(`Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${Zm(e)}`), !0; if (function (e, t) { if ("transaction" !== e.type || !t || !t.length) return !1; const n = e.transaction; return !!n && sm(n, t) }(e, t.ignoreTransactions)) return by && Em.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.\nEvent: ${Zm(e)}`), !0; if (function (e, t) { if (!t || !t.length) return !1; const n = fv(e); return !!n && sm(n, t) }(e, t.denyUrls)) return by && Em.warn(`Event dropped due to being matched by \`denyUrls\` option.\nEvent: ${Zm(e)}.\nUrl: ${fv(e)}`), !0; if (!function (e, t) { if (!t || !t.length) return !0; const n = fv(e); return !n || sm(n, t) }(e, t.allowUrls)) return by && Em.warn(`Event dropped due to not being matched by \`allowUrls\` option.\nEvent: ${Zm(e)}.\nUrl: ${fv(e)}`), !0; return !1 }(t, s) ? null : t } }); function fv(e) { try { let n; try { n = e.exception.values[0].stacktrace.frames } catch (t) { } return n ? function (e = []) { for (let t = e.length - 1; t >= 0; t--) { const n = e[t]; if (n && "<anonymous>" !== n.filename && "[native code]" !== n.filename) return n.filename || null } return null }(n) : null } catch (n) { return by && Em.error(`Cannot extract url for event ${Zm(e)}`), null } } let hv; X_(dv, pv); const mv = "FunctionToString", gv = new WeakMap, yv = () => ({ name: mv, setupOnce() { hv = Function.prototype.toString; try { Function.prototype.toString = function (...e) { const t = Pm(this), n = gv.has(qy()) && void 0 !== t ? t : this; return hv.apply(n, e) } } catch (e) { } }, setup(e) { gv.set(e, !0) } }); X_(mv, yv); const _v = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__; function vv(e) { const t = vy([e, "call", e => e(), "access", e => e.getClient, "call", e => e(), "optionalAccess", e => e.getOptions, "call", e => e()]); return "sentry" !== (vy([t, "optionalAccess", e => e.instrumenter]) || "sentry") } class bv { static __initStatic() { this.id = "Express" } constructor(e = {}) { this.name = bv.id, this._router = e.router || e.app, this._methods = (Array.isArray(e.methods) ? e.methods : []).concat("use") } setupOnce(e, t) { this._router ? vv(t) ? _v && Em.log("Express Integration is skipped because of instrumenter configuration.") : (function (e, t = []) { t.forEach((t => function (e, t) { const n = e[t]; return e[t] = function (...e) { return n.call(this, ...function (e, t) { return e.map((e => "function" == typeof e ? wv(e, t) : Array.isArray(e) ? e.map((e => "function" == typeof e ? wv(e, t) : e)) : e)) }(e, t)) }, e }(e, t))) }(this._router, this._methods), function (e) { const t = "settings" in e; t && void 0 === e._router && e.lazyrouter && e.lazyrouter(); const n = t ? e._router : e; if (!n) return _v && Em.debug("Cannot instrument router for URL Parameterization (did not find a valid router)."), void (_v && Em.debug("Routing instrumentation is currently only supported in Express 4.")); const r = Object.getPrototypeOf(n), o = r.process_params; r.process_params = function (e, t, n, r, s) { n._reconstructedRoute || (n._reconstructedRoute = ""); const { layerRoutePath: i, isRegex: a, isArray: c, numExtraSegments: l } = function (e) { let t = vy([e, "access", e => e.route, "optionalAccess", e => e.path]); const n = Xh(t), r = Array.isArray(t); if (!t) { const [n] = dm.process.versions.node.split(".").map(Number); n >= 16 && (t = Sv(e.path, e.regexp, e.keys)) } if (!t) return { isRegex: n, isArray: r, numExtraSegments: 0 }; const o = r ? Math.max((i = t, i.reduce(((e, t) => e + zg(t.toString())), 0) - zg(e.path || "")), 0) : 0, s = function (e, t) { if (e) return t.map((e => e.toString())).join(","); return t && t.toString() }(r, t); var i; return { layerRoutePath: s, isRegex: n, isArray: r, numExtraSegments: o } }(e); let u; (i || a || c) && (n._hasParameters = !0), u = i || (function (e, t, n) { const r = vy([Wg(e || ""), "optionalAccess", e => e.split, "call", e => e("/"), "access", e => e.filter, "call", e => e((e => !!e))]); let o = 0; const s = vy([t, "optionalAccess", e => e.split, "call", e => e("/"), "access", e => e.filter, "call", e => e((e => !!e)), "access", e => e.length]) || 0; return vy([n, "optionalAccess", e => e.split, "call", e => e("/"), "access", e => e.filter, "call", e => e((e => vy([r, "optionalAccess", e => e[s + o]]) === e && (o += 1, !0))), "access", e => e.join, "call", e => e("/")]) }(n.originalUrl, n._reconstructedRoute, e.path) || ""); const d = u.split("/").filter((e => e.length > 0 && (a || c || !e.includes("*")))).join("/"); d && d.length > 0 && (n._reconstructedRoute += `/${d}${a ? "/" : ""}`); if (zg(Wg(n.originalUrl || "")) + l === zg(n._reconstructedRoute)) { n._hasParameters || n._reconstructedRoute !== n.originalUrl && (n._reconstructedRoute = n.originalUrl ? Wg(n.originalUrl) : n.originalUrl); const e = r.__sentry_transaction, t = e && Py(e).data || {}; if (e && "custom" !== t[O_]) { const t = n._reconstructedRoute || "/", [r, o] = function (e, t = {}) { const n = e.method && e.method.toUpperCase(); let r = "", o = "url"; t.customRoute || e.route ? (r = t.customRoute || `${e.baseUrl || ""}${e.route && e.route.path}`, o = "route") : (e.originalUrl || e.url) && (r = Wg(e.originalUrl || e.url || "")); let s = ""; return t.method && n && (s += n), t.method && t.path && (s += " "), t.path && r && (s += r), [s, o] }(n, { path: !0, method: !0, customRoute: t }); e.updateName(r), e.setAttribute(O_, o) } } return o.call(this, e, t, n, r, s) } }(this._router)) : _v && Em.error("ExpressIntegration is missing an Express instance") } } function wv(e, t) { const n = e.length; switch (n) { case 2: return function (n, r) { const o = r.__sentry_transaction; if (o) { const n = o.startChild({ description: e.name, op: `middleware.express.${t}`, origin: "auto.middleware.express" }); r.once("finish", (() => { n.end() })) } return e.call(this, n, r) }; case 3: return function (n, r, o) { const s = vy([r.__sentry_transaction, "optionalAccess", e => e.startChild, "call", n => n({ description: e.name, op: `middleware.express.${t}`, origin: "auto.middleware.express" })]); e.call(this, n, r, (function (...e) { vy([s, "optionalAccess", e => e.end, "call", e => e()]), o.call(this, ...e) })) }; case 4: return function (n, r, o, s) { const i = vy([o.__sentry_transaction, "optionalAccess", e => e.startChild, "call", n => n({ description: e.name, op: `middleware.express.${t}`, origin: "auto.middleware.express" })]); e.call(this, n, r, o, (function (...e) { vy([i, "optionalAccess", e => e.end, "call", e => e()]), s.call(this, ...e) })) }; default: throw new Error(`Express middleware takes 2-4 arguments. Got: ${n}`) } } bv.__initStatic(); const Sv = (e, t, n) => { if (!(e && t && n && 0 !== Object.keys(n).length && vy([n, "access", e => e[0], "optionalAccess", e => e.offset]))) return; const r = n.sort(((e, t) => e.offset - t.offset)), o = new RegExp(t, `${t.flags}d`).exec(e); if (!o || !o.indices) return; const [, ...s] = o.indices; if (s.length !== r.length) return; let i = e, a = 0; return s.forEach(((e, t) => { if (e) { const [n, o] = e, s = i.substring(0, n - a), c = `:${r[t].name}`, l = i.substring(o - a); i = s + c + l, a += o - n - c.length } })), i }; class kv { static __initStatic() { this.id = "Postgres" } constructor(e = {}) { this.name = kv.id, this._usePgNative = !!e.usePgNative, this._module = e.module } loadDependency() { return this._module = this._module || Lg("pg") } setupOnce(e, t) { if (vv(t)) return void (_v && Em.log("Postgres Integration is skipped because of instrumenter configuration.")); const n = this.loadDependency(); if (!n) return void (_v && Em.error("Postgres Integration was unable to require `pg` package.")); const r = this._usePgNative ? vy([n, "access", e => e.native, "optionalAccess", e => e.Client]) : n.Client; r ? Rm(r.prototype, "query", (function (e) { return function (n, r, o) { const s = t().getScope().getSpan(), i = { "db.system": "postgresql" }; try { this.database && (i["db.name"] = this.database), this.host && (i["server.address"] = this.host), this.port && (i["server.port"] = this.port), this.user && (i["db.user"] = this.user) } catch (l) { } const a = vy([s, "optionalAccess", e => e.startChild, "call", e => e({ description: "string" == typeof n ? n : n.text, op: "db", origin: "auto.db.postgres", data: i })]); if ("function" == typeof o) return e.call(this, n, r, (function (e, t) { vy([a, "optionalAccess", e => e.end, "call", e => e()]), o(e, t) })); if ("function" == typeof r) return e.call(this, n, (function (e, t) { vy([a, "optionalAccess", e => e.end, "call", e => e()]), r(e, t) })); const c = void 0 !== r ? e.call(this, n, r) : e.call(this, n); return Zh(c) ? c.then((e => (vy([a, "optionalAccess", e => e.end, "call", e => e()]), e))) : (vy([a, "optionalAccess", e => e.end, "call", e => e()]), c) } })) : _v && Em.error("Postgres Integration was unable to access 'pg-native' bindings.") } } kv.__initStatic(); class Ev { static __initStatic() { this.id = "Mysql" } constructor() { this.name = Ev.id } loadDependency() { return this._module = this._module || Lg("mysql/lib/Connection.js") } setupOnce(e, t) { if (vv(t)) return void (_v && Em.log("Mysql Integration is skipped because of instrumenter configuration.")); const n = this.loadDependency(); if (!n) return void (_v && Em.error("Mysql Integration was unable to require `mysql` package.")); let r; try { n.prototype.connect = new Proxy(n.prototype.connect, { apply: (e, t, n) => (r || (r = t.config), e.apply(t, n)) }) } catch (s) { _v && Em.error("Mysql Integration was unable to instrument `mysql` config.") } function o(e) { if (!e) return; const t = r ? { "server.address": r.host, "server.port": r.port, "db.user": r.user } : {}; Object.keys(t).forEach((n => { e.setAttribute(n, t[n]) })), e.end() } Rm(n, "createQuery", (function (e) { return function (n, r, s) { const i = vy([t().getScope().getSpan(), "optionalAccess", e => e.startChild, "call", e => e({ description: "string" == typeof n ? n : n.sql, op: "db", origin: "auto.db.mysql", data: { "db.system": "mysql" } })]); if ("function" == typeof s) return e.call(this, n, r, (function (e, t, n) { o(i), s(e, t, n) })); if ("function" == typeof r) return e.call(this, n, (function (e, t, n) { o(i), r(e, t, n) })); const a = e.call(this, n, r); return a.on("end", (() => { o(i) })), a } })) } } Ev.__initStatic(); const Tv = ["aggregate", "bulkWrite", "countDocuments", "createIndex", "createIndexes", "deleteMany", "deleteOne", "distinct", "drop", "dropIndex", "dropIndexes", "estimatedDocumentCount", "find", "findOne", "findOneAndDelete", "findOneAndReplace", "findOneAndUpdate", "indexes", "indexExists", "indexInformation", "initializeOrderedBulkOp", "insertMany", "insertOne", "isCapped", "mapReduce", "options", "parallelCollectionScan", "rename", "replaceOne", "stats", "updateMany", "updateOne"], xv = { bulkWrite: ["operations"], countDocuments: ["query"], createIndex: ["fieldOrSpec"], createIndexes: ["indexSpecs"], deleteMany: ["filter"], deleteOne: ["filter"], distinct: ["key", "query"], dropIndex: ["indexName"], find: ["query"], findOne: ["query"], findOneAndDelete: ["filter"], findOneAndReplace: ["filter", "replacement"], findOneAndUpdate: ["filter", "update"], indexExists: ["indexes"], insertMany: ["docs"], insertOne: ["doc"], mapReduce: ["map", "reduce"], rename: ["newName"], replaceOne: ["filter", "doc"], updateMany: ["filter", "update"], updateOne: ["filter", "update"] }; class Cv { static __initStatic() { this.id = "Mongo" } constructor(e = {}) { this.name = Cv.id, this._operations = Array.isArray(e.operations) ? e.operations : Tv, this._describeOperations = !("describeOperations" in e) || e.describeOperations, this._useMongoose = !!e.useMongoose } loadDependency() { const e = this._useMongoose ? "mongoose" : "mongodb"; return this._module = this._module || Lg(e) } setupOnce(e, t) { if (vv(t)) return void (_v && Em.log("Mongo Integration is skipped because of instrumenter configuration.")); const n = this.loadDependency(); if (n) this._instrumentOperations(n.Collection, this._operations, t); else { const e = this._useMongoose ? "mongoose" : "mongodb"; _v && Em.error(`Mongo Integration was unable to require \`${e}\` package.`) } } _instrumentOperations(e, t, n) { t.forEach((t => this._patchOperation(e, t, n))) } _patchOperation(e, t, n) { if (!(t in e.prototype)) return; const r = this._getSpanContextFromOperationArguments.bind(this); Rm(e.prototype, t, (function (e) { return function (...o) { const s = o[o.length - 1], i = n(), a = i.getScope(), c = i.getClient(), l = a.getSpan(), u = vy([c, "optionalAccess", e => e.getOptions, "call", e => e(), "access", e => e.sendDefaultPii]); if ("function" != typeof s || "mapReduce" === t && 2 === o.length) { const n = vy([l, "optionalAccess", e => e.startChild, "call", e => e(r(this, t, o, u))]), s = e.call(this, ...o); if (Zh(s)) return s.then((e => (vy([n, "optionalAccess", e => e.end, "call", e => e()]), e))); if ((d = s) && "object" == typeof d && d.once && "function" == typeof d.once) { const e = s; try { e.once("close", (() => { vy([n, "optionalAccess", e => e.end, "call", e => e()]) })) } catch (f) { vy([n, "optionalAccess", e => e.end, "call", e => e()]) } return e } return vy([n, "optionalAccess", e => e.end, "call", e => e()]), s } var d; const p = vy([l, "optionalAccess", e => e.startChild, "call", e => e(r(this, t, o.slice(0, -1)))]); return e.call(this, ...o.slice(0, -1), (function (e, t) { vy([p, "optionalAccess", e => e.end, "call", e => e()]), s(e, t) })) } })) } _getSpanContextFromOperationArguments(e, t, n, r = !1) { const o = { "db.system": "mongodb", "db.name": e.dbName, "db.operation": t, "db.mongodb.collection": e.collectionName }, s = { op: "db", origin: "auto.db.mongo", description: t, data: o }, i = xv[t], a = Array.isArray(this._describeOperations) ? this._describeOperations.includes(t) : this._describeOperations; if (!i || !a || !r) return s; try { if ("mapReduce" === t) { const [e, t] = n; o[i[0]] = "string" == typeof e ? e : e.name || "<anonymous>", o[i[1]] = "string" == typeof t ? t : t.name || "<anonymous>" } else for (let e = 0; e < i.length; e++)o[`db.mongodb.${i[e]}`] = JSON.stringify(n[e]) } catch (c) { } return s } } Cv.__initStatic(); class Ov { static __initStatic() { this.id = "Prisma" } constructor(e = {}) { if (this.name = Ov.id, (t = e.client) && t.$use && !e.client._sentryInstrumented) { Im(e.client, "_sentryInstrumented", !0); const t = {}; try { const n = e.client._engineConfig; if (n) { const { activeProvider: e, clientVersion: r } = n; e && (t["db.system"] = e), r && (t["db.prisma.version"] = r) } } catch (n) { } e.client.$use(((e, n) => { if (vv(u_)) return n(e); const r = e.action, o = e.model; return w_({ name: o ? `${o} ${r}` : r, onlyIfParent: !0, op: "db.prisma", attributes: { [I_]: "auto.db.prisma" }, data: { ...t, "db.operation": r } }, (() => n(e))) })) } else _v && Em.warn("Unsupported Prisma client provided to PrismaIntegration. Provided client:", e.client); var t } setupOnce() { } } Ov.__initStatic(); class Av { static __initStatic() { this.id = "GraphQL" } constructor() { this.name = Av.id } loadDependency() { return this._module = this._module || Lg("graphql/execution/execute.js") } setupOnce(e, t) { if (vv(t)) return void (_v && Em.log("GraphQL Integration is skipped because of instrumenter configuration.")); const n = this.loadDependency(); n ? Rm(n, "execute", (function (e) { return function (...n) { const r = t().getScope(), o = r.getSpan(), s = vy([o, "optionalAccess", e => e.startChild, "call", e => e({ description: "execute", op: "graphql.execute", origin: "auto.graphql.graphql" })]); vy([r, "optionalAccess", e => e.setSpan, "call", e => e(s)]); const i = e.call(this, ...n); return Zh(i) ? i.then((e => (vy([s, "optionalAccess", e => e.end, "call", e => e()]), vy([r, "optionalAccess", e => e.setSpan, "call", e => e(o)]), e))) : (vy([s, "optionalAccess", e => e.end, "call", e => e()]), vy([r, "optionalAccess", e => e.setSpan, "call", e => e(o)]), i) } })) : _v && Em.error("GraphQL Integration was unable to require graphql/execution package.") } } Av.__initStatic(); class Rv { static __initStatic() { this.id = "Apollo" } constructor(e = { useNestjs: !1 }) { this.name = Rv.id, this._useNest = !!e.useNestjs } loadDependency() { return this._useNest ? this._module = this._module || Lg("@nestjs/graphql") : this._module = this._module || Lg("apollo-server-core"), this._module } setupOnce(e, t) { if (vv(t)) _v && Em.log("Apollo Integration is skipped because of instrumenter configuration."); else if (this._useNest) { const e = this.loadDependency(); if (!e) return void (_v && Em.error("Apollo-NestJS Integration was unable to require @nestjs/graphql package.")); Rm(e.GraphQLFactory.prototype, "mergeWithSchema", (function (e) { return function (...n) { return Rm(this.resolversExplorerService, "explore", (function (e) { return function () { return Iv(rg(e.call(this)), t) } })), e.call(this, ...n) } })) } else { const e = this.loadDependency(); if (!e) return void (_v && Em.error("Apollo Integration was unable to require apollo-server-core package.")); Rm(e.ApolloServerBase.prototype, "constructSchema", (function (e) { return function () { if (!this.config.resolvers) return _v && (this.config.schema ? (Em.warn("Apollo integration is not able to trace `ApolloServer` instances constructed via `schema` property.If you are using NestJS with Apollo, please use `Sentry.Integrations.Apollo({ useNestjs: true })` instead."), Em.warn()) : this.config.modules && Em.warn("Apollo integration is not able to trace `ApolloServer` instances constructed via `modules` property."), Em.error("Skipping tracing as no resolvers found on the `ApolloServer` instance.")), e.call(this); const n = rg(this.config.resolvers); return this.config.resolvers = Iv(n, t), e.call(this) } })) } } } function Iv(e, t) { return e.map((e => (Object.keys(e).forEach((n => { Object.keys(e[n]).forEach((r => { "function" == typeof e[n][r] && function (e, t, n, r) { Rm(e[t], n, (function (e) { return function (...o) { const s = vy([r().getScope().getSpan(), "optionalAccess", e => e.startChild, "call", e => e({ description: `${t}.${n}`, op: "graphql.resolve", origin: "auto.graphql.apollo" })]), i = e.call(this, ...o); return Zh(i) ? i.then((e => (vy([s, "optionalAccess", e => e.end, "call", e => e()]), e))) : (vy([s, "optionalAccess", e => e.end, "call", e => e()]), i) } })) }(e, n, r, t) })) })), e))) } Rv.__initStatic(); const $v = dm; const Pv = (e, t, n) => { let r, o; return s => { t.value >= 0 && (s || n) && (o = t.value - (r || 0), (o || void 0 === r) && (r = t.value, t.delta = o, e(t))) } }, jv = () => $v.__WEB_VITALS_POLYFILL__ ? $v.performance && (performance.getEntriesByType && performance.getEntriesByType("navigation")[0] || (() => { const e = $v.performance.timing, t = $v.performance.navigation.type, n = { entryType: "navigation", startTime: 0, type: 2 == t ? "back_forward" : 1 === t ? "reload" : "navigate" }; for (const r in e) "navigationStart" !== r && "toJSON" !== r && (n[r] = Math.max(e[r] - e.navigationStart, 0)); return n })()) : $v.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0], Lv = () => { const e = jv(); return e && e.activationStart || 0 }, Dv = (e, t) => { const n = jv(); let r = "navigate"; return n && (r = $v.document.prerendering || Lv() > 0 ? "prerender" : n.type.replace(/_/g, "-")), { name: e, value: void 0 === t ? -1 : t, rating: "good", delta: 0, entries: [], id: `v3-${Date.now()}-${Math.floor(8999999999999 * Math.random()) + 1e12}`, navigationType: r } }, Nv = (e, t, n) => { try { if (PerformanceObserver.supportedEntryTypes.includes(e)) { const r = new PerformanceObserver((e => { t(e.getEntries()) })); return r.observe(Object.assign({ type: e, buffered: !0 }, n || {})), r } } catch (r) { } }, Mv = (e, t) => { const n = r => { "pagehide" !== r.type && "hidden" !== $v.document.visibilityState || (e(r), t && (removeEventListener("visibilitychange", n, !0), removeEventListener("pagehide", n, !0))) }; addEventListener("visibilitychange", n, !0), addEventListener("pagehide", n, !0) }, Fv = e => { const t = Dv("CLS", 0); let n, r = 0, o = []; const s = e => { e.forEach((e => { if (!e.hadRecentInput) { const s = o[0], i = o[o.length - 1]; r && 0 !== o.length && e.startTime - i.startTime < 1e3 && e.startTime - s.startTime < 5e3 ? (r += e.value, o.push(e)) : (r = e.value, o = [e]), r > t.value && (t.value = r, t.entries = o, n && n()) } })) }, i = Nv("layout-shift", s); if (i) { n = Pv(e, t); const r = () => { s(i.takeRecords()), n(!0) }; return Mv(r), r } }; let Uv = -1; const Hv = () => (Uv < 0 && (Uv = "hidden" !== $v.document.visibilityState || $v.document.prerendering ? 1 / 0 : 0, Mv((({ timeStamp: e }) => { Uv = e }), !0)), { get firstHiddenTime() { return Uv } }), Bv = e => { const t = Hv(), n = Dv("FID"); let r; const o = e => { e.startTime < t.firstHiddenTime && (n.value = e.processingStart - e.startTime, n.entries.push(e), r(!0)) }, s = e => { e.forEach(o) }, i = Nv("first-input", s); r = Pv(e, n), i && Mv((() => { s(i.takeRecords()), i.disconnect() }), !0) }; let qv = 0, Vv = 1 / 0, Wv = 0; const zv = e => { e.forEach((e => { e.interactionId && (Vv = Math.min(Vv, e.interactionId), Wv = Math.max(Wv, e.interactionId), qv = Wv ? (Wv - Vv) / 7 + 1 : 0) })) }; let Gv; const Jv = () => Gv ? qv : performance.interactionCount || 0, Kv = [], Yv = {}, Qv = e => { const t = Kv[Kv.length - 1], n = Yv[e.interactionId]; if (n || Kv.length < 10 || e.duration > t.latency) { if (n) n.entries.push(e), n.latency = Math.max(n.latency, e.duration); else { const t = { id: e.interactionId, latency: e.duration, entries: [e] }; Yv[t.id] = t, Kv.push(t) } Kv.sort(((e, t) => t.latency - e.latency)), Kv.splice(10).forEach((e => { delete Yv[e.id] })) } }, Xv = (e, t) => { t = t || {}, "interactionCount" in performance || Gv || (Gv = Nv("event", zv, { type: "event", buffered: !0, durationThreshold: 0 })); const n = Dv("INP"); let r; const o = e => { e.forEach((e => { if (e.interactionId && Qv(e), "first-input" === e.entryType) { !Kv.some((t => t.entries.some((t => e.duration === t.duration && e.startTime === t.startTime)))) && Qv(e) } })); const t = (() => { const e = Math.min(Kv.length - 1, Math.floor(Jv() / 50)); return Kv[e] })(); t && t.latency !== n.value && (n.value = t.latency, n.entries = t.entries, r()) }, s = Nv("event", o, { durationThreshold: t.durationThreshold || 40 }); r = Pv(e, n, t.reportAllChanges), s && (s.observe({ type: "first-input", buffered: !0 }), Mv((() => { o(s.takeRecords()), n.value < 0 && Jv() > 0 && (n.value = 0, n.entries = []), r(!0) }))) }, Zv = {}, eb = e => { const t = Hv(), n = Dv("LCP"); let r; const o = e => { const o = e[e.length - 1]; if (o) { const e = Math.max(o.startTime - Lv(), 0); e < t.firstHiddenTime && (n.value = e, n.entries = [o], r()) } }, s = Nv("largest-contentful-paint", o); if (s) { r = Pv(e, n); const t = () => { Zv[n.id] || (o(s.takeRecords()), s.disconnect(), Zv[n.id] = !0, r(!0)) }; return ["keydown", "click"].forEach((e => { addEventListener(e, t, { once: !0, capture: !0 }) })), Mv(t, !0), t } }, tb = e => { $v.document && ($v.document.prerendering ? addEventListener("prerenderingchange", (() => tb(e)), !0) : "complete" !== $v.document.readyState ? addEventListener("load", (() => tb(e)), !0) : setTimeout(e, 0)) }, nb = (e, t) => { t = t || {}; const n = Dv("TTFB"), r = Pv(e, n, t.reportAllChanges); tb((() => { const e = jv(); if (e) { if (n.value = Math.max(e.responseStart - Lv(), 0), n.value < 0 || n.value > performance.now()) return; n.entries = [e], r(!0) } })) }, rb = {}, ob = {}; let sb, ib, ab, cb, lb; function ub(e, t) { return _b(e, t), ob[e] || (!function (e) { const t = {}; "event" === e && (t.durationThreshold = 0); Nv(e, (t => { db(e, { entries: t }) }), t) }(e), ob[e] = !0), vb(e, t) } function db(e, t) { const n = rb[e]; if (n && n.length) for (const o of n) try { o(t) } catch (r) { _v && Em.error(`Error while triggering instrumentation handler.\nType: ${e}\nName: ${Vm(o)}\nError:`, r) } } function pb() { return Fv((e => { db("cls", { metric: e }), sb = e })) } function fb() { return Bv((e => { db("fid", { metric: e }), ib = e })) } function hb() { return eb((e => { db("lcp", { metric: e }), ab = e })) } function mb() { return nb((e => { db("ttfb", { metric: e }), cb = e })) } function gb() { return Xv((e => { db("inp", { metric: e }), lb = e })) } function yb(e, t, n, r, o = !1) { let s; return _b(e, t), ob[e] || (s = n(), ob[e] = !0), r && t({ metric: r }), vb(e, t, o ? s : void 0) } function _b(e, t) { rb[e] = rb[e] || [], rb[e].push(t) } function vb(e, t, n) { return () => { n && n(); const r = rb[e]; if (!r) return; const o = r.indexOf(t); -1 !== o && r.splice(o, 1) } } function bb(e) { return "number" == typeof e && isFinite(e) } function wb(e, { startTimestamp: t, ...n }) { return t && e.startTimestamp > t && (e.startTimestamp = t), e.startChild({ startTimestamp: t, ...n }) } const Sb = 2147483647; function kb(e) { return e / 1e3 } function Eb() { return $v && $v.addEventListener && $v.performance } let Tb, xb, Cb = 0, Ob = {}; function Ab() { const e = Eb(); if (e && Xg) { e.mark && $v.performance.mark("sentry-tracing-init"); const t = yb("fid", (({ metric: e }) => { const t = e.entries[e.entries.length - 1]; if (!t) return; const n = kb(Xg), r = kb(t.startTime); _v && Em.log("[Measurements] Adding FID"), Ob.fid = { value: e.value, unit: "millisecond" }, Ob["mark.fid"] = { value: n + r, unit: "second" } }), fb, ib), n = function (e, t = !1) { return yb("cls", e, pb, sb, t) }((({ metric: e }) => { const t = e.entries[e.entries.length - 1]; t && (_v && Em.log("[Measurements] Adding CLS"), Ob.cls = { value: e.value, unit: "" }, xb = t) }), !0), r = function (e, t = !1) { return yb("lcp", e, hb, ab, t) }((({ metric: e }) => { const t = e.entries[e.entries.length - 1]; t && (_v && Em.log("[Measurements] Adding LCP"), Ob.lcp = { value: e.value, unit: "millisecond" }, Tb = t) }), !0), o = function (e) { return yb("ttfb", e, mb, cb) }((({ metric: e }) => { e.entries[e.entries.length - 1] && (_v && Em.log("[Measurements] Adding TTFB"), Ob.ttfb = { value: e.value, unit: "millisecond" }) })); return () => { t(), n(), r(), o() } } return () => { } } function Rb(e) { if (Eb() && Xg) { const n = (t = e, yb("inp", (({ metric: e }) => { if (void 0 === e.value) return; const n = e.entries.find((t => t.duration === e.value && void 0 !== Ib[t.name])), r = qy(); if (!n || !r) return; const o = Ib[n.name], s = r.getOptions(), i = kb(Xg + n.startTime), a = kb(e.value), c = void 0 !== n.interactionId ? t[n.interactionId] : void 0; if (void 0 === c) return; const { routeName: l, parentContext: u, activeTransaction: d, user: p, replayId: f } = c, h = void 0 !== p ? p.email || p.id || p.ip_address : void 0, m = void 0 !== d ? d.getProfileId() : void 0, g = new P_({ startTimestamp: i, endTimestamp: i + a, op: `ui.interaction.${o}`, name: gm(n.target), attributes: { release: s.release, environment: s.environment, transaction: l, ...void 0 !== h && "" !== h ? { user: h } : {}, ...void 0 !== m ? { profile_id: m } : {}, ...void 0 !== f ? { replay_id: f } : {} }, exclusiveTime: e.value, measurements: { inp: { value: e.value, unit: "millisecond" } } }), y = function (e, t) { if (!b_(t)) return !1; let n; return n = void 0 !== e && "function" == typeof t.tracesSampler ? t.tracesSampler({ transactionContext: e, name: e.name, parentSampled: e.parentSampled, attributes: { ...e.data, ...e.attributes }, location: $v.location }) : void 0 !== e && void 0 !== e.sampled ? e.sampled : void 0 !== t.tracesSampleRate ? t.tracesSampleRate : 1, U_(n) ? n : (_v && Em.warn("[Tracing] Discarding transaction because of invalid sample rate."), !1) }(u, s); if (y && Math.random() < y) { const e = g ? function (e, t) { const n = { sent_at: (new Date).toISOString() }; return t && (n.dsn = xm(t)), cy(n, e.map(cv)) }([g], r.getDsn()) : void 0, t = r && r.getTransport(); t && e && t.send(e).then(null, (e => { _v && Em.error("Error while sending interaction:", e) })) } }), gb, lb)); return () => { n() } } var t; return () => { } } const Ib = { click: "click", pointerdown: "click", pointerup: "click", mousedown: "click", mouseup: "click", touchstart: "click", touchend: "click", mouseover: "hover", mouseout: "hover", mouseenter: "hover", mouseleave: "hover", pointerover: "hover", pointerout: "hover", pointerenter: "hover", pointerleave: "hover", dragstart: "drag", dragend: "drag", drag: "drag", dragenter: "drag", dragleave: "drag", dragover: "drag", drop: "drag", keydown: "press", keyup: "press", keypress: "press", input: "press" }; function $b(e) { const t = Eb(); if (!t || !$v.performance.getEntries || !Xg) return; _v && Em.log("[Tracing] Adding & adjusting spans using Performance API"); const n = kb(Xg), r = t.getEntries(), { op: o, start_timestamp: s } = Py(e); if (r.slice(Cb).forEach((t => { const r = kb(t.startTime), o = kb(t.duration); if (!("navigation" === e.op && s && n + r < s)) switch (t.entryType) { case "navigation": !function (e, t, n) { ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((r => { Pb(e, t, r, n) })), Pb(e, t, "secureConnection", n, "TLS/SSL", "connectEnd"), Pb(e, t, "fetch", n, "cache", "domainLookupStart"), Pb(e, t, "domainLookup", n, "DNS"), function (e, t, n) { t.responseEnd && (wb(e, { op: "browser", origin: "auto.browser.browser.metrics", description: "request", startTimestamp: n + kb(t.requestStart), endTimestamp: n + kb(t.responseEnd) }), wb(e, { op: "browser", origin: "auto.browser.browser.metrics", description: "response", startTimestamp: n + kb(t.responseStart), endTimestamp: n + kb(t.responseEnd) })) }(e, t, n) }(e, t, n); break; case "mark": case "paint": case "measure": { !function (e, t, n, r, o) { const s = o + n, i = s + r; wb(e, { description: t.name, endTimestamp: i, op: t.entryType, origin: "auto.resource.browser.metrics", startTimestamp: s }) }(e, t, r, o, n); const s = Hv(), i = t.startTime < s.firstHiddenTime; "first-paint" === t.name && i && (_v && Em.log("[Measurements] Adding FP"), Ob.fp = { value: t.startTime, unit: "millisecond" }), "first-contentful-paint" === t.name && i && (_v && Em.log("[Measurements] Adding FCP"), Ob.fcp = { value: t.startTime, unit: "millisecond" }); break } case "resource": !function (e, t, n, r, o, s) { if ("xmlhttprequest" === t.initiatorType || "fetch" === t.initiatorType) return; const i = Vg(n), a = {}; jb(a, t, "transferSize", "http.response_transfer_size"), jb(a, t, "encodedBodySize", "http.response_content_length"), jb(a, t, "decodedBodySize", "http.decoded_response_content_length"), "renderBlockingStatus" in t && (a["resource.render_blocking_status"] = t.renderBlockingStatus); i.protocol && (a["url.scheme"] = i.protocol.split(":").pop()); i.host && (a["server.address"] = i.host); a["url.same_origin"] = n.includes($v.location.origin); const c = s + r, l = c + o; wb(e, { description: n.replace($v.location.origin, ""), endTimestamp: l, op: t.initiatorType ? `resource.${t.initiatorType}` : "resource.other", origin: "auto.resource.browser.metrics", startTimestamp: c, data: a }) }(e, t, t.name, r, o, n) } })), Cb = Math.max(r.length - 1, 0), function (e) { const t = $v.navigator; if (!t) return; const n = t.connection; n && (n.effectiveType && e.setTag("effectiveConnectionType", n.effectiveType), n.type && e.setTag("connectionType", n.type), bb(n.rtt) && (Ob["connection.rtt"] = { value: n.rtt, unit: "millisecond" })); bb(t.deviceMemory) && e.setTag("deviceMemory", `${t.deviceMemory} GB`); bb(t.hardwareConcurrency) && e.setTag("hardwareConcurrency", String(t.hardwareConcurrency)) }(e), "pageload" === o) { !function (e) { const t = jv(); if (!t) return; const { responseStart: n, requestStart: r } = t; r <= n && (_v && Em.log("[Measurements] Adding TTFB Request Time"), e["ttfb.requestTime"] = { value: n - r, unit: "millisecond" }) }(Ob), ["fcp", "fp", "lcp"].forEach((e => { if (!Ob[e] || !s || n >= s) return; const t = Ob[e].value, r = n + kb(t), o = Math.abs(1e3 * (r - s)), i = o - t; _v && Em.log(`[Measurements] Normalized ${e} from ${t} to ${o} (${i})`), Ob[e].value = o })); const t = Ob["mark.fid"]; t && Ob.fid && (wb(e, { description: "first input delay", endTimestamp: t.value + kb(Ob.fid.value), op: "ui.action", origin: "auto.ui.browser.metrics", startTimestamp: t.value }), delete Ob["mark.fid"]), "fcp" in Ob || delete Ob.cls, Object.keys(Ob).forEach((e => { !function (e, t, n) { const r = h_(); r && r.setMeasurement(e, t, n) }(e, Ob[e].value, Ob[e].unit) })), function (e) { Tb && (_v && Em.log("[Measurements] Adding LCP Data"), Tb.element && e.setTag("lcp.element", gm(Tb.element)), Tb.id && e.setTag("lcp.id", Tb.id), Tb.url && e.setTag("lcp.url", Tb.url.trim().slice(0, 200)), e.setTag("lcp.size", Tb.size)); xb && xb.sources && (_v && Em.log("[Measurements] Adding CLS Data"), xb.sources.forEach(((t, n) => e.setTag(`cls.source.${n + 1}`, gm(t.node))))) }(e) } Tb = void 0, xb = void 0, Ob = {} } function Pb(e, t, n, r, o, s) { const i = s ? t[s] : t[`${n}End`], a = t[`${n}Start`]; a && i && wb(e, { op: "browser", origin: "auto.browser.browser.metrics", description: o || n, startTimestamp: r + kb(a), endTimestamp: r + kb(i) }) } function jb(e, t, n, r) { const o = t[n]; null != o && o < Sb && (e[r] = o) } function Lb(e, t, n, r, o = "auto.http.browser") { if (!b_() || !e.fetchData) return; const s = t(e.fetchData.url); if (e.endTimestamp && s) { const t = e.fetchData.__span; if (!t) return; const n = r[t]; if (n) { if (e.response) { __(n, e.response.status); const t = e.response && e.response.headers && e.response.headers.get("content-length"); if (t) { const e = parseInt(t); e > 0 && n.setAttribute("http.response_content_length", e) } } else e.error && n.setStatus("internal_error"); n.end(), delete r[t] } return } const i = Vy(), a = qy(), { method: c, url: l } = e.fetchData, u = s ? S_({ name: `${c} ${l}`, onlyIfParent: !0, attributes: { url: l, type: "fetch", "http.method": c, [I_]: o }, op: "http.client" }) : void 0; if (u && (e.fetchData.__span = u.spanContext().spanId, r[u.spanContext().spanId] = u), n(e.fetchData.url) && a) { const t = e.args[0]; e.args[1] = e.args[1] || {}; const n = e.args[1]; n.headers = function (e, t, n, r, o) { const s = o || n.getSpan(), i = d_(), { traceId: a, spanId: c, sampled: l, dsc: u } = { ...i.getPropagationContext(), ...n.getPropagationContext() }, d = s ? Ry(s) : ay(a, c, l), p = ry(u || (s ? Qy(s) : Yy(a, t, n))), f = r.headers || ("undefined" != typeof Request && tm(e, Request) ? e.headers : void 0); if (f) { if ("undefined" != typeof Headers && tm(f, Headers)) { const e = new Headers(f); return e.append("sentry-trace", d), p && e.append(Zg, p), e } if (Array.isArray(f)) { const e = [...f, ["sentry-trace", d]]; return p && e.push([Zg, p]), e } { const e = "baggage" in f ? f.baggage : void 0, t = []; return Array.isArray(e) ? t.push(...e) : e && t.push(e), p && t.push(p), { ...f, "sentry-trace": d, baggage: t.length > 0 ? t.join(",") : void 0 } } } return { "sentry-trace": d, baggage: p } }(t, a, i, n, u) } return u } const Db = ["localhost", /^\/(?!\/)/], Nb = { traceFetch: !0, traceXHR: !0, enableHTTPTimings: !0, tracingOrigins: Db, tracePropagationTargets: Db }; function Mb(e) { const { traceFetch: t, traceXHR: n, tracePropagationTargets: r, tracingOrigins: o, shouldCreateSpanForRequest: s, enableHTTPTimings: i } = { traceFetch: Nb.traceFetch, traceXHR: Nb.traceXHR, ...e }, a = "function" == typeof s ? s : e => !0, c = e => function (e, t) { return sm(e, t || Db) }(e, r || o), l = {}; t && hg((e => { const t = Lb(e, a, c, l); i && t && Fb(t) })), n && Ig((e => { const t = function (e, t, n, r) { const o = e.xhr, s = o && o[Rg]; if (!b_() || !o || o.__sentry_own_request__ || !s) return; const i = t(s.url); if (e.endTimestamp && i) { const e = o.__sentry_xhr_span_id__; if (!e) return; const t = r[e]; return void (t && void 0 !== s.status_code && (__(t, s.status_code), t.end(), delete r[e])) } const a = Vy(), c = d_(), l = i ? S_({ name: `${s.method} ${s.url}`, onlyIfParent: !0, attributes: { type: "xhr", "http.method": s.method, url: s.url, [I_]: "auto.http.browser" }, op: "http.client" }) : void 0; l && (o.__sentry_xhr_span_id__ = l.spanContext().spanId, r[o.__sentry_xhr_span_id__] = l); const u = qy(); if (o.setRequestHeader && n(s.url) && u) { const { traceId: e, spanId: t, sampled: n, dsc: r } = { ...c.getPropagationContext(), ...a.getPropagationContext() }; !function (e, t, n) { try { e.setRequestHeader("sentry-trace", t), n && e.setRequestHeader(Zg, n) } catch (r) { } }(o, l ? Ry(l) : ay(e, t, n), ry(r || (l ? Qy(l) : Yy(e, u, a)))) } return l }(e, a, c, l); i && t && Fb(t) })) } function Fb(e) { const { url: t } = Py(e).data || {}; if (!t || "string" != typeof t) return; const n = ub("resource", (({ entries: r }) => { r.forEach((r => { if (function (e) { return "resource" === e.entryType && "initiatorType" in e && "string" == typeof e.nextHopProtocol && ("fetch" === e.initiatorType || "xmlhttprequest" === e.initiatorType) }(r) && r.name.endsWith(t)) { (function (e) { const { name: t, version: n } = function (e) { let t = "unknown", n = "unknown", r = ""; for (const o of e) { if ("/" === o) { [t, n] = e.split("/"); break } if (!isNaN(Number(o))) { t = "h" === r ? "http" : r, n = e.split(r)[1]; break } r += o } r === e && (t = r); return { name: t, version: n } }(e.nextHopProtocol), r = []; if (r.push(["network.protocol.version", n], ["network.protocol.name", t]), !Xg) return r; return [...r, ["http.request.redirect_start", Ub(e.redirectStart)], ["http.request.fetch_start", Ub(e.fetchStart)], ["http.request.domain_lookup_start", Ub(e.domainLookupStart)], ["http.request.domain_lookup_end", Ub(e.domainLookupEnd)], ["http.request.connect_start", Ub(e.connectStart)], ["http.request.secure_connection_start", Ub(e.secureConnectionStart)], ["http.request.connection_end", Ub(e.connectEnd)], ["http.request.request_start", Ub(e.requestStart)], ["http.request.response_start", Ub(e.responseStart)], ["http.request.response_end", Ub(e.responseEnd)]] })(r).forEach((t => e.setAttribute(...t))), setTimeout(n) } })) })) } function Ub(e = 0) { return ((Xg || performance.timeOrigin) + e) / 1e3 } const Hb = { ...L_, markBackgroundTransactions: !0, routingInstrumentation: function (e, t = !0, n = !0) { if (!$v || !$v.location) return void (_v && Em.warn("Could not initialize routing instrumentation due to invalid location")); let r, o = $v.location.href; t && (r = e({ name: $v.location.pathname, startTimestamp: Xg ? Xg / 1e3 : void 0, op: "pageload", origin: "auto.pageload.browser", metadata: { source: "url" } })), n && Cg((({ to: t, from: n }) => { void 0 === n && o && -1 !== o.indexOf(t) ? o = void 0 : n !== t && (o = void 0, r && (_v && Em.log(`[Tracing] Finishing current transaction with op: ${r.op}`), r.end()), r = e({ name: $v.location.pathname, op: "navigation", origin: "auto.navigation.browser", metadata: { source: "url" } })) })) }, startTransactionOnLocationChange: !0, startTransactionOnPageLoad: !0, enableLongTask: !0, enableInp: !1, _experiments: {}, ...Nb }; function Bb(e) { const t = (n = `meta[name=${e}]`, hm.document && hm.document.querySelector ? hm.document.querySelector(n) : null); var n; return t ? t.getAttribute("content") : void 0 } function qb(e) { const t = e.attributes && e.attributes[O_], n = e.data && e.data[O_], r = e.metadata && e.metadata.source; return t || n || r } const Vb = dm; let Wb = 0; function zb() { return Wb > 0 } function Gb(e, t = {}, n) { if ("function" != typeof e) return e; try { const t = e.__sentry_wrapped__; if (t) return t; if (Pm(e)) return e } catch (o) { return e } const r = function () { const r = Array.prototype.slice.call(arguments); try { n && "function" == typeof n && n.apply(this, arguments); const o = r.map((e => Gb(e, t))); return e.apply(this, o) } catch (o) { throw Wb++, setTimeout((() => { Wb-- })), By((e => { e.addEventProcessor((e => (t.mechanism && (eg(e, void 0, void 0), tg(e, t.mechanism)), e.extra = { ...e.extra, arguments: r }, e))), Fy(o) })), o } }; try { for (const t in e) Object.prototype.hasOwnProperty.call(e, t) && (r[t] = e[t]) } catch (s) { } $m(r, e), Im(e, "__sentry_wrapped__", r); try { Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", { get: () => e.name }) } catch (s) { } return r } const Jb = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__; function Kb(e, t) { const n = Qb(e, t), r = { type: t && t.name, value: Zb(t) }; return n.length && (r.stacktrace = { frames: n }), void 0 === r.type && "" === r.value && (r.value = "Unrecoverable error caught"), r } function Yb(e, t) { return { exception: { values: [Kb(e, t)] } } } function Qb(e, t) { const n = t.stacktrace || t.stack || "", r = function (e) { if (e) { if ("number" == typeof e.framesToPop) return e.framesToPop; if (Xb.test(e.message)) return 1 } return 0 }(t); try { return e(n, r) } catch (o) { } return [] } const Xb = /Minified React error #\d+;/i; function Zb(e) { const t = e && e.message; return t ? t.error && "string" == typeof t.error.message ? t.error.message : t : "No error message" } function ew(e, t, n, r, o) { let s; if (Wh(t) && t.error) { return Yb(e, t.error) } if (zh(t) || Vh(t, "DOMException")) { const o = t; if ("stack" in t) s = Yb(e, t); else { const t = o.name || (zh(o) ? "DOMError" : "DOMException"), i = o.message ? `${t}: ${o.message}` : t; s = tw(e, i, n, r), eg(s, i) } return "code" in o && (s.tags = { ...s.tags, "DOMException.code": `${o.code}` }), s } if (qh(t)) return Yb(e, t); if (Yh(t) || Qh(t)) { return s = function (e, t, n, r) { const o = qy(), s = o && o.getOptions().normalizeDepth, i = { exception: { values: [{ type: Qh(t) ? t.constructor.name : r ? "UnhandledRejection" : "Error", value: nw(t, { isUnhandledRejection: r }) }] }, extra: { __serialized__: Ng(t, s) } }; if (n) { const t = Qb(e, n); t.length && (i.exception.values[0].stacktrace = { frames: t }) } return i }(e, t, n, o), tg(s, { synthetic: !0 }), s } return s = tw(e, t, n, r), eg(s, `${t}`, void 0), tg(s, { synthetic: !0 }), s } function tw(e, t, n, r) { const o = {}; if (r && n) { const r = Qb(e, n); r.length && (o.exception = { values: [{ value: t, stacktrace: { frames: r } }] }) } if (Jh(t)) { const { __sentry_template_string__: e, __sentry_template_values__: n } = t; return o.logentry = { message: e, params: n }, o } return o.message = t, o } function nw(e, { isUnhandledRejection: t }) { const n = function (e, t = 40) { const n = Object.keys(jm(e)); if (n.sort(), !n.length) return "[object has no keys]"; if (n[0].length >= t) return rm(n[0], t); for (let r = n.length; r > 0; r--) { const e = n.slice(0, r).join(", "); if (!(e.length > t)) return r === n.length ? e : rm(e, t) } return "" }(e), r = t ? "promise rejection" : "exception"; if (Wh(e)) return `Event \`ErrorEvent\` captured as ${r} with message \`${e.message}\``; if (Qh(e)) { return `Event \`${function (e) { try { const t = Object.getPrototypeOf(e); return t ? t.constructor.name : void 0 } catch (t) { } }(e)}\` (type=${e.type}) captured as ${r}` } return `Object captured as ${r} with keys: ${n}` } class rw extends tv { constructor(e) { !function (e, t, n = [t], r = "npm") { const o = e._metadata || {}; o.sdk || (o.sdk = { name: `sentry.javascript.${t}`, packages: n.map((e => ({ name: `${r}:@sentry/${e}`, version: o_ }))), version: o_ }), e._metadata = o }(e, "browser", ["browser"], Vb.SENTRY_SDK_SOURCE || "npm"), super(e), e.sendClientReports && Vb.document && Vb.document.addEventListener("visibilitychange", (() => { "hidden" === Vb.document.visibilityState && this._flushOutcomes() })) } eventFromException(e, t) { return function (e, t, n, r) { const o = ew(e, t, n && n.syntheticException || void 0, r); return tg(o), o.level = "error", n && n.event_id && (o.event_id = n.event_id), Ug(o) }(this._options.stackParser, e, t, this._options.attachStacktrace) } eventFromMessage(e, t = "info", n) { return function (e, t, n = "info", r, o) { const s = tw(e, t, r && r.syntheticException || void 0, o); return s.level = n, r && r.event_id && (s.event_id = r.event_id), Ug(s) }(this._options.stackParser, e, t, n, this._options.attachStacktrace) } captureUserFeedback(e) { if (!this._isEnabled()) return void (Jb && Em.warn("SDK not enabled, will not capture user feedback.")); const t = function (e, { metadata: t, tunnel: n, dsn: r }) { const o = { event_id: e.event_id, sent_at: (new Date).toISOString(), ...t && t.sdk && { sdk: { name: t.sdk.name, version: t.sdk.version } }, ...!!n && !!r && { dsn: xm(r) } }, s = function (e) { return [{ type: "user_report" }, e] }(e); return cy(o, [s]) }(e, { metadata: this.getSdkMetadata(), dsn: this.getDsn(), tunnel: this.getOptions().tunnel }); this._sendEnvelope(t) } _prepareEvent(e, t, n) { return e.platform = e.platform || "javascript", super._prepareEvent(e, t, n) } _flushOutcomes() { const e = this._clearOutcomes(); if (0 === e.length) return void (Jb && Em.log("No outcomes to send")); if (!this._dsn) return void (Jb && Em.log("No dsn provided, will not send outcomes")); Jb && Em.log("Sending outcomes:", e); const t = (n = e, cy((r = this._options.tunnel && xm(this._dsn)) ? { dsn: r } : {}, [[{ type: "client_report" }, { timestamp: o || Yg(), discarded_events: n }]])); var n, r, o; this._sendEnvelope(t) } } let ow; function sw(e, t = function () { if (ow) return ow; if (fg(Vb.fetch)) return ow = Vb.fetch.bind(Vb); const e = Vb.document; let t = Vb.fetch; if (e && "function" == typeof e.createElement) try { const n = e.createElement("iframe"); n.hidden = !0, e.head.appendChild(n); const r = n.contentWindow; r && r.fetch && (t = r.fetch), e.head.removeChild(n) } catch (n) { Jb && Em.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n) } return ow = t.bind(Vb) }()) { let n = 0, r = 0; return iv(e, (function (o) { const s = o.body.length; n += s, r++; const i = { body: o.body, method: "POST", referrerPolicy: "origin", headers: e.headers, keepalive: n <= 6e4 && r < 15, ...e.fetchOptions }; try { return t(e.url, i).then((e => (n -= s, r--, { statusCode: e.status, headers: { "x-sentry-rate-limits": e.headers.get("X-Sentry-Rate-Limits"), "retry-after": e.headers.get("Retry-After") } }))) } catch (a) { return ow = void 0, n -= s, r--, Hg(a) } })) } const iw = 4; function aw(e) { return iv(e, (function (t) { return new Bg(((n, r) => { const o = new XMLHttpRequest; o.onerror = r, o.onreadystatechange = () => { o.readyState === iw && n({ statusCode: o.status, headers: { "x-sentry-rate-limits": o.getResponseHeader("X-Sentry-Rate-Limits"), "retry-after": o.getResponseHeader("Retry-After") } }) }, o.open("POST", e.url); for (const t in e.headers) Object.prototype.hasOwnProperty.call(e.headers, t) && o.setRequestHeader(t, e.headers[t]); o.send(t.body) })) })) } const cw = "?"; function lw(e, t, n, r) { const o = { filename: e, function: t, in_app: !0 }; return void 0 !== n && (o.lineno = n), void 0 !== r && (o.colno = r), o } const uw = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, dw = /\((\S*)(?::(\d+))(?::(\d+))\)/, pw = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i, fw = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i, hw = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i, mw = Bm(...[[30, e => { const t = uw.exec(e); if (t) { if (t[2] && 0 === t[2].indexOf("eval")) { const e = dw.exec(t[2]); e && (t[2] = e[1], t[3] = e[2], t[4] = e[3]) } const [e, n] = gw(t[1] || cw, t[2]); return lw(n, e, t[3] ? +t[3] : void 0, t[4] ? +t[4] : void 0) } }], [50, e => { const t = pw.exec(e); if (t) { if (t[3] && t[3].indexOf(" > eval") > -1) { const e = fw.exec(t[3]); e && (t[1] = t[1] || "eval", t[3] = e[1], t[4] = e[2], t[5] = "") } let e = t[3], n = t[1] || cw; return [n, e] = gw(n, e), lw(e, n, t[4] ? +t[4] : void 0, t[5] ? +t[5] : void 0) } }], [40, e => { const t = hw.exec(e); return t ? lw(t[2], t[1] || cw, +t[3], t[4] ? +t[4] : void 0) : void 0 }]]), gw = (e, t) => { const n = -1 !== e.indexOf("safari-extension"), r = -1 !== e.indexOf("safari-web-extension"); return n || r ? [-1 !== e.indexOf("@") ? e.split("@")[0] : cw, n ? `safari-extension:${t}` : `safari-web-extension:${t}`] : [e, t] }, yw = 1024, _w = "Breadcrumbs", vw = (e = {}) => { const t = { console: !0, dom: !0, fetch: !0, history: !0, sentry: !0, xhr: !0, ...e }; return { name: _w, setupOnce() { }, setup(e) { var n; t.console && function (e) { const t = "console"; Gm(t, e), Jm(t, Ym) }(function (e) { return function (t) { if (qy() !== e) return; const n = { category: "console", data: { arguments: t.args, logger: "console" }, level: Jg(t.level), message: om(t.args, " ") }; if ("assert" === t.level) { if (!1 !== t.args[0]) return; n.message = `Assertion failed: ${om(t.args.slice(1), " ") || "console.assert"}`, n.data.arguments = t.args.slice(1) } Hy(n, { input: t.args, level: t.level }) } }(e)), t.dom && (n = function (e, t) { return function (n) { if (qy() !== e) return; let r, o, s = "object" == typeof t ? t.serializeAttribute : void 0, i = "object" == typeof t && "number" == typeof t.maxStringLength ? t.maxStringLength : void 0; i && i > yw && (Jb && Em.warn(`\`dom.maxStringLength\` cannot exceed 1024, but a value of ${i} was configured. Sentry will use 1024 instead.`), i = yw), "string" == typeof s && (s = [s]); try { const e = n.event, t = function (e) { return !!e && !!e.target }(e) ? e.target : e; r = gm(t, { keyAttrs: s, maxStringLength: i }), o = vm(t) } catch (c) { r = "<unknown>" } if (0 === r.length) return; const a = { category: `ui.${n.name}`, message: r }; o && (a.data = { "ui.component_name": o }), Hy(a, { event: n.event, name: n.name, global: n.global }) } }(e, t.dom), Gm("dom", n), Jm("dom", lg)), t.xhr && Ig(function (e) { return function (t) { if (qy() !== e) return; const { startTimestamp: n, endTimestamp: r } = t, o = t.xhr[Rg]; if (!n || !r || !o) return; const { method: s, url: i, status_code: a, body: c } = o; Hy({ category: "xhr", data: { method: s, url: i, status_code: a }, type: "http" }, { xhr: t.xhr, input: c, startTimestamp: n, endTimestamp: r }) } }(e)), t.fetch && hg(function (e) { return function (t) { if (qy() !== e) return; const { startTimestamp: n, endTimestamp: r } = t; if (r && (!t.fetchData.url.match(/sentry_key/) || "POST" !== t.fetchData.method)) if (t.error) { Hy({ category: "fetch", data: t.fetchData, level: "error", type: "http" }, { data: t.error, input: t.args, startTimestamp: n, endTimestamp: r }) } else { const e = t.response; Hy({ category: "fetch", data: { ...t.fetchData, status_code: e && e.status }, type: "http" }, { input: t.args, response: e, startTimestamp: n, endTimestamp: r }) } } }(e)), t.history && Cg(function (e) { return function (t) { if (qy() !== e) return; let n = t.from, r = t.to; const o = Vg(Vb.location.href); let s = n ? Vg(n) : void 0; const i = Vg(r); s && s.path || (s = o), o.protocol === i.protocol && o.host === i.host && (r = i.relative), o.protocol === s.protocol && o.host === s.host && (n = s.relative), Hy({ category: "navigation", data: { from: n, to: r } }) } }(e)), t.sentry && e.on && e.on("beforeSendEvent", function (e) { return function (t) { qy() === e && Hy({ category: "sentry." + ("transaction" === t.type ? "transaction" : "event"), event_id: t.event_id, level: t.level, message: Zm(t) }, { event: t }) } }(e)) } } }; X_(_w, vw); const bw = "Dedupe", ww = () => { let e; return { name: bw, setupOnce() { }, processEvent(t) { if (t.type) return t; try { if (function (e, t) { if (!t) return !1; if (function (e, t) { const n = e.message, r = t.message; if (!n && !r) return !1; if (n && !r || !n && r) return !1; if (n !== r) return !1; if (!kw(e, t)) return !1; if (!Sw(e, t)) return !1; return !0 }(e, t)) return !0; if (function (e, t) { const n = Ew(t), r = Ew(e); if (!n || !r) return !1; if (n.type !== r.type || n.value !== r.value) return !1; if (!kw(e, t)) return !1; if (!Sw(e, t)) return !1; return !0 }(e, t)) return !0; return !1 }(t, e)) return Jb && Em.warn("Event dropped due to being a duplicate of previously captured event."), null } catch (n) { } return e = t } } }; function Sw(e, t) { let n = Tw(e), r = Tw(t); if (!n && !r) return !0; if (n && !r || !n && r) return !1; if (r.length !== n.length) return !1; for (let o = 0; o < r.length; o++) { const e = r[o], t = n[o]; if (e.filename !== t.filename || e.lineno !== t.lineno || e.colno !== t.colno || e.function !== t.function) return !1 } return !0 } function kw(e, t) { let n = e.fingerprint, r = t.fingerprint; if (!n && !r) return !0; if (n && !r || !n && r) return !1; try { return !(n.join("") !== r.join("")) } catch (o) { return !1 } } function Ew(e) { return e.exception && e.exception.values && e.exception.values[0] } function Tw(e) { const t = e.exception; if (t) try { return t.values[0].stacktrace.frames } catch (n) { return } } X_(bw, ww); const xw = "GlobalHandlers", Cw = (e = {}) => { const t = { onerror: !0, onunhandledrejection: !0, ...e }; return { name: xw, setupOnce() { Error.stackTraceLimit = 50 }, setup(e) { t.onerror && (!function (e) { vg((t => { const { stackParser: n, attachStacktrace: r } = Rw(); if (qy() !== e || zb()) return; const { msg: o, url: s, line: i, column: a, error: c } = t, l = void 0 === c && Gh(o) ? function (e, t, n, r) { const o = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i; let s = Wh(e) ? e.message : e, i = "Error"; const a = s.match(o); a && (i = a[1], s = a[2]); const c = { exception: { values: [{ type: i, value: s }] } }; return Ow(c, t, n, r) }(o, s, i, a) : Ow(ew(n, c || o, void 0, r, !1), s, i, a); l.level = "error", Uy(l, { originalException: c, mechanism: { handled: !1, type: "onerror" } }) })) }(e), Aw("onerror")), t.onunhandledrejection && (!function (e) { Sg((t => { const { stackParser: n, attachStacktrace: r } = Rw(); if (qy() !== e || zb()) return; const o = function (e) { if (Kh(e)) return e; const t = e; try { if ("reason" in t) return t.reason; if ("detail" in t && "reason" in t.detail) return t.detail.reason } catch (n) { } return e }(t), s = Kh(o) ? { exception: { values: [{ type: "UnhandledRejection", value: `Non-Error promise rejection captured with value: ${String(o)}` }] } } : ew(n, o, void 0, r, !0); s.level = "error", Uy(s, { originalException: o, mechanism: { handled: !1, type: "onunhandledrejection" } }) })) }(e), Aw("onunhandledrejection")) } } }; function Ow(e, t, n, r) { const o = e.exception = e.exception || {}, s = o.values = o.values || [], i = s[0] = s[0] || {}, a = i.stacktrace = i.stacktrace || {}, c = a.frames = a.frames || [], l = isNaN(parseInt(r, 10)) ? void 0 : r, u = isNaN(parseInt(n, 10)) ? void 0 : n, d = Gh(t) && t.length > 0 ? t : function () { try { return hm.document.location.href } catch (e) { return "" } }(); return 0 === c.length && c.push({ colno: l, filename: d, function: "?", in_app: !0, lineno: u }), e } function Aw(e) { Jb && Em.log(`Global Handler attached: ${e}`) } function Rw() { const e = qy(); return e && e.getOptions() || { stackParser: () => [], attachStacktrace: !1 } } X_(xw, Cw); const Iw = "HttpContext", $w = () => ({ name: Iw, setupOnce() { }, preprocessEvent(e) { if (!Vb.navigator && !Vb.location && !Vb.document) return; const t = e.request && e.request.url || Vb.location && Vb.location.href, { referrer: n } = Vb.document || {}, { userAgent: r } = Vb.navigator || {}, o = { ...e.request && e.request.headers, ...n && { Referer: n }, ...r && { "User-Agent": r } }, s = { ...e.request, ...t && { url: t }, headers: o }; e.request = s } }); X_(Iw, $w); const Pw = "LinkedErrors", jw = (e = {}) => { const t = e.limit || 5, n = e.key || "cause"; return { name: Pw, setupOnce() { }, preprocessEvent(e, r, o) { const s = o.getOptions(); im(Kb, s.stackParser, s.maxValueLength, n, t, e, r) } } }; X_(Pw, jw); const Lw = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"], Dw = "TryCatch", Nw = (e = {}) => { const t = { XMLHttpRequest: !0, eventTarget: !0, requestAnimationFrame: !0, setInterval: !0, setTimeout: !0, ...e }; return { name: Dw, setupOnce() { t.setTimeout && Rm(Vb, "setTimeout", Mw), t.setInterval && Rm(Vb, "setInterval", Mw), t.requestAnimationFrame && Rm(Vb, "requestAnimationFrame", Fw), t.XMLHttpRequest && "XMLHttpRequest" in Vb && Rm(XMLHttpRequest.prototype, "send", Uw); const e = t.eventTarget; if (e) { (Array.isArray(e) ? e : Lw).forEach(Hw) } } } }; function Mw(e) { return function (...t) { const n = t[0]; return t[0] = Gb(n, { mechanism: { data: { function: Vm(e) }, handled: !1, type: "instrument" } }), e.apply(this, t) } } function Fw(e) { return function (t) { return e.apply(this, [Gb(t, { mechanism: { data: { function: "requestAnimationFrame", handler: Vm(e) }, handled: !1, type: "instrument" } })]) } } function Uw(e) { return function (...t) { const n = this; return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((e => { e in n && "function" == typeof n[e] && Rm(n, e, (function (t) { const n = { mechanism: { data: { function: e, handler: Vm(t) }, handled: !1, type: "instrument" } }, r = Pm(t); return r && (n.mechanism.data.handler = Vm(r)), Gb(t, n) })) })), e.apply(this, t) } } function Hw(e) { const t = Vb, n = t[e] && t[e].prototype; n && n.hasOwnProperty && n.hasOwnProperty("addEventListener") && (Rm(n, "addEventListener", (function (t) { return function (n, r, o) { try { "function" == typeof r.handleEvent && (r.handleEvent = Gb(r.handleEvent, { mechanism: { data: { function: "handleEvent", handler: Vm(r), target: e }, handled: !1, type: "instrument" } })) } catch (s) { } return t.apply(this, [n, Gb(r, { mechanism: { data: { function: "addEventListener", handler: Vm(r), target: e }, handled: !1, type: "instrument" } }), o]) } })), Rm(n, "removeEventListener", (function (e) { return function (t, n, r) { const o = n; try { const n = o && o.__sentry_wrapped__; n && e.call(this, t, n, r) } catch (s) { } return e.call(this, t, o, r) } }))) } X_(Dw, Nw); const Bw = [pv(), yv(), Nw(), vw(), Cw(), jw(), ww(), $w()]; function qw(e) { return [...Bw] } function Vw(e = {}) { void 0 === e.defaultIntegrations && (e.defaultIntegrations = qw()), void 0 === e.release && ("string" == typeof __SENTRY_RELEASE__ && (e.release = __SENTRY_RELEASE__), Vb.SENTRY_RELEASE && Vb.SENTRY_RELEASE.id && (e.release = Vb.SENTRY_RELEASE.id)), void 0 === e.autoSessionTracking && (e.autoSessionTracking = !0), void 0 === e.sendClientReports && (e.sendClientReports = !0); const t = { ...e, stackParser: (n = e.stackParser || mw, Array.isArray(n) ? Bm(...n) : n), integrations: K_(e), transport: e.transport || (pg() ? sw : aw) }; var n; ov(rw, t), e.autoSessionTracking && function () { if (void 0 === Vb.document) return void (Jb && Em.warn("Session tracking in non-browser environment with @sentry/browser is not supported.")); Wy({ ignoreDuration: !0 }), Jy(), Cg((({ from: e, to: t }) => { void 0 !== e && e !== t && (Wy({ ignoreDuration: !0 }), Jy()) })) }() } const Ww = ["activate", "mount", "update"], zw = /(?:^|[-_])(\w)/g, Gw = "<Anonymous>", Jw = (e, t) => { if (!e) return Gw; if (e.$root === e) return "<Root>"; if (!e.$options) return Gw; const n = e.$options; let r = n.name || n._componentTag; const o = n.__file; if (!r && o) { const e = o.match(/([^/\\]+)\.vue$/); e && (r = e[1]) } return (r ? `<${s = r, s.replace(zw, (e => e.toUpperCase())).replace(/[-_]/g, "")}>` : Gw) + (o && !1 !== t ? ` at ${o}` : ""); var s }, Kw = (e, t) => { const { errorHandler: n, warnHandler: r, silent: o } = e.config; e.config.errorHandler = (s, i, a) => { const c = Jw(i, !1), l = i ? (e => { if (e && (e._isVue || e.__isVue) && e.$parent) { const t = []; let n = 0; for (; e;) { if (t.length > 0) { const r = t[t.length - 1]; if (r.constructor === e.constructor) { n++, e = e.$parent; continue } n > 0 && (t[t.length - 1] = [r, n], n = 0) } t.push(e), e = e.$parent } return `\n\nfound in\n\n${t.map(((e, t) => { return `${(0 === t ? "---\x3e " : (n = " ", r = 5 + 2 * t, n.repeat ? n.repeat(r) : n)) + (Array.isArray(e) ? `${Jw(e[0])}... (${e[1]} recursive calls)` : Jw(e))}`; var n, r })).join("\n")}` } return `\n\n(found in ${Jw(e)})` })(i) : "", u = { componentName: c, lifecycleHook: a, trace: l }; if (t.attachProps && i && (i.$options && i.$options.propsData ? u.propsData = i.$options.propsData : i.$props && (u.propsData = i.$props)), setTimeout((() => { Fy(s, { captureContext: { contexts: { vue: u } }, mechanism: { handled: !1 } }) })), "function" == typeof n && n.call(e, s, i, a), t.logErrors) { const e = "undefined" != typeof console, t = `Error in ${a}: "${s && s.toString()}"`; r ? r.call(null, t, i, l) : e && !o && km((() => { console.error(`[Vue warn]: ${t}${l}`) })) } } }, Yw = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__, Qw = "ui.vue", Xw = { activate: ["activated", "deactivated"], create: ["beforeCreate", "created"], unmount: ["beforeUnmount", "unmounted"], destroy: ["beforeDestroy", "destroyed"], mount: ["beforeMount", "mounted"], update: ["beforeUpdate", "updated"] }; const Zw = e => { const t = (e.hooks || []).concat(Ww).filter(((e, t, n) => n.indexOf(e) === t)), n = {}; for (const r of t) { const t = Xw[r]; if (t) for (const o of t) n[o] = function () { const n = this.$root === this; if (n) { k_() && (this.$_sentryRootSpan = this.$_sentryRootSpan || S_({ name: "Application Render", op: `${Qw}.render`, origin: "auto.ui.vue" })) } const s = Jw(this, !1), i = Array.isArray(e.trackComponents) ? e.trackComponents.indexOf(s) > -1 : e.trackComponents; var a, c, l; if (n || i) if (this.$_sentrySpans = this.$_sentrySpans || {}, o == t[0]) { if (this.$root && this.$root.$_sentryRootSpan || k_()) { const e = this.$_sentrySpans[r]; e && e.end(), this.$_sentrySpans[r] = S_({ name: `Vue <${s}>`, op: `${Qw}.${r}`, origin: "auto.ui.vue" }) } } else { const t = this.$_sentrySpans[r]; if (!t) return; t.end(), a = this, c = Qg(), l = e.timeout, a.$_sentryRootSpanTimer && clearTimeout(a.$_sentryRootSpanTimer), a.$_sentryRootSpanTimer = setTimeout((() => { a.$root && a.$root.$_sentryRootSpan && (a.$root.$_sentryRootSpan.end(c), a.$root.$_sentryRootSpan = void 0) }), l) } }; else Yw && Em.warn(`Unknown hook: ${r}`) } return n }, eS = { Vue: dm.Vue, attachProps: !0, logErrors: !0, hooks: Ww, timeout: 2e3, trackComponents: !1 }, tS = (e = {}) => ({ name: "Vue", setupOnce() { }, setup(t) { !function (e, t) { const n = { ...eS, ...e.getOptions(), ...t }; if (!n.Vue && !n.app) return void km((() => { console.warn("[@sentry/vue]: Misconfigured SDK. Vue specific errors will not be captured.\nUpdate your `Sentry.init` call with an appropriate config option:\n`app` (Application Instance - Vue 3) or `Vue` (Vue Constructor - Vue 2).") })); if (n.app) { rg(n.app).forEach((e => nS(e, n))) } else n.Vue && nS(n.Vue, n) }(t, e) } }); X_("Vue", tS); const nS = (e, t) => { const n = e; !0 === (n._instance && n._instance.isMounted) && km((() => { console.warn("[@sentry/vue]: Misconfigured SDK. Vue app is already mounted. Make sure to call `app.mount()` after `Sentry.init()`.") })), Kw(e, t), b_(t) && e.mixin(Zw({ ...t, ...t.tracingOptions })) }; const rS = class { constructor(e) { this.name = "BrowserTracing", this._hasSetTracePropagationTargets = !1, V_(), _v && (this._hasSetTracePropagationTargets = !(!e || !e.tracePropagationTargets && !e.tracingOrigins)), this.options = { ...Hb, ...e }, void 0 !== this.options._experiments.enableLongTask && (this.options.enableLongTask = this.options._experiments.enableLongTask), e && !e.tracePropagationTargets && e.tracingOrigins && (this.options.tracePropagationTargets = e.tracingOrigins), this._collectWebVitals = Ab(), this._interactionIdToRouteNameMapping = {}, this.options.enableInp && Rb(this._interactionIdToRouteNameMapping), this.options.enableLongTask && ub("longtask", (({ entries: e }) => { for (const t of e) { const e = h_(); if (!e) return; const n = kb(Xg + t.startTime), r = kb(t.duration); e.startChild({ description: "Main UI thread blocked", op: "ui.long-task", origin: "auto.ui.browser.metrics", startTimestamp: n, endTimestamp: n + r }) } })), this.options._experiments.enableInteractions && ub("event", (({ entries: e }) => { for (const t of e) { const e = h_(); if (!e) return; if ("click" === t.name) { const n = kb(Xg + t.startTime), r = kb(t.duration), o = { description: gm(t.target), op: `ui.interaction.${t.name}`, origin: "auto.ui.browser.metrics", startTimestamp: n, endTimestamp: n + r }, s = vm(t.target); s && (o.attributes = { "ui.component_name": s }), e.startChild(o) } } })), this._latestRoute = { name: void 0, context: void 0 } } setupOnce(e, t) { this._getCurrentHub = t; const n = t().getClient(), r = n && n.getOptions(), { routingInstrumentation: o, startTransactionOnLocationChange: s, startTransactionOnPageLoad: i, markBackgroundTransactions: a, traceFetch: c, traceXHR: l, shouldCreateSpanForRequest: u, enableHTTPTimings: d, _experiments: p } = this.options, f = r && r.tracePropagationTargets, h = f || this.options.tracePropagationTargets; _v && this._hasSetTracePropagationTargets && f && Em.warn("[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used."), o((e => { const n = this._createRouteTransaction(e); return this.options._experiments.onStartRouteTransaction && this.options._experiments.onStartRouteTransaction(n, e, t), n }), i, s), a && ($v && $v.document ? $v.document.addEventListener("visibilitychange", (() => { const e = h_(); if ($v.document.hidden && e) { const t = "cancelled", { op: n, status: r } = Py(e); _v && Em.log(`[Tracing] Transaction: ${t} -> since tab moved to the background, op: ${n}`), r || e.setStatus(t), e.setTag("visibilitychange", "document.hidden"), e.end() } })) : _v && Em.warn("[Tracing] Could not set up background tab detection due to lack of global document")), p.enableInteractions && this._registerInteractionListener(), this.options.enableInp && this._registerInpInteractionListener(), Mb({ traceFetch: c, traceXHR: l, tracePropagationTargets: h, shouldCreateSpanForRequest: u, enableHTTPTimings: d }) } _createRouteTransaction(e) { if (!this._getCurrentHub) return void (_v && Em.warn(`[Tracing] Did not create ${e.op} transaction because _getCurrentHub is invalid.`)); const t = this._getCurrentHub(), { beforeNavigate: n, idleTimeout: r, finalTimeout: o, heartbeatInterval: s } = this.options, i = "pageload" === e.op; let a; if (i) { const t = i ? Bb("sentry-trace") : "", n = i ? Bb("baggage") : void 0, { traceId: r, dsc: o, parentSpanId: s, sampled: c } = iy(t, n); a = { traceId: r, parentSpanId: s, parentSampled: c, ...e, metadata: { ...e.metadata, dynamicSamplingContext: o }, trimEnd: !0 } } else a = { trimEnd: !0, ...e }; const c = "function" == typeof n ? n(a) : a, l = void 0 === c ? { ...a, sampled: !1 } : c; l.metadata = l.name !== a.name ? { ...l.metadata, source: "custom" } : l.metadata, this._latestRoute.name = l.name, this._latestRoute.context = l, !1 === l.sampled && _v && Em.log(`[Tracing] Will not send ${l.op} transaction because of beforeNavigate.`), _v && Em.log(`[Tracing] Starting ${l.op} transaction on scope`); const { location: u } = $v, d = q_(t, l, r, o, !0, { location: u }, s, i); return i && ($v.document.addEventListener("readystatechange", (() => { ["interactive", "complete"].includes($v.document.readyState) && d.sendAutoFinishSignal() })), ["interactive", "complete"].includes($v.document.readyState) && d.sendAutoFinishSignal()), d.registerBeforeFinishCallback((e => { this._collectWebVitals(), $b(e) })), d } _registerInteractionListener() { let e; const t = () => { const { idleTimeout: t, finalTimeout: n, heartbeatInterval: r } = this.options, o = "ui.action.click", s = h_(); if (s && s.op && ["navigation", "pageload"].includes(s.op)) return void (_v && Em.warn(`[Tracing] Did not create ${o} transaction because a pageload or navigation transaction is in progress.`)); if (e && (e.setFinishReason("interactionInterrupted"), e.end(), e = void 0), !this._getCurrentHub) return void (_v && Em.warn(`[Tracing] Did not create ${o} transaction because _getCurrentHub is invalid.`)); if (!this._latestRoute.name) return void (_v && Em.warn(`[Tracing] Did not create ${o} transaction because _latestRouteName is missing.`)); const i = this._getCurrentHub(), { location: a } = $v, c = { name: this._latestRoute.name, op: o, trimEnd: !0, data: { [O_]: this._latestRoute.context ? qb(this._latestRoute.context) : "url" } }; e = q_(i, c, t, n, !0, { location: a }, r) };["click"].forEach((e => { addEventListener(e, t, { once: !1, capture: !0 }) })) } _registerInpInteractionListener() { const e = ({ entries: e }) => { const t = qy(), n = void 0 !== t && void 0 !== t.getIntegrationByName ? t.getIntegrationByName("Replay") : void 0, r = void 0 !== n ? n.getReplayId() : void 0, o = h_(), s = Vy(), i = void 0 !== s ? s.getUser() : void 0; e.forEach((e => { if (function (e) { return "duration" in e }(e)) { const t = e.interactionId; if (void 0 === t) return; const n = this._interactionIdToRouteNameMapping[t], s = e.duration, a = e.startTime, c = Object.keys(this._interactionIdToRouteNameMapping), l = c.length > 0 ? c.reduce(((e, t) => this._interactionIdToRouteNameMapping[e].duration < this._interactionIdToRouteNameMapping[t].duration ? e : t)) : void 0; if ("first-input" === e.entryType) { if (c.map((e => this._interactionIdToRouteNameMapping[e])).some((e => e.duration === s && e.startTime === a))) return } if (!t) return; if (n) n.duration = Math.max(n.duration, s); else if (c.length < 10 || void 0 === l || s > this._interactionIdToRouteNameMapping[l].duration) { const e = this._latestRoute.name, n = this._latestRoute.context; e && n && (l && Object.keys(this._interactionIdToRouteNameMapping).length >= 10 && delete this._interactionIdToRouteNameMapping[l], this._interactionIdToRouteNameMapping[t] = { routeName: e, duration: s, parentContext: n, user: i, activeTransaction: o, replayId: r, startTime: a }) } } })) }; ub("event", e), ub("first-input", e) } }, oS = { BrowserTracing: rS, Apollo: Rv, Express: bv, GraphQL: Av, Mongo: Cv, Mysql: Ev, Postgres: kv, Prisma: Ov }; ("undefined" == typeof __SENTRY_TRACING__ || __SENTRY_TRACING__) && (V_(), Pg() && function () { const e = c_(); if (!e.__SENTRY__) return; const t = { mongodb: () => new (jg(module, "./node/integrations/mongo").Mongo), mongoose: () => new (jg(module, "./node/integrations/mongo").Mongo), mysql: () => new (jg(module, "./node/integrations/mysql").Mysql), pg: () => new (jg(module, "./node/integrations/postgres").Postgres) }, n = Object.keys(t).filter((e => !!Lg(e))).map((e => { try { return t[e]() } catch (n) { return } })).filter((e => e)); n.length > 0 && (e.__SENTRY__.integrations = [...e.__SENTRY__.integrations || [], ...n]) }()); const sS = Oc((async e => { !function (e = {}) { Vw({ _metadata: { sdk: { name: "sentry.javascript.vue", packages: [{ name: "npm:@sentry/vue", version: o_ }], version: o_ } }, defaultIntegrations: [...qw(), tS()], ...e }) }({ app: e.vueApp, dsn: "", integrations: [new oS.BrowserTracing], tracesSampleRate: 1 }) })); var iS = { library: "https://accounts.google.com/gsi/client", defaultButtonConfig: { theme: "outline", size: "large" }, scopes: "email profile openid" }; const aS = Te({ clientId: null, popupType: "CODE", prompt: !1, autoLogin: !1, idConfiguration: null, buttonConfig: iS.defaultButtonConfig, callback: () => { }, error: null }), cS = Te({ apiLoaded: !1, apiLoadIntitited: !1 }), lS = new Promise((e => { const t = "undefined" != typeof window; if (!cS.apiLoadIntitited && t) { const t = document.createElement("script"); cS.apiLoadIntitited = !0, t.addEventListener("load", (() => { cS.apiLoaded = !0, e(window.google) })), t.src = iS.library, t.async = !0, t.defer = !0, document.head.appendChild(t) } })), uS = e => { cS.apiLoadIntitited ? cS.apiLoaded ? e(window.google) : qn((() => cS.apiLoaded), (t => { t && e(window.google) })) : lS.then((t => { e(t) })) }, dS = e => { if (!e && (e = {}), !e.clientId && !aS.clientId) throw new Error("clientId is required"); const t = { use_fedcm_for_prompt: !0 }; return e.clientId && (t.client_id = e.clientId), !e.clientId && aS.clientId && (t.client_id = aS.clientId), e.context && (t.context = e.context), null != e.autoLogin && (t.auto_select = e.autoLogin), null != e.cancelOnTapOutside && (t.cancel_on_tap_outside = e.cancelOnTapOutside), new Promise(((n, r) => { t.callback = t => { e && e.callback && e.callback(t), t.credential ? n(t) : r(t) }, uS((e => { e.accounts.id.initialize(t), e.accounts.id.prompt() })) })) }; var pS = cr({ __name: "GoogleLogin", props: { clientId: { type: String, required: !1 }, prompt: { type: Boolean, required: !1, default: !1 }, autoLogin: { type: Boolean, required: !1, default: !1 }, popupType: { type: String, required: !1 }, idConfiguration: { type: Object, required: !1 }, buttonConfig: { type: Object, required: !1 }, callback: { type: Function, required: !1 }, error: { type: Function, required: !1 } }, setup(e) { const t = !!qr().default, n = e, r = ((e, t) => { const n = { ...aS }; for (const r in t) void 0 !== t[r] && null !== t[r] && (n[r] = t[r]); return n })(0, n), o = { client_id: r.clientId || null, auto_select: r.autoLogin || !1, callback: r.callback, ...r.idConfiguration }, s = Ue(); return Tr((() => { ((e, t, n, r) => { if (!e.client_id) throw new Error("Prop client id required since plugin is not initialized with a client id"); uS((() => { ((e, t, n, r, o) => { if (o) { const t = e.callback; e.callback = e => { e.credential ? t && t(e) : o(e) } } window.google.accounts.id.initialize(e); const s = t.value; s && !r && window.google.accounts.id.renderButton(s, n) })(e, t, n.buttonConfig, r, n.error), n.prompt && dS({ clientId: n.clientId, callback: n.callback, error: n.error, autoLogin: n.autoLogin }) })) })(o, s, r, t), n.popupType && !t && console.warn("Option 'popupType' is ignored since a slot which act as a custom login button was not found!!!") })), (e, n) => (Jo(), Zo("div", { class: "g-btn-wrapper", onClick: n[0] || (n[0] = e => Ve(t) && void ("TOKEN" === Ve(r).popupType ? (e => new Promise(((t, n) => { uS((r => { if (!(e && e.clientId || aS.clientId)) throw new Error("clientId is required since the plugin is not initialized with a Client Id"); r.accounts.oauth2.initTokenClient({ client_id: e && e.clientId || aS.clientId || "", scope: iS.scopes, callback: e => { e.access_token ? t(e) : n(e) }, error_callback: e => { n(e) } }).requestAccessToken() })) })))({ clientId: r.clientId }).then((e => { r.callback && r.callback(e) })).catch((e => { r.error && r.error(e) })) : (e => new Promise(((t, n) => { uS((r => { if (!(e && e.clientId || aS.clientId)) throw new Error("clientId is required since the plugin is not initialized with a Client Id"); r.accounts.oauth2.initCodeClient({ client_id: e && e.clientId || aS.clientId || "", scope: iS.scopes, ux_mode: "popup", callback: e => { e.code ? t(e) : n(e) }, error_callback: e => { n(e) } }).requestCode() })) })))({ clientId: r.clientId }).then((e => { r.callback && r.callback(e) })).catch((e => { r.error && r.error(e) })))) }, [Ve(t) ? ds("v-if", !0) : (Jo(), Zo("span", { key: 0, ref_key: "buttonRef", ref: s, class: "g-btn" }, null, 512)), Dr(e.$slots, "default")])) } }); !function (e, t) { void 0 === t && (t = {}); var n = t.insertAt; if (e && "undefined" != typeof document) { var r = document.head || document.getElementsByTagName("head")[0], o = document.createElement("style"); o.type = "text/css", "top" === n && r.firstChild ? r.insertBefore(o, r.firstChild) : r.appendChild(o), o.styleSheet ? o.styleSheet.cssText = e : o.appendChild(document.createTextNode(e)) } }("\n.g-btn-wrapper[data-v-5e610566] {\n  display: inline-block;\n}\n"), pS.__scopeId = "data-v-5e610566", pS.__file = "src/plugin/GoogleLogin.vue"; var fS = { install: (e, t) => { var n; t && ((n = t).clientId && (aS.clientId = n.clientId), n.popupType && (aS.popupType = n.popupType), null != n.prompt && (aS.prompt = n.prompt), null != n.autoLogin && (aS.autoLogin = n.autoLogin), n.idConfiguration && (aS.idConfiguration = n.idConfiguration), n.buttonConfig && (aS.buttonConfig = n.buttonConfig), n.callback && (aS.callback = n.callback)), lS.then((() => { if (t.clientId) { const e = { client_id: t.clientId, auto_select: !0 === t.autoLogin, callback: t.callback, use_fedcm_for_prompt: !0, ...t.idConfiguration }; window.google.accounts.id.initialize(e), t.prompt && window.google.accounts.id.prompt() } })), e.component("GoogleLogin", pS) } }; const hS = [Cu, Au, Kp, Yp, Qp, Xp, ef, tf, Hh, sS, Oc((async e => { e.vueApp.use(fS, { clientId: "499694163018-r10ilqfvebms2g737ameta9ol8brh5mh.apps.googleusercontent.com" }) })), Oc((() => ({ provide: { windowWidth: Ue(window.innerWidth) } })))], mS = cr({ props: { vnode: { type: Object, required: !0 }, route: { type: Object, required: !0 }, vnodeRef: Object, renderKey: String, trackRootNodes: Boolean }, setup(e) { const t = e.renderKey, n = e.route, r = {}; for (const o in e.route) Object.defineProperty(r, o, { get: () => t === e.renderKey ? e.route[o] : n[o] }); return co(cu, xe(r)), () => Ls(e.vnode, { ref: e.vnodeRef }) } }), gS = cr({ name: "NuxtPage", inheritAttrs: !1, props: { name: { type: String }, transition: { type: [Boolean, Object], default: void 0 }, keepalive: { type: [Boolean, Object], default: void 0 }, route: { type: Object }, pageKey: { type: [Function, String], default: null } }, setup(e, { attrs: t, expose: n }) { const r = Ac(), o = Ue(), s = lo(cu, null); let i; n({ pageRef: o }); const a = lo(au, null); let c; const l = r.deferHydration(); return e.pageKey && qn((() => e.pageKey), ((e, t) => { e !== t && r.callHook("page:loading:start") })), () => Ls(ip, { name: e.name, route: e.route, ...t }, { default: t => { const n = function (e, t, n) { if (!e) return !1; const r = t.matched.findIndex((e => { var t; return (null == (t = e.components) ? void 0 : t.default) === (null == n ? void 0 : n.type) })); if (!r || -1 === r) return !1; return t.matched.slice(0, r).some(((t, n) => { var r, o, s; return (null == (r = t.components) ? void 0 : r.default) !== (null == (s = null == (o = e.matched[n]) ? void 0 : o.components) ? void 0 : s.default) })) || n && cp({ route: t, Component: n }) !== cp({ route: e, Component: n }) }(s, t.route, t.Component), u = s && s.matched.length === t.route.matched.length; if (!t.Component) return c && !u ? c : void l(); if (c && a && !a.isCurrent(t.route)) return c; if (n && s && (!a || (null == a ? void 0 : a.isCurrent(s)))) return u ? c : null; const d = cp(t, e.pageKey); r.isHydrating || function (e, t, n) { if (!e) return !1; const r = t.matched.findIndex((e => { var t; return (null == (t = e.components) ? void 0 : t.default) === (null == n ? void 0 : n.type) })); return r < t.matched.length - 1 }(s, t.route, t.Component) || i !== d || r.callHook("page:loading:end"), i = d; const p = !!(e.transition ?? t.route.meta.pageTransition ?? _u), f = p && function (e) { const t = e.map((e => ({ ...e, onAfterLeave: e.onAfterLeave ? lp(e.onAfterLeave) : void 0 }))); return Xl(...t) }([e.transition, t.route.meta.pageTransition, _u, { onAfterLeave: () => { r.callHook("page:transition:finish", t.Component) } }].filter(Boolean)), h = e.keepalive ?? t.route.meta.keepalive ?? false; return c = yp(pi, p && f, ((e, t) => ({ default: () => e ? Ls(hr, !0 === e ? {} : e, t) : t }))(h, Ls(Ln, { suspensible: !0, onPending: () => r.callHook("page:start", t.Component), onResolve: () => { rn((() => r.callHook("page:finish", t.Component).then((() => r.callHook("page:loading:end"))).finally(l))) } }, { default: () => { const e = Ls(mS, { key: d || void 0, vnode: t.Component, route: t.route, renderKey: d || void 0, trackRootNodes: p, vnodeRef: o }); return h && (e.type.name = t.Component.type.name || t.Component.type.__name || "RouteProvider"), e } }))).default(), c } }) } }); const yS = cr({ name: "LayoutLoader", inheritAttrs: !1, props: { name: String, layoutProps: Object }, async setup(e, t) { const n = await Zp[e.name]().then((e => e.default || e)); return () => Ls(n, e.layoutProps, t.slots) } }), _S = cr({ name: "NuxtLayout", inheritAttrs: !1, props: { name: { type: [String, Boolean, Object], default: null }, fallback: { type: [String, Object], default: null } }, setup(e, t) { const n = Ac(), r = lo(cu), o = r === mu() ? lo(Yd) : r, s = js((() => { let t = Ve(e.name) ?? o.meta.layout ?? "default"; return t && !(t in Zp) && e.fallback && (t = Ve(e.fallback)), t })), i = Ue(); t.expose({ layoutRef: i }); const a = n.deferHydration(); return () => { const n = s.value && s.value in Zp, r = o.meta.layoutTransition ?? false; return yp(pi, n && r, { default: () => Ls(Ln, { suspensible: !0, onResolve: () => { rn(a) } }, { default: () => Ls(vS, { layoutProps: ms(t.attrs, { ref: i }), key: s.value || void 0, name: s.value, shouldProvide: !e.name, hasTransition: !!r }, t.slots) }) }).default() } } }), vS = cr({ name: "NuxtLayoutProvider", inheritAttrs: !1, props: { name: { type: [String, Boolean] }, layoutProps: { type: Object }, hasTransition: { type: Boolean }, shouldProvide: { type: Boolean } }, setup(e, t) { const n = e.name; return e.shouldProvide && co(au, { isCurrent: e => n === (e.meta.layout ?? "default") }), () => { var r, o; return !n || "string" == typeof n && !(n in Zp) ? null == (o = (r = t.slots).default) ? void 0 : o.call(r) : Ls(yS, { key: n, layoutProps: e.layoutProps, name: n }, t.slots) } } }), bS = cr({ name: "ClientOnly", inheritAttrs: !1, props: ["fallback", "placeholder", "placeholderTag", "fallbackTag"], setup(e, { slots: t, attrs: n }) { const r = Ue(!1); return Tr((() => { r.value = !0 })), e => { var o; if (r.value) return null == (o = t.default) ? void 0 : o.call(t); const s = t.fallback || t.placeholder; if (s) return s(); const i = e.fallback || e.placeholder || ""; return Zo(e.fallbackTag || e.placeholderTag || "span", n, i) } } }); class wS { static get() { const { $axios: e } = Ac(); return e.get("/orders") } static delete(e) { const { $axios: t } = Ac(); return t.delete(`/orders/${e}`) } static getExchanges() { const { $axios: e } = Ac(); return e.get("/orders/exchange_rates") } static getUrrate() { const { $axios: e } = Ac(); return e.get("/urrate") } static getRefferals(e) { const { $axios: t } = Ac(); return e ? t.get(`/referral_transactions?page=${e}`) : t.get("/referral_transactions") } static getTransactions(e = 0) { const { $axios: t } = Ac(); return t.get("/transactions", { params: { page: e } }) } } const SS = Hp("ordersStore", { state: () => ({ list: { items: [], isFetch: !1, error: !1 }, listRefferals: { items: [], isFetch: !1, error: !1, pagination: {} }, listTransactions: { items: [], isFetch: !1, error: !1, pagination: {} }, recentOrder: null, exchanges: { kzt: "5" }, urrate: null, isUSDTopup: !1, sum: 0 }), actions: { getList() { return this.setFetch(!0), wS.get().then((({ data: e }) => { this.setList(e) })).catch((e => { console.error("error", e) })).finally((() => { this.setFetch(!1) })) }, getListRefferals(e) { return this.setFetchRefferal(!0), wS.getRefferals(e ?? null).then((({ data: e }) => { this.setListRefferals(e), this.setPaginationRefferals(e) })).catch((e => { console.error("error", e) })).finally((() => { this.setFetchRefferal(!1) })) }, getTransactions() { var e; return this.setFetchTransactions(!0), wS.getTransactions((null == (e = this.listTransactions.pagination) ? void 0 : e.current_page) + 1).then((({ data: e }) => { this.setListTransactions(e), this.setPaginationListTransactions(e) })).catch((e => { console.error("error", e) })).finally((() => { this.setFetchTransactions(!1) })) }, getExchanges() { return this.setFetch(!0), wS.getExchanges().then((({ data: e }) => { this.setExchanges(e) })).catch((e => { console.error("error", e) })).finally((() => { this.setFetch(!1) })) }, getUrrate() { return this.setFetch(!0), wS.getUrrate().then((({ data: e }) => { this.setUrrate(e); const t = new CustomEvent("urrate-get"); window.dispatchEvent(t) })).catch((e => { console.error("error", e) })).finally((() => { this.setFetch(!1) })) }, setFetch(e) { this.list.isFetch = e }, setPaginationRefferals({ meta: e }) { this.listRefferals.pagination = e }, setPaginationListTransactions({ meta: e }) { this.listTransactions.pagination = e }, setList({ data: e }) { this.list.items = e }, setListRefferals({ data: e }) { this.listRefferals.items = e }, setListTransactions({ data: e }) { window.scrollBy(0, -50), this.listTransactions.items = [...this.listTransactions.items, ...e] }, setSum(e) { this.sum = e }, setExchanges(e) { this.exchanges = e }, setUrrate(e) { this.urrate = null == e ? void 0 : e.rate }, setFetchRefferal(e) { this.listRefferals.isFetch = e }, setFetchTransactions(e) { this.listTransactions.isFetch = e }, setRecentOrder(e) { this.recentOrder = e } } }), kS = e => { const t = decodeURIComponent(document.cookie).split("; "); for (const n of t) { const [t, r] = n.split("="); if (t === e) return r } return null }; class ES { static register(e) { const { $axios: t } = Ac(); return t.post("/auth/register", { email: e }) } static restore(e) { const { $axios: t } = Ac(); return t.post("/auth/restore_password", { email: e }) } static login(e) { const { $axios: t } = Ac(); return t.post("/auth/login", e) } static checkSub() { const { $axios: e } = Ac(); return e.post("/bonuses/check_vk_sub") } static loginGoogle(e) { const { $axios: t } = Ac(); return t.get(`/auth/oauth/callback/google?code=${e}`) } static loginTelegram(e, t, n, r = !1) { const { $axios: o } = Ac(), s = kS("linkHash"); let i = Object.assign({}, e, { uuid: t, source: n, referral_hash: s }); return r && (i = Object.assign({}, i, { force_reassign: 1 })), o.get("/auth/oauth/callback/telegram", { params: i }) } static loginVK(e, t, n = !1) { const { $axios: r } = Ac(); let o = `/auth/oauth/callback/vkontakte?code=${e}&redirect_url=${localStorage.getItem("vk-redirect-url")}&uuid=${t}&referral_hash=${kS("linkHash")}`; return n && (o = o.concat("&force_reassign=1")), r.get(o) } static getUser() { const { $axios: e } = Ac(); return e.post("/auth/me") } static getDisasterSettings() { const { $axios: e } = Ac(); return e.get("domain/settings/disaster") } } let TS = { status: { loggedIn: !1 }, user: null }; TS.user = (null == (e = JSON.parse(localStorage.getItem("user"))) ? void 0 : e.data) || null; const xS = Hp("authStore", { state: () => ({ ...TS, tgLoginSource: "default", loading: !1, dublicate: !1, dublicateData: null, ymClientId: "", paymentOff: !1, paymentGamesOff: !1, workingBetterOn: !1, technicalWorksHeader: !1, technicalWorksHeaderGifts: !1, technicalWorksHeaderSkins: !1, isDisableParticipation: !1, loadingDisaster: !1 }), actions: { setLoading(e) { this.loading = e }, async register(e) { return this.setLoading(!0), ES.register(e).then((() => !0)).catch((e => (console.error(e), !1))).finally((() => { this.setLoading(!1) })) }, async restore(e) { return this.setLoading(!0), ES.restore(e).then((() => !0)).catch((e => (console.error(e), !1))).finally((() => { this.setLoading(!1) })) }, async login(e) { return this.setLoading(!0), ES.login(e).then((({ data: e }) => (localStorage.setItem("access_token", JSON.stringify(e.access_token)), this.getUser(!0), !0))).catch((e => (console.error(e), !1))).finally((() => { this.setLoading(!1) })) }, async loginGoogle(e) { return this.setLoading(!0), ES.loginGoogle(e).then((({ data: e }) => { localStorage.setItem("access_token", JSON.stringify(e.access_token)), this.getUser(!0) })).catch((e => { console.error(e) })).finally((() => { this.setLoading(!1) })) }, checkSub: async () => ES.checkSub().then((({ data: e }) => e)), goldAuth() { if (localStorage.getItem("IS_GOLD_AUTH") && localStorage.getItem("access_token")) { let e = document.createElement("a"); document.body.appendChild(e), e.style = "display: none", e.href = `${JSON.parse(localStorage.getItem("IS_GOLD_AUTH"))}?token=${JSON.parse(localStorage.getItem("access_token"))}`, localStorage.removeItem("IS_GOLD_AUTH"), e.click(), document.body.removeChild(e) } }, async loginVK(e = null) { this.setLoading(!0); const t = Bp(), n = SS().recentOrder ?? null, r = e ?? this.dublicateData.code; return ES.loginVK(r, n, !e).then((async ({ data: e }) => { var n; localStorage.setItem("access_token", JSON.stringify(e.access_token)), this.goldAuth(), await this.getUser(!0), !1 === (null == (n = this.user) ? void 0 : n.vk_sub) && await t.openModalQuery({ name: "modal-vk-sub" }), window.location.href.includes("view=login-coin") && await t.closeModalQuery() })).catch((n => { console.error(n), "o_auth_account_another_user" === Object.keys(n.data.errors)[0] && (this.setDuplicate(!0), this.setDuplicateData({ type: "vk", code: e, money: n.data.errors.o_auth_account_another_user[0].cashback_amount ?? 0 }), t.openModalQuery({ name: "duplicate" })) })).finally((() => { this.setLoading(!1) })) }, async loginTelegram(e = null) { this.setLoading(!0); const t = mu(), n = Bp(), r = SS().recentOrder ?? null, o = e ?? this.dublicateData.code; return ES.loginTelegram(o, r, this.tgLoginSource, !e).then((({ data: e }) => { setTimeout((() => { n.closeModalQuery() }), 300), "/telegram" === t.path ? n.closeModal() : n.closeModal(!1), localStorage.setItem("access_token", JSON.stringify(e.access_token)), this.goldAuth(), this.getUser(!0) })).catch((t => { console.error(t), "o_auth_account_another_user" === Object.keys(t.data.errors)[0] && (this.setDuplicate(!0), this.setDuplicateData({ type: "tg", code: e, money: t.data.errors.o_auth_account_another_user[0].cashback_amount ?? 0 }), n.openModalQuery({ name: "duplicate" })) })).finally((() => { this.setLoading(!1) })) }, async getUser(e = !1) { this.setLoading(!0); const t = Bp(); return ES.getUser().then((({ data: n }) => { n || alert("дынных о юзере нет"), localStorage.setItem("user", JSON.stringify(n)), this.setUserMe(n), e && t.closeModal(!1) })).catch((e => { this.logout(), console.error(e) })).finally((() => { this.setLoading(!1), this.setYmClientId() })) }, async getDisasterSettings(e = !1) { return this.loadingDisaster = !0, ES.getDisasterSettings().then((({ data: e }) => { const { disaster_mode: t } = e; t.wallet && (this.paymentOff = !0), t.gifts && (this.paymentOffGifts = !0), t.delivery_wallet && (this.technicalWorksHeader = !0), t.delivery_gift && (this.technicalWorksHeaderGifts = !0) })).catch((e => { this.loadingDisaster = !1 })).finally((() => { this.loadingDisaster = !1 })) }, setUserMe({ data: e }) { this.user = e, this.status.loggedIn = !0 }, setTgLoginSource(e) { this.tgLoginSource = e }, setYmClientId() { try { ym(89954502, "getClientID", (e => this.ymClientId = e)) } catch { let e = function () { ym(89954502, "getClientID", (e => this.ymClientId = e)), window.removeEventListener("yMetrikaLoaded", e) }; window.addEventListener("yMetrikaLoaded", e) } }, setDuplicate(e) { this.dublicate = e }, async logout() { const e = mu(), t = hu(); this.user = null, this.status = { loggedIn: !1 }, this.dublicate = !1, localStorage.removeItem("user"), localStorage.removeItem("access_token"), "/" !== e.path && -1 === Vp.findIndex((t => e.path.includes(t))) && await t.push("/") }, setDuplicateData(e) { this.dublicateData = e } } }); class CS { static getPlatforms() { const { $axios: e } = Ac(); return e.get("/platforms") } static getPlatform(e) { const { $axios: t } = Ac(); return t.get(`/platforms/${e}`) } static getProduct(e) { const { $axios: t } = Ac(); return t.get(`/platforms/${e}/products/0`) } } const OS = Hp("platformsStore", { state: () => ({ list: { items: [], isFetch: !1, error: !1 }, isFetch: !1, platformId: 2, platformData: null, productId: 2, sum: 0, currentTabMainPage: 1, productIdSkins: 17347, currentFaq: 3, kupicoinDiscountEnable: !1, discount: null, priceInGold: null }), actions: { async getPlatforms() { const e = mu(); return this.setFetch(!0), CS.getPlatforms().then((({ data: { data: t } }) => { var n; this.setList(t); const r = "context" === localStorage.getItem("SiteRole") || "context-2" === localStorage.getItem("SiteRole"), o = r ? "6" : "3", s = "/kzt" === e.path ? o : null, i = localStorage.getItem("platform-id"), a = r ? "5" : "2"; this.setPlatformID(s ?? a ?? i ?? (null == (n = t[0]) ? void 0 : n.id)) })).catch((e => { console.error("error", e) })).finally((() => { this.setFetch(!1) })) }, async changeCurrentTab(e) { this.setCurrentTab(e) }, async getPlatform() { return this.setFetch(!0), CS.getPlatform(this.platformId).then((async ({ data: { data: e } }) => { this.setPlatformData(e), await this.getProduct() })).catch((e => { console.error("error", e) })).finally((() => { this.setFetch(!1) })) }, async getProduct() { return console.log("getProduct"), this.setFetch(!0), CS.getProduct(this.platformId).then((({ data: { data: e } }) => { console.log("getProduct", e[0]), this.setProductId(e) })).catch((e => { console.error("error", e) })).finally((() => { this.setFetch(!1) })) }, async setPlatformID(e) { this.setPlatformId(e), await this.getPlatform() }, async setPlatformName(e) { const t = this.list.items.find((t => t.name === e)); t && await this.setPlatformID(t.id) }, setFetch(e) { this.isFetch = e }, setCurrentFaq(e) { this.currentFaq = e }, setSum(e) { this.sum = e }, setDiscount(e = { mode: !1, discount: null, price: null }) { console.log("payload in dispatch", e), this.kupicoinDiscountEnable = e.mode, this.discount = e.discount, this.priceInGold = e.price }, setList(e) { this.list.items = e }, setPlatformId(e) { this.platformId = e, localStorage.setItem("platform-id", e) }, setProductIdSkins(e) { this.productIdSkins = e }, setPlatformData(e) { this.platformData = e }, setProductId(e) { console.log("setProductId, payload:", e), this.productId = e[0].id }, setCurrentTab(e) { this.currentTabMainPage = e } } }); class AS { static getList(e) { const { $axios: t } = Ac(); return t.get("/games", { params: e }) } static getGame(e) { const { $axios: t } = Ac(); return t.get(`/product_by_slug/${e}`) } static getSimilarGames(e, t) { if (!e) return; const { $axios: n } = Ac(); return n.get(`/related_games/${e}`, { params: { sort: t } }) } static getDlcGames(e, t = 0) { if (!e) return; const { $axios: n } = Ac(); return n.get(`/dlc_games/${e}`, { params: { page: t } }) } static getGameById(e) { const { $axios: t } = Ac(); return t.get(`/products/${e}`) } static getCalculate(e, t = "") { var n; const { $axios: r } = Ac(), o = $S(); console.log("getCaculate", o); const s = null == (n = o.currentPackage) ? void 0 : n.package_id; return r.get("/orders/calculate", { params: { product_id: s, quantity: "1", promocode: e, account: t } }) } static buyGame(e, t, n, r, o = !1) { const { $axios: s } = Ac(), i = xS(), a = i.status.loggedIn, c = i.ymClientId, l = kS("linkHash"); return s.post(a ? "/orders" : "/orders/public", { product_id: t, account: e, quantity: "1", region: r, promocode: n, ym_client_id: c ?? null, referral_hash: l, pay_with_gold: o }) } } var RS; ((e, n, r) => { n in e ? t(e, n, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[n] = r })(AS, "symbol" != typeof (RS = "steam_link") ? RS + "" : RS, "https://steam.kupikod.com"); const IS = () => (e, t = !1) => { const n = document.createElement("a"); document.body.appendChild(n), n.style.display = "none", n.href = e, n.target = t ? "_blank" : "_self", n.click(), document.body.removeChild(n) }, $S = Hp("gamesStore", { state: () => ({ list: { items: [], pagination: {}, isFetch: !1, error: !1 }, inputList: { items: [], isFetch: !1, error: !1 }, game: { item: null, isFetch: !1, error: !1 }, edition: { item: null, list: [] }, similarGames: { item: null, items: [] }, dlcGames: { items: [], pagination: {}, isFetch: !1 }, code: { value: "", status: "Неверный промокод", isFetch: !1, error: !1 }, steamLink: { value: "", error: !1 }, agreement: { value: !1, error: !1 }, payment: { isFetch: !1, error: !1 }, userRegion: null, userCurrency: null, regions: ["ru", "az", "am", "by", "gr", "kz", "kg", "md", "tj", "tm", "uz", "ua"], regionData: { ru: { region: "ru", currency: "rub", name: "Россия" }, az: { region: "az", currency: "unknown", name: "Азербайджан" }, am: { region: "am", currency: "unknown", name: "Армения" }, by: { region: "by", currency: "unknown", name: "Беларусь" }, gr: { region: "gr", currency: "unknown", name: "Грузия" }, kz: { region: "kz", currency: "kzt", name: "Казахстан" }, kg: { region: "kg", currency: "unknown", name: "Кыргызстан" }, md: { region: "md", currency: "unknown", name: "Молдова" }, tj: { region: "tj", currency: "unknown", name: "Таджикистан" }, tm: { region: "tm", currency: "unknown", name: "Туркменистан" }, uz: { region: "uz", currency: "unknown", name: "Узбекистан" }, ua: { region: "ua", currency: "uah", name: "Украина" } }, sum: { isFetch: !1, price: 0, discount: null, cashback: 0, oldPrice: null }, goldApplyLink: null, isModalGoldOpened: !1 }), actions: { getList(e) { return "input" === e.type ? this.setFetch({ name: "inputList", status: !0 }) : this.setFetch({ name: "list", status: !0 }), AS.getList(e.filters).then((({ data: t }) => { this.setList({ type: e.type, data: t }) })).catch((e => { console.error("error", e) })).finally((() => { "input" === e.type ? this.setFetch({ name: "inputList", status: !1 }) : this.setFetch({ name: "list", status: !1 }) })) }, getGame(e) { const t = hu(); return this.setFetch({ name: "game", status: !0 }), AS.getGame(e).then((({ data: e }) => { this.setGame(e), this.applyCalculate(), this.setEdition(), this.setEditions() })).catch((async e => { console.error("error", e), await t.replace("/ru-ru/games") })).finally((() => { this.setFetch({ name: "game", status: !1 }) })) }, getGameById(e) { return this.setFetch({ name: "game", status: !0 }), AS.getGameById(e).then((({ data: e }) => { this.setGame(e), this.applyCalculate(), this.setEdition() })).catch((e => { console.error("error", e) })).finally((() => { this.setFetch({ name: "game", status: !1 }) })) }, applyCalculate() { var e, t; const n = OS(), r = IS(); if (this.setFetch({ name: "sum", status: !1 }), (null == (t = null == (e = this.game) ? void 0 : e.item) ? void 0 : t.game.available_packages) || r("/ru-ru/games"), this.currentPackage) return AS.getCalculate(this.code.value, this.steamLink.value).then((({ data: { data: e } }) => { var t, r, o, s, i, a, c; this.setSum({ newPrice: e.amount, cashback: e.cashback, basePrice: this.currentPackage.price }), this.setError({ name: "code", status: !1 }), n.setDiscount((null == (r = null == (t = e.options) ? void 0 : t.discount_in_gold) ? void 0 : r.discount) ? { mode: !0, discount: null == (i = null == (s = null == (o = e.options) ? void 0 : o.discount_in_gold) ? void 0 : s.discount) ? void 0 : i.value, price: Math.ceil(null == (c = null == (a = e.options) ? void 0 : a.discount_in_gold) ? void 0 : c.price_in_gold) } : { mode: !1, discount: null, price: Math.ceil(e.amount) }) })).catch((e => { this.setSum({ basePrice: this.currentPackage.price }), this.setError({ name: "code", status: !0 }), console.error("error", e) })).finally((() => { this.setFetch({ name: "sum", status: !1 }) })) }, getSimilarGames(e) { return AS.getSimilarGames(e, !0).then((({ data: { data: e } }) => { this.setSimilarGames(e) })).catch((e => console.log(e))) }, getDlcGames(e) { var t; return this.setFetchDlc(!0), AS.getDlcGames(e, ((null == (t = this.dlcGames.pagination) ? void 0 : t.current_page) ?? 0) + 1).then((({ data: e }) => { this.setDlcGames(e) })).catch((e => console.log(e))).finally((() => { this.setFetchDlc(!1) })) }, async changeGameEdition(e) { const t = hu(); "games" === e.locationFrom ? (localStorage.setItem("pr-t", "true"), await t.replace(`/ru-ru/games/${e.edition.slug}`)) : "status" === e.locationFrom && (localStorage.setItem("pr-t", "true"), await t.replace(`/ru-ru/order-status-game/${e.edition.slug}`)), this.getGame(e.edition.slug) }, checkData() { return this.checkSteamLink(), !this.steamLink.error && (!!this.agreement.value || (this.setError({ name: "agreement", status: !0 }), !1)) }, async buyGame(e = { payWithGold: !1 }) { var t; this.setFetch({ name: "payment", status: !0 }); const n = IS(), r = this.checkData(); try { ym(89954502, "reachGoal", "buy-game-btn-clicked") } catch { } if (r) { try { const { data: { data: r } } = await AS.buyGame(this.steamLink.value, this.currentPackage.package_id, this.code.value, this.userRegion, e.payWithGold); if (e.payWithGold) return this.openModal(r.transaction.link), void this.setFetch({ name: "payment", status: !1 }); const o = e.payWithGold ? `/order-status-game?uuid=${r.uuid}` : null == (t = r.transaction) ? void 0 : t.link, s = /iPhone/.test(navigator.userAgent) || !1; if (o.includes("palych") && !s) return n(o, !0), void n(`${window.location.origin}/order-status-game?uuid=${r.uuid}`); n(o) } catch { return this.setError({ name: "payment", status: !0 }), this.setFetch({ name: "payment", status: !1 }), !1 } this.setFetch({ name: "payment", status: !1 }) } else this.setFetch({ name: "payment", status: !1 }) }, setRegion(e) { this.setUserRegion(e), this.setCurrency(e), this.game.item && this.applyCalculate() }, setFetch(e) { this[e.name].isFetch = e.status }, setList({ type: e, data: t }) { "input" === e ? this.inputList.items = t.data : "filter" === e ? (this.list.items = t.data, this.list.pagination = t.meta) : (window.scrollBy(0, -50), this.list.items = [...this.list.items, ...t.data], this.list.pagination = t.meta) }, setError(e) { this[e.name].error = e.status }, setGame({ data: e }) { this.game.item = e }, setSimilarGames(e) { this.similarGames.items = e }, setDlcGames(e) { this.dlcGames.items = [...this.dlcGames.items, ...e.data], this.dlcGames.pagination = e.meta }, setFetchDlc(e) { this.dlcGames.isFetch = e }, setEdition() { var e, t, n, r; this.edition.item = (null == (t = null == (e = this.game) ? void 0 : e.item) ? void 0 : t.game.editions.find((e => { var t, n; return e.slug === (null == (n = null == (t = this.game) ? void 0 : t.item) ? void 0 : n.slug) }))) ?? (null == (r = null == (n = this.game) ? void 0 : n.item) ? void 0 : r.game.editions[0]) }, setEditions() { var e, t; this.edition.list = null == (t = null == (e = this.game) ? void 0 : e.item) ? void 0 : t.game.editions }, setSum(e = null, t = null, n = null) { e ? (this.sum.oldPrice = this.game.item.price, this.sum.price = e.newPrice, this.sum.cashback = e.cashback, this.sum.discount = Number(this.game.item.price) - Number(e.newPrice)) : (this.sum.oldPrice = null, this.sum.price = n ?? 0, this.sum.cashback = this.game.item.cashback, this.sum.discount = null) }, setUserRegion(e) { this.userRegion = e }, setCurrency(e) { this.userCurrency = this.regionData[e].currency }, getUserCurrencyByCountry() { const e = localStorage.getItem("selected_account_region") ?? "ru"; return "unknown" === this.regionData[e].currency ? "cis" : this.regionData[e].currency }, updateSteamLink(e) { this.steamLink.value = e, this.steamLink.error = !1 }, updateAgreement(e) { this.agreement.value = e, this.agreement.error = !1 }, updateCodeLink(e) { this.code.value = e, this.code.error = !1 }, checkSteamLink() { if (null == this.steamLink.value || !this.steamLink.value.length) return this.steamLink.error = !0, !1; if (null == this.steamLink.value.match(/(?:https?:\/\/)?steamcommunity\.com\/(?:profiles|id)\/[^\/]+/g)) return this.steamLink.error = !0, !1; { this.steamLink.error = !1; const e = this.steamLink.value.match(/(?:https?:\/\/)?steamcommunity\.com\/(?:profiles|id)\/[^\/]+/g)[0]; return this.steamLink.value = e, this.steamLink.error = !1, localStorage.setItem("user-steam-link", e), !0 } }, updateRegion(e) { this.userRegion = e }, openModal(e) { this.isModalGoldOpened = !0, this.goldApplyLink = e }, closeModal() { this.isModalGoldOpened = !1, this.goldApplyLink = null } }, getters: { currentPackage: e => { var t, n, r, o, s, i, a, c, l, u, d, p; if (!(null == (t = e.game.item) ? void 0 : t.slug)) return !1; if (!e.userRegion) { const t = Object.values(e.game.item.game.available_packages)[0]; return "object" == typeof t ? t : t.find((t => t.slug === e.game.item.slug)) } return Object.values(null == (r = null == (n = e.game) ? void 0 : n.item) ? void 0 : r.game.available_packages)[0][0] ? !!(null == (l = null == (a = e.game) ? void 0 : a.item) ? void 0 : l.game.available_packages[null == (c = e.userRegion) ? void 0 : c.toUpperCase()]) && (null == (p = null == (u = e.game) ? void 0 : u.item) ? void 0 : p.game.available_packages[null == (d = e.userRegion) ? void 0 : d.toUpperCase()].find((t => { var n; return t.slug === (null == (n = e.game.item) ? void 0 : n.slug) }))) : null == (i = null == (o = e.game) ? void 0 : o.item) ? void 0 : i.game.available_packages[null == (s = e.userRegion) ? void 0 : s.toUpperCase()] } } }), PS = [{ name: "kzt", weight: "0" }, { name: "context", weight: "0" }, { name: "context-2", weight: "0" }]; const jS = Hp("versionsStore", { state: () => ({ list: { items: [{ name: "default", weight: 100 - PS.reduce(((e, t) => e + Number(t.weight)), 0) }].concat(PS) }, version: null }), actions: { setVersion() { const e = this.list.items.map((e => e.name)), t = localStorage.getItem("SiteRole") ?? null, n = localStorage.getItem("RoleTime") ?? null, r = !n || Math.floor((Date.now() - parseInt(n)) / 864e5) > 0; t && e.includes(t) && !r ? this.version = t : (this.version = function (e) { const t = [...e].sort((function (e, t) { return e.weight - t.weight })), n = e.reduce(((e, t) => e + Number(t.weight)), 0); let r = 0; const o = t.map(((e, t) => { if (!t) return r += Number(e.weight), Object.assign({}, e, { start: 0, end: Number(e.weight) }); const n = Object.assign({}, e, { start: Number(r), end: Number(r) + Number(e.weight) }); return r += Number(e.weight), n })); let s = Math.random() * n; for (let i = 0; i < o.length; i++) { if (0 === i && 0 <= s && s < o[i].end) return o[i].name; if (o[i].start < s && s <= o[i].end) return o[i].name } }(this.list.items), localStorage.setItem("SiteRole", this.version), localStorage.setItem("RoleTime", Date.now().toString())); try { ym(89954502, "userParams", { param1: this.version }), console.log("rol s") } catch { let e = function () { ym(89954502, "userParams", { param1: this.version }), window.removeEventListener("yMetrikaLoaded", e), console.log("rol s") }; window.addEventListener("yMetrikaLoaded", e) } return this.version } } }); var LS = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function DS(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var NS = { exports: {} }; const MS = DS(NS.exports = function () { var e = 1e3, t = 6e4, n = 36e5, r = "millisecond", o = "second", s = "minute", i = "hour", a = "day", c = "week", l = "month", u = "quarter", d = "year", p = "date", f = "Invalid Date", h = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, m = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, g = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function (e) { var t = ["th", "st", "nd", "rd"], n = e % 100; return "[" + e + (t[(n - 20) % 10] || t[n] || t[0]) + "]" } }, y = function (e, t, n) { var r = String(e); return !r || r.length >= t ? e : "" + Array(t + 1 - r.length).join(n) + e }, _ = { s: y, z: function (e) { var t = -e.utcOffset(), n = Math.abs(t), r = Math.floor(n / 60), o = n % 60; return (t <= 0 ? "+" : "-") + y(r, 2, "0") + ":" + y(o, 2, "0") }, m: function e(t, n) { if (t.date() < n.date()) return -e(n, t); var r = 12 * (n.year() - t.year()) + (n.month() - t.month()), o = t.clone().add(r, l), s = n - o < 0, i = t.clone().add(r + (s ? -1 : 1), l); return +(-(r + (n - o) / (s ? o - i : i - o)) || 0) }, a: function (e) { return e < 0 ? Math.ceil(e) || 0 : Math.floor(e) }, p: function (e) { return { M: l, y: d, w: c, d: a, D: p, h: i, m: s, s: o, ms: r, Q: u }[e] || String(e || "").toLowerCase().replace(/s$/, "") }, u: function (e) { return void 0 === e } }, v = "en", b = {}; b[v] = g; var w = "$isDayjsObject", S = function (e) { return e instanceof x || !(!e || !e[w]) }, k = function e(t, n, r) { var o; if (!t) return v; if ("string" == typeof t) { var s = t.toLowerCase(); b[s] && (o = s), n && (b[s] = n, o = s); var i = t.split("-"); if (!o && i.length > 1) return e(i[0]) } else { var a = t.name; b[a] = t, o = a } return !r && o && (v = o), o || !r && v }, E = function (e, t) { if (S(e)) return e.clone(); var n = "object" == typeof t ? t : {}; return n.date = e, n.args = arguments, new x(n) }, T = _; T.l = k, T.i = S, T.w = function (e, t) { return E(e, { locale: t.$L, utc: t.$u, x: t.$x, $offset: t.$offset }) }; var x = function () { function g(e) { this.$L = k(e.locale, null, !0), this.parse(e), this.$x = this.$x || e.x || {}, this[w] = !0 } var y = g.prototype; return y.parse = function (e) { this.$d = function (e) { var t = e.date, n = e.utc; if (null === t) return new Date(NaN); if (T.u(t)) return new Date; if (t instanceof Date) return new Date(t); if ("string" == typeof t && !/Z$/i.test(t)) { var r = t.match(h); if (r) { var o = r[2] - 1 || 0, s = (r[7] || "0").substring(0, 3); return n ? new Date(Date.UTC(r[1], o, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], o, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s) } } return new Date(t) }(e), this.init() }, y.init = function () { var e = this.$d; this.$y = e.getFullYear(), this.$M = e.getMonth(), this.$D = e.getDate(), this.$W = e.getDay(), this.$H = e.getHours(), this.$m = e.getMinutes(), this.$s = e.getSeconds(), this.$ms = e.getMilliseconds() }, y.$utils = function () { return T }, y.isValid = function () { return !(this.$d.toString() === f) }, y.isSame = function (e, t) { var n = E(e); return this.startOf(t) <= n && n <= this.endOf(t) }, y.isAfter = function (e, t) { return E(e) < this.startOf(t) }, y.isBefore = function (e, t) { return this.endOf(t) < E(e) }, y.$g = function (e, t, n) { return T.u(e) ? this[t] : this.set(n, e) }, y.unix = function () { return Math.floor(this.valueOf() / 1e3) }, y.valueOf = function () { return this.$d.getTime() }, y.startOf = function (e, t) { var n = this, r = !!T.u(t) || t, u = T.p(e), f = function (e, t) { var o = T.w(n.$u ? Date.UTC(n.$y, t, e) : new Date(n.$y, t, e), n); return r ? o : o.endOf(a) }, h = function (e, t) { return T.w(n.toDate()[e].apply(n.toDate("s"), (r ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(t)), n) }, m = this.$W, g = this.$M, y = this.$D, _ = "set" + (this.$u ? "UTC" : ""); switch (u) { case d: return r ? f(1, 0) : f(31, 11); case l: return r ? f(1, g) : f(0, g + 1); case c: var v = this.$locale().weekStart || 0, b = (m < v ? m + 7 : m) - v; return f(r ? y - b : y + (6 - b), g); case a: case p: return h(_ + "Hours", 0); case i: return h(_ + "Minutes", 1); case s: return h(_ + "Seconds", 2); case o: return h(_ + "Milliseconds", 3); default: return this.clone() } }, y.endOf = function (e) { return this.startOf(e, !1) }, y.$set = function (e, t) { var n, c = T.p(e), u = "set" + (this.$u ? "UTC" : ""), f = (n = {}, n[a] = u + "Date", n[p] = u + "Date", n[l] = u + "Month", n[d] = u + "FullYear", n[i] = u + "Hours", n[s] = u + "Minutes", n[o] = u + "Seconds", n[r] = u + "Milliseconds", n)[c], h = c === a ? this.$D + (t - this.$W) : t; if (c === l || c === d) { var m = this.clone().set(p, 1); m.$d[f](h), m.init(), this.$d = m.set(p, Math.min(this.$D, m.daysInMonth())).$d } else f && this.$d[f](h); return this.init(), this }, y.set = function (e, t) { return this.clone().$set(e, t) }, y.get = function (e) { return this[T.p(e)]() }, y.add = function (r, u) { var p, f = this; r = Number(r); var h = T.p(u), m = function (e) { var t = E(f); return T.w(t.date(t.date() + Math.round(e * r)), f) }; if (h === l) return this.set(l, this.$M + r); if (h === d) return this.set(d, this.$y + r); if (h === a) return m(1); if (h === c) return m(7); var g = (p = {}, p[s] = t, p[i] = n, p[o] = e, p)[h] || 1, y = this.$d.getTime() + r * g; return T.w(y, this) }, y.subtract = function (e, t) { return this.add(-1 * e, t) }, y.format = function (e) { var t = this, n = this.$locale(); if (!this.isValid()) return n.invalidDate || f; var r = e || "YYYY-MM-DDTHH:mm:ssZ", o = T.z(this), s = this.$H, i = this.$m, a = this.$M, c = n.weekdays, l = n.months, u = n.meridiem, d = function (e, n, o, s) { return e && (e[n] || e(t, r)) || o[n].slice(0, s) }, p = function (e) { return T.s(s % 12 || 12, e, "0") }, h = u || function (e, t, n) { var r = e < 12 ? "AM" : "PM"; return n ? r.toLowerCase() : r }; return r.replace(m, (function (e, r) { return r || function (e) { switch (e) { case "YY": return String(t.$y).slice(-2); case "YYYY": return T.s(t.$y, 4, "0"); case "M": return a + 1; case "MM": return T.s(a + 1, 2, "0"); case "MMM": return d(n.monthsShort, a, l, 3); case "MMMM": return d(l, a); case "D": return t.$D; case "DD": return T.s(t.$D, 2, "0"); case "d": return String(t.$W); case "dd": return d(n.weekdaysMin, t.$W, c, 2); case "ddd": return d(n.weekdaysShort, t.$W, c, 3); case "dddd": return c[t.$W]; case "H": return String(s); case "HH": return T.s(s, 2, "0"); case "h": return p(1); case "hh": return p(2); case "a": return h(s, i, !0); case "A": return h(s, i, !1); case "m": return String(i); case "mm": return T.s(i, 2, "0"); case "s": return String(t.$s); case "ss": return T.s(t.$s, 2, "0"); case "SSS": return T.s(t.$ms, 3, "0"); case "Z": return o }return null }(e) || o.replace(":", "") })) }, y.utcOffset = function () { return 15 * -Math.round(this.$d.getTimezoneOffset() / 15) }, y.diff = function (r, p, f) { var h, m = this, g = T.p(p), y = E(r), _ = (y.utcOffset() - this.utcOffset()) * t, v = this - y, b = function () { return T.m(m, y) }; switch (g) { case d: h = b() / 12; break; case l: h = b(); break; case u: h = b() / 3; break; case c: h = (v - _) / 6048e5; break; case a: h = (v - _) / 864e5; break; case i: h = v / n; break; case s: h = v / t; break; case o: h = v / e; break; default: h = v }return f ? h : T.a(h) }, y.daysInMonth = function () { return this.endOf(l).$D }, y.$locale = function () { return b[this.$L] }, y.locale = function (e, t) { if (!e) return this.$L; var n = this.clone(), r = k(e, t, !0); return r && (n.$L = r), n }, y.clone = function () { return T.w(this.$d, this) }, y.toDate = function () { return new Date(this.valueOf()) }, y.toJSON = function () { return this.isValid() ? this.toISOString() : null }, y.toISOString = function () { return this.$d.toISOString() }, y.toString = function () { return this.$d.toUTCString() }, g }(), C = x.prototype; return E.prototype = C, [["$ms", r], ["$s", o], ["$m", s], ["$H", i], ["$W", a], ["$M", l], ["$y", d], ["$D", p]].forEach((function (e) { C[e[1]] = function (t) { return this.$g(t, e[0], e[1]) } })), E.extend = function (e, t) { return e.$i || (e(t, x, E), e.$i = !0), E }, E.locale = k, E.isDayjs = S, E.unix = function (e) { return E(1e3 * e) }, E.en = b[v], E.Ls = b, E.p = {}, E }()), FS = cr({ __name: "app", setup(e) { const { $windowWidth: t } = Ac(), n = mu(), r = xS(), o = Bp(), s = $S(), i = SS(), a = jS(), c = ur((() => jc((() => import("./ModalSearch.Cf2pKKm_.js")), __vite__mapDeps([116, 33, 35]), import.meta.url))), l = ur((() => jc((() => import("./TheWidget.Ddb6fdTK.js")), __vite__mapDeps([117, 13, 107, 55, 56, 108, 43, 44, 45, 6, 7, 8, 9, 118, 99, 22, 23, 24, 25, 30, 59, 82, 119]), import.meta.url))), u = ["/preland", "/parse-steam-review", "/service", "/order-status-plati"].includes(n.path), d = n.fullPath.replace("/?", "").split("&").reduce((function (e, t) { const n = t.split("="); return e[decodeURIComponent(n[0])] = decodeURIComponent(n[1]), e }), {}); return Jl({ link: [{ rel: "canonical", href: "https://steam.kupikod.com" + n.path.trim().replace(/\/+$/, "") }] }), Tr((() => { var e; if (r.getUser(), r.getDisasterSettings(), "yandex" === d.utm_source && (localStorage.setItem("SiteRole", "context"), localStorage.setItem("RoleTime", Date.now().toString())), "yad" === d.utm_source && (localStorage.setItem("SiteRole", "context-2"), localStorage.setItem("RoleTime", Date.now().toString())), d.sl && localStorage.setItem("selected_account_region", d.sl), d.kfrom === kS("linkHash")) { const e = new Date((new Date).getTime() + 7776e6).toUTCString(); document.cookie = `linkHash=${d.kfrom}; expires=${e}; path=/;` } if (d.kfrom && !kS("linkHash") && d.kfrom !== (null == (e = r.user) ? void 0 : e.referral_hash)) { const e = new Date((new Date).getTime() + 7776e6).toUTCString(); document.cookie = `linkHash=${d.kfrom}; expires=${e}; path=/;` } const c = localStorage.getItem("selected_account_region"); if (c && s.regions.includes(c) ? s.setRegion(localStorage.getItem("selected_account_region")) : localStorage.removeItem("selected_account_region"), a.setVersion(), i.getExchanges(), i.getUrrate(), window.addEventListener("telegram-login", (e => { r.loginTelegram(e.detail) })), d.code && r.loginVK(d.code), d.view) o.openModalQuery({ name: d.view, noQuery: !0 }); else { const e = localStorage.getItem("popunder-viewed"), t = localStorage.getItem("popunder-timestamp"); if (e || "/service" === n.path || "/order-status-plati" === n.path || r.isDisableParticipation || setTimeout((() => { o.openModalQuery({ name: "popunder", noQuery: !0 }) }), 2e3), t) { MS(JSON.parse(t)).diff(new Date, "day", !1) <= -3 && (localStorage.removeItem("popunder-viewed"), setTimeout((() => { o.openModalQuery({ name: "popunder", noQuery: !0 }) }), 2e3)) } } window.addEventListener("resize", (() => { t.value = window.innerWidth })) })), (e, t) => { const n = gS, r = _S, o = bS; return Jo(), Zo(Bo, null, [Ve(u) ? ds("", !0) : (Jo(), es(r, { key: 0, name: "main" }, { default: Sn((() => [as(r, null, { default: Sn((() => [as(n)])), _: 1 })])), _: 1 })), as(o, null, { default: Sn((() => [as(Ve(c))])), _: 1 }), Ve(u) ? ds("", !0) : (Jo(), es(Ve(l), { key: 1 })), Ve(u) ? (Jo(), es(n, { key: 2 })) : ds("", !0)], 64) } } }), US = (e, t) => { const n = e.__vccOpts || e; for (const [r, o] of t) n[r] = o; return n }, HS = e => (vn("data-v-af5ea00a"), e = e(), bn(), e), BS = { class: "error" }, qS = [HS((() => is("h1", { class: "error__header" }, ":’(", -1))), HS((() => is("h2", { class: "error__title" }, "Ошибка 404", -1))), HS((() => is("p", { class: "error__text" }, "Такой страницы не существует", -1))), HS((() => is("a", { class: "error__link", href: "/" }, "Вернуться на главную", -1)))], VS = US({ __name: "error", setup: e => (Kl({ title: "Страница не найдена", description: "Такой страницы не существует", ogTitle: "Страница не найдена", ogDescription: "Такой страницы не существует", ogUrl: "", ogImage: "", ogType: "website", ogSiteName: "", ogLocale: "ru_RU" }), (e, t) => (Jo(), Zo("div", BS, qS))) }, [["__scopeId", "data-v-af5ea00a"]]), WS = { __name: "nuxt-root", setup(e) { const t = () => null, n = Ac(), r = n.deferHydration(), o = !1; co(cu, mu()), n.hooks.callHookWith((e => e.map((e => e()))), "vue:setup"); const s = uu(); Pr(((e, t, r) => { if (n.hooks.callHook("vue:error", e, t, r).catch((e => console.error("[nuxt] Error in `vue:error` hook", e))), (e => !!e && "object" == typeof e && lu in e)(e) && (e.fatal || e.unhandled)) return n.runWithContext((() => du(e))), !1 })); const i = !1; return (e, n) => (Jo(), es(Ln, { onResolve: Ve(r) }, { default: Sn((() => [Ve(s) ? (Jo(), es(Ve(VS), { key: 0, error: Ve(s) }, null, 8, ["error"])) : Ve(i) ? (Jo(), es(Ve(t), { key: 1, context: Ve(i) }, null, 8, ["context"])) : Ve(o) ? (Jo(), es(In(Ve(o)), { key: 2 })) : (Jo(), es(Ve(FS), { key: 3 }))])), _: 1 }, 8, ["onResolve"])) } }; let zS; { let e; zS = async function () { var t, n; if (e) return e; const r = Boolean((null == (t = window.__NUXT__) ? void 0 : t.serverRendered) || "true" === (null == (n = document.getElementById("__NUXT_DATA__")) ? void 0 : n.dataset.ssr)) ? ((...e) => { const t = oa().createApp(...e), { mount: n } = t; return t.mount = e => { const t = sa(e); if (t) return n(t, !0, t instanceof SVGElement) }, t })(WS) : ((...e) => { const t = ra().createApp(...e), { mount: n } = t; return t.mount = e => { const r = sa(e); if (!r) return; const o = t._component; Vs(o) || o.render || o.template || (o.template = r.innerHTML), r.innerHTML = ""; const s = n(r, !1, r instanceof SVGElement); return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), s }, t })(WS), o = Cc({ vueApp: r }); async function s(e) { await o.callHook("app:error", e), o.payload.error = o.payload.error || e } r.config.errorHandler = s; try { await async function (e, t) { const n = [], r = [], o = [], s = []; let i = 0; async function a(t) { if (t.dependsOn && !t.dependsOn.every((e => n.includes(e)))) r.push([new Set(t.dependsOn), t]); else { const c = async function (e, t) { if (t.hooks && e.hooks.addHooks(t.hooks), "function" == typeof t) { const { provide: n } = await e.runWithContext((() => t(e))) || {}; if (n && "object" == typeof n) for (const t in n) e.provide(t, n[t]) } }(e, t).then((async () => { t._name && (n.push(t._name), await Promise.all(r.map((async ([e, n]) => { e.has(t._name) && (e.delete(t._name), 0 === e.size && (i++, await a(n))) })))) })); t.parallel ? o.push(c.catch((e => s.push(e)))) : await c } } for (const c of t) await a(c); if (await Promise.all(o), i) for (let c = 0; c < i; c++)await Promise.all(o); if (s.length) throw s[0] }(o, hS) } catch (i) { s(i) } try { await o.hooks.callHook("app:created", r), await o.hooks.callHook("app:beforeMount", r), r.mount("#app"), await o.hooks.callHook("app:mounted", r), await rn() } catch (i) { s(i) } return r.config.errorHandler === s && (r.config.errorHandler = void 0), r }, e = zS().catch((e => { throw console.error("Error while mounting app:", e), e })) } export { Er as $, ls as A, bS as B, $S as C, mu as D, Wi as E, Bo as F, pi as G, IS as H, An as I, qn as J, cr as K, Dr as L, Kl as M, Jl as N, hu as O, SS as P, OS as Q, MS as R, Lt as S, Uo as T, Ti as U, Qi as V, _S as W, Fe as X, DS as Y, wS as Z, jc as _, Bp as a, Or as a0, Wr as a1, zi as a2, fu as a3, b as a4, w as a5, Hn as a6, bs as a7, Hp as a8, LS as a9, Cr as aA, xr as aB, qp as aC, gS as aD, jS as aE, kS as aF, Ge as aG, Zi as aa, wn as ab, xe as ac, Te as ad, rn as ae, Mr as af, Lr as ag, $a as ah, xp as ai, Ep as aj, Tp as ak, Ls as al, Ua as am, Ba as an, Ea as ao, vu as ap, Rc as aq, yu as ar, La as as, ja as at, lo as au, co as av, Da as aw, Xl as ax, wa as ay, ba as az, es as b, js as c, is as d, Ht as e, ds as f, Ve as g, ur as h, US as i, Ue as j, Tr as k, Jn as l, ms as m, Ut as n, Jo as o, Zo as p, jr as q, In as r, us as s, Bt as t, xS as u, vn as v, Sn as w, bn as x, Ac as y, as as z };
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["./predzakaz-gta-6.t-iAN5p0.js", "./nuxt-img.DVDG_DV7.js", "./TheAccordion.ByNl8Anp.js", "./TheAccordion.Dqmr2skB.css", "./predzakaz-gta-6.DaBhySdT.css", "./bonus-program.wPrMEJds.js", "./KupikodGold.JYkgU09l.js", "./KupikodGold.DC257x_j.css", "./KupikodBonus.xhvu8ipO.js", "./KupikodBonus.DoXIqhu1.css", "./gift.hcoJFARN.js", "./bonus-program.BXzP6EXX.css", "./contacts.Dob7V1hW.js", "./nuxt-link.CUlQH__i.js", "./contacts.Hy3o9nbz.css", "./policy.3V8mOafy.js", "./policy.DCYdFH1K.css", "./terms.CquVN1lI.js", "./terms.D5-i65nX.css", "./order-status-plati-gift.jHganKvS.js", "./KupikodCoin.Bsot1T6X.js", "./KupikodCoin.DLzQ4DMu.css", "./AccountRegion.VO6wyKAp.js", "./FlagImg.c99GlnIO.js", "./ru.CI-0GExX.js", "./AccountRegion.i-6TH019.css", "./TransitionExpand.CbYOREqa.js", "./TransitionExpand.DBFWcZL0.css", "./ButtonComponent.Cp3PtDM8.js", "./ButtonComponent.WORGvl9p.css", "./loading.84m3E_5w.js", "./select-control.BT0ivl61.js", "./tooltip.A9IRWFFY.js", "./close.Ddj0ZJIE.js", "./index.CcrWORLX.js", "./VueFinalModal.esm.Co8Bv0qO.js", "./customParseFormat.BG_goTfz.js", "./useAddOrderToLocalStorage.DaU1B3jh.js", "./order-status-plati-gift.Qw9sJNxX.css", "./vue-select.CnNxA7i4.css", "./order-status-plati-skins.Ci9HAU7q.js", "./ModalTelegram.fx1TcpRH.js", "./ModalTelegram.BRbs2hiE.css", "./LoginButton.CGDiqKU-.js", "./tg-connect.CDaP-iDv.js", "./LoginButton.CV8OxsxR.css", "./vk-and-telegramm.CvezytMr.js", "./order-status-plati-skins.BkaLpgXn.css", "./order-status-plati.BlyYLrsZ.js", "./order-status-plati.Do26YPnO.css", "./order-status-skins.D6PZ6ma9.js", "./order-status-skins.CF6bXU82.css", "./order-status.BKk7_Eco.js", "./SkeletonWrapper.DBzw1pvC.js", "./SkeletonWrapper.8QfRLCca.css", "./KupikodTicket.BykQjHKJ.js", "./KupikodTicket.BmhFSmds.css", "./order-status.Bx0RQt_y.css", "./orders._qyQuVOs.js", "./debounce.DXHWJuBw.js", "./VK_logo_profile.B4jKCzQJ.js", "./getTextReview.CMjS-91D.js", "./copy-outline.CaKL0erC.js", "./orders.CLb_zXiU.css", "./parse-steam-review.BXi_S9W-.js", "./parse-steam-review.C83oJKBz.css", "./index.BsqDI0Br.js", "./SearchGames.CA3cwrv0.js", "./SearchGames.xK_foGPq.css", "./WorkingBetter.k5BqI5ZY.js", "./WorkingBetter.B6lNjMDF.css", "./index.0lY1nOOo.css", "./reviews.Dmk0SUVU.js", "./ReviewList.r74J0Bdl.js", "./ReviewList.Cu09kNXD.css", "./reviews.DnxG0RQw.css", "./index.yPp_hKTc.js", "./autoplay.cfuBjilC.js", "./swiper-vue.RJj2Od45.js", "./index.ClZh3Cgx.css", "./swiper.B7A9EpPD.css", "./index.D4f5KimQ.js", "./index.yudbGgax.js", "./create-element-if-not-defined.DOGbF7Gv.js", "./VerticalGameCardContainer.CvVU5JhG.js", "./VerticalGameCardContainer.BjNHhunj.css", "./popularGenres.CtY6smKv.js", "./popularGenres.C80nhMWs.css", "./index.B6_7gpbP.css", "./razprodazha.CoiB6FZH.js", "./razprodazha.B8U0dfNP.css", "./service.kgFeCbAI.js", "./service.CjcMB5VO.css", "./skins.BjSK3k2n.js", "./TheModal.DdId0Ihk.js", "./TheModal.DddsLrBv.css", "./TheInfo.C0C632-j.js", "./TheInfo.BmnZnmY3.css", "./digiseller.BqbjoaLl.js", "./KUPIKOD.I0gcvwnx.js", "./digiseller.Dw1rjcTU.css", "./gifts.BKXRNM1E.js", "./gifts.Cc-7MjcA.css", "./main._BKJ5qC5.js", "./vk-icon-white._lbrMmjx.js", "./main.Bw4yQg81.css", "./order-new.DDqOxevT.js", "./arrow.AWnFXOim.js", "./arrow.7vpdkCDE.css", "./order-new.CwIxjpHS.css", "./order.DK8UPh1L.js", "./order.Bbuvp89M.css", "./payment.7ywNYUAM.js", "./payment.DJLwH0wE.css", "./raffle.C-szGx0I.js", "./raffle.CP48KP6W.css", "./ModalSearch.Cf2pKKm_.js", "./TheWidget.Ddb6fdTK.js", "./close-white.CkIL6RuV.js", "./TheWidget.Cyqs1op8.css"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
