function Nn(e, t) { const s = Object.create(null), n = e.split(","); for (let o = 0; o < n.length; o++)s[n[o]] = !0; return t ? o => !!s[o.toLowerCase()] : o => !!s[o] } const oe = {}, xt = [], Le = () => { }, mc = () => !1, vc = /^on[^a-z]/, is = e => vc.test(e), jn = e => e.startsWith("onUpdate:"), ge = Object.assign, $n = (e, t) => { const s = e.indexOf(t); s > -1 && e.splice(s, 1) }, Ac = Object.prototype.hasOwnProperty, Z = (e, t) => Ac.call(e, t), F = Array.isArray, Et = e => Qs(e) === "[object Map]", wr = e => Qs(e) === "[object Set]", Q = e => typeof e == "function", ae = e => typeof e == "string", Qn = e => typeof e == "symbol", re = e => e !== null && typeof e == "object", xr = e => (re(e) || Q(e)) && Q(e.then) && Q(e.catch), Er = Object.prototype.toString, Qs = e => Er.call(e), bc = e => Qs(e).slice(8, -1), Cr = e => Qs(e) === "[object Object]", Fn = e => ae(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Wt = Nn(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), Fs = e => { const t = Object.create(null); return s => t[s] || (t[s] = e(s)) }, yc = /-(\w)/g, De = Fs(e => e.replace(yc, (t, s) => s ? s.toUpperCase() : "")), kc = /\B([A-Z])/g, Ut = Fs(e => e.replace(kc, "-$1").toLowerCase()), Ds = Fs(e => e.charAt(0).toUpperCase() + e.slice(1)), nn = Fs(e => e ? `on${Ds(e)}` : ""), At = (e, t) => !Object.is(e, t), on = (e, t) => { for (let s = 0; s < e.length; s++)e[s](t) }, Es = (e, t, s) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: s }) }, wc = e => { const t = parseFloat(e); return isNaN(t) ? e : t }, xc = e => { const t = ae(e) ? Number(e) : NaN; return isNaN(t) ? e : t }; let yo; const _n = () => yo || (yo = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function Js(e) { if (F(e)) { const t = {}; for (let s = 0; s < e.length; s++) { const n = e[s], o = ae(n) ? Tc(n) : Js(n); if (o) for (const r in o) t[r] = o[r] } return t } else if (ae(e) || re(e)) return e } const Ec = /;(?![^(]*\))/g, Cc = /:([^]+)/, Rc = /\/\*[^]*?\*\//g; function Tc(e) { const t = {}; return e.replace(Rc, "").split(Ec).forEach(s => { if (s) { const n = s.split(Cc); n.length > 1 && (t[n[0].trim()] = n[1].trim()) } }), t } function _e(e) { let t = ""; if (ae(e)) t = e; else if (F(e)) for (let s = 0; s < e.length; s++) { const n = _e(e[s]); n && (t += n + " ") } else if (re(e)) for (const s in e) e[s] && (t += s + " "); return t.trim() } function Ic(e) { if (!e) return null; let { class: t, style: s } = e; return t && !ae(t) && (e.class = _e(t)), s && (e.style = Js(s)), e } const Pc = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Sc = Nn(Pc); function Rr(e) { return !!e || e === "" } const Me = e => ae(e) ? e : e == null ? "" : F(e) || re(e) && (e.toString === Er || !Q(e.toString)) ? JSON.stringify(e, Tr, 2) : String(e), Tr = (e, t) => t && t.__v_isRef ? Tr(e, t.value) : Et(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((s, [n, o]) => (s[`${n} =>`] = o, s), {}) } : wr(t) ? { [`Set(${t.size})`]: [...t.values()] } : re(t) && !F(t) && !Cr(t) ? String(t) : t; let Se; class Ir { constructor(t = !1) { this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Se, !t && Se && (this.index = (Se.scopes || (Se.scopes = [])).push(this) - 1) } get active() { return this._active } run(t) { if (this._active) { const s = Se; try { return Se = this, t() } finally { Se = s } } } on() { Se = this } off() { Se = this.parent } stop(t) { if (this._active) { let s, n; for (s = 0, n = this.effects.length; s < n; s++)this.effects[s].stop(); for (s = 0, n = this.cleanups.length; s < n; s++)this.cleanups[s](); if (this.scopes) for (s = 0, n = this.scopes.length; s < n; s++)this.scopes[s].stop(!0); if (!this.detached && this.parent && !t) { const o = this.parent.scopes.pop(); o && o !== this && (this.parent.scopes[this.index] = o, o.index = this.index) } this.parent = void 0, this._active = !1 } } } function Mc(e) { return new Ir(e) } function Bc(e, t = Se) { t && t.active && t.effects.push(e) } function Hc() { return Se } const Dn = e => { const t = new Set(e); return t.w = 0, t.n = 0, t }, Pr = e => (e.w & it) > 0, Sr = e => (e.n & it) > 0, Lc = ({ deps: e }) => { if (e.length) for (let t = 0; t < e.length; t++)e[t].w |= it }, Oc = e => { const { deps: t } = e; if (t.length) { let s = 0; for (let n = 0; n < t.length; n++) { const o = t[n]; Pr(o) && !Sr(o) ? o.delete(e) : t[s++] = o, o.w &= ~it, o.n &= ~it } t.length = s } }, Cs = new WeakMap; let Jt = 0, it = 1; const gn = 30; let Be; const mt = Symbol(""), mn = Symbol(""); class Jn { constructor(t, s = null, n) { this.fn = t, this.scheduler = s, this.active = !0, this.deps = [], this.parent = void 0, Bc(this, n) } run() { if (!this.active) return this.fn(); let t = Be, s = ot; for (; t;) { if (t === this) return; t = t.parent } try { return this.parent = Be, Be = this, ot = !0, it = 1 << ++Jt, Jt <= gn ? Lc(this) : ko(this), this.fn() } finally { Jt <= gn && Oc(this), it = 1 << --Jt, Be = this.parent, ot = s, this.parent = void 0, this.deferStop && this.stop() } } stop() { Be === this ? this.deferStop = !0 : this.active && (ko(this), this.onStop && this.onStop(), this.active = !1) } } function ko(e) { const { deps: t } = e; if (t.length) { for (let s = 0; s < t.length; s++)t[s].delete(e); t.length = 0 } } let ot = !0; const Mr = []; function Nt() { Mr.push(ot), ot = !1 } function jt() { const e = Mr.pop(); ot = e === void 0 ? !0 : e } function ke(e, t, s) { if (ot && Be) { let n = Cs.get(e); n || Cs.set(e, n = new Map); let o = n.get(s); o || n.set(s, o = Dn()), Br(o) } } function Br(e, t) { let s = !1; Jt <= gn ? Sr(e) || (e.n |= it, s = !Pr(e)) : s = !e.has(Be), s && (e.add(Be), Be.deps.push(e)) } function qe(e, t, s, n, o, r) { const i = Cs.get(e); if (!i) return; let c = []; if (t === "clear") c = [...i.values()]; else if (s === "length" && F(e)) { const l = Number(n); i.forEach((u, a) => { (a === "length" || a >= l) && c.push(u) }) } else switch (s !== void 0 && c.push(i.get(s)), t) { case "add": F(e) ? Fn(s) && c.push(i.get("length")) : (c.push(i.get(mt)), Et(e) && c.push(i.get(mn))); break; case "delete": F(e) || (c.push(i.get(mt)), Et(e) && c.push(i.get(mn))); break; case "set": Et(e) && c.push(i.get(mt)); break }if (c.length === 1) c[0] && vn(c[0]); else { const l = []; for (const u of c) u && l.push(...u); vn(Dn(l)) } } function vn(e, t) { const s = F(e) ? e : [...e]; for (const n of s) n.computed && wo(n); for (const n of s) n.computed || wo(n) } function wo(e, t) { (e !== Be || e.allowRecurse) && (e.scheduler ? e.scheduler() : e.run()) } function Uc(e, t) { var s; return (s = Cs.get(e)) == null ? void 0 : s.get(t) } const Nc = Nn("__proto__,__v_isRef,__isVue"), Hr = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(Qn)), xo = jc(); function jc() { const e = {}; return ["includes", "indexOf", "lastIndexOf"].forEach(t => { e[t] = function (...s) { const n = X(this); for (let r = 0, i = this.length; r < i; r++)ke(n, "get", r + ""); const o = n[t](...s); return o === -1 || o === !1 ? n[t](...s.map(X)) : o } }), ["push", "pop", "shift", "unshift", "splice"].forEach(t => { e[t] = function (...s) { Nt(); const n = X(this)[t].apply(this, s); return jt(), n } }), e } function $c(e) { const t = X(this); return ke(t, "has", e), t.hasOwnProperty(e) } class Lr { constructor(t = !1, s = !1) { this._isReadonly = t, this._shallow = s } get(t, s, n) { const o = this._isReadonly, r = this._shallow; if (s === "__v_isReactive") return !o; if (s === "__v_isReadonly") return o; if (s === "__v_isShallow") return r; if (s === "__v_raw" && n === (o ? r ? Gc : jr : r ? Nr : Ur).get(t)) return t; const i = F(t); if (!o) { if (i && Z(xo, s)) return Reflect.get(xo, s, n); if (s === "hasOwnProperty") return $c } const c = Reflect.get(t, s, n); return (Qn(s) ? Hr.has(s) : Nc(s)) || (o || ke(t, "get", s), r) ? c : he(c) ? i && Fn(s) ? c : c.value : re(c) ? o ? Qr(c) : Ze(c) : c } } class Or extends Lr { constructor(t = !1) { super(!1, t) } set(t, s, n, o) { let r = t[s]; if (bt(r) && he(r) && !he(n)) return !1; if (!this._shallow && (!Rs(n) && !bt(n) && (r = X(r), n = X(n)), !F(t) && he(r) && !he(n))) return r.value = n, !0; const i = F(t) && Fn(s) ? Number(s) < t.length : Z(t, s), c = Reflect.set(t, s, n, o); return t === X(o) && (i ? At(n, r) && qe(t, "set", s, n) : qe(t, "add", s, n)), c } deleteProperty(t, s) { const n = Z(t, s); t[s]; const o = Reflect.deleteProperty(t, s); return o && n && qe(t, "delete", s, void 0), o } has(t, s) { const n = Reflect.has(t, s); return (!Qn(s) || !Hr.has(s)) && ke(t, "has", s), n } ownKeys(t) { return ke(t, "iterate", F(t) ? "length" : mt), Reflect.ownKeys(t) } } class Qc extends Lr { constructor(t = !1) { super(!0, t) } set(t, s) { return !0 } deleteProperty(t, s) { return !0 } } const Fc = new Or, Dc = new Qc, Jc = new Or(!0), Kn = e => e, Ks = e => Reflect.getPrototypeOf(e); function us(e, t, s = !1, n = !1) { e = e.__v_raw; const o = X(e), r = X(t); s || (At(t, r) && ke(o, "get", t), ke(o, "get", r)); const { has: i } = Ks(o), c = n ? Kn : s ? qn : zt; if (i.call(o, t)) return c(e.get(t)); if (i.call(o, r)) return c(e.get(r)); e !== o && e.get(t) } function fs(e, t = !1) { const s = this.__v_raw, n = X(s), o = X(e); return t || (At(e, o) && ke(n, "has", e), ke(n, "has", o)), e === o ? s.has(e) : s.has(e) || s.has(o) } function ds(e, t = !1) { return e = e.__v_raw, !t && ke(X(e), "iterate", mt), Reflect.get(e, "size", e) } function Eo(e) { e = X(e); const t = X(this); return Ks(t).has.call(t, e) || (t.add(e), qe(t, "add", e, e)), this } function Co(e, t) { t = X(t); const s = X(this), { has: n, get: o } = Ks(s); let r = n.call(s, e); r || (e = X(e), r = n.call(s, e)); const i = o.call(s, e); return s.set(e, t), r ? At(t, i) && qe(s, "set", e, t) : qe(s, "add", e, t), this } function Ro(e) { const t = X(this), { has: s, get: n } = Ks(t); let o = s.call(t, e); o || (e = X(e), o = s.call(t, e)), n && n.call(t, e); const r = t.delete(e); return o && qe(t, "delete", e, void 0), r } function To() { const e = X(this), t = e.size !== 0, s = e.clear(); return t && qe(e, "clear", void 0, void 0), s } function hs(e, t) { return function (n, o) { const r = this, i = r.__v_raw, c = X(i), l = t ? Kn : e ? qn : zt; return !e && ke(c, "iterate", mt), i.forEach((u, a) => n.call(o, l(u), l(a), r)) } } function ps(e, t, s) { return function (...n) { const o = this.__v_raw, r = X(o), i = Et(r), c = e === "entries" || e === Symbol.iterator && i, l = e === "keys" && i, u = o[e](...n), a = s ? Kn : t ? qn : zt; return !t && ke(r, "iterate", l ? mn : mt), { next() { const { value: f, done: p } = u.next(); return p ? { value: f, done: p } : { value: c ? [a(f[0]), a(f[1])] : a(f), done: p } }, [Symbol.iterator]() { return this } } } } function Ge(e) { return function (...t) { return e === "delete" ? !1 : this } } function Kc() { const e = { get(r) { return us(this, r) }, get size() { return ds(this) }, has: fs, add: Eo, set: Co, delete: Ro, clear: To, forEach: hs(!1, !1) }, t = { get(r) { return us(this, r, !1, !0) }, get size() { return ds(this) }, has: fs, add: Eo, set: Co, delete: Ro, clear: To, forEach: hs(!1, !0) }, s = { get(r) { return us(this, r, !0) }, get size() { return ds(this, !0) }, has(r) { return fs.call(this, r, !0) }, add: Ge("add"), set: Ge("set"), delete: Ge("delete"), clear: Ge("clear"), forEach: hs(!0, !1) }, n = { get(r) { return us(this, r, !0, !0) }, get size() { return ds(this, !0) }, has(r) { return fs.call(this, r, !0) }, add: Ge("add"), set: Ge("set"), delete: Ge("delete"), clear: Ge("clear"), forEach: hs(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach(r => { e[r] = ps(r, !1, !1), s[r] = ps(r, !0, !1), t[r] = ps(r, !1, !0), n[r] = ps(r, !0, !0) }), [e, s, t, n] } const [Wc, Vc, qc, Yc] = Kc(); function Wn(e, t) { const s = t ? e ? Yc : qc : e ? Vc : Wc; return (n, o, r) => o === "__v_isReactive" ? !e : o === "__v_isReadonly" ? e : o === "__v_raw" ? n : Reflect.get(Z(s, o) && o in n ? s : n, o, r) } const Zc = { get: Wn(!1, !1) }, Xc = { get: Wn(!1, !0) }, zc = { get: Wn(!0, !1) }, Ur = new WeakMap, Nr = new WeakMap, jr = new WeakMap, Gc = new WeakMap; function ea(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function ta(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : ea(bc(e)) } function Ze(e) { return bt(e) ? e : Vn(e, !1, Fc, Zc, Ur) } function $r(e) { return Vn(e, !1, Jc, Xc, Nr) } function Qr(e) { return Vn(e, !0, Dc, zc, jr) } function Vn(e, t, s, n, o) { if (!re(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; const r = o.get(e); if (r) return r; const i = ta(e); if (i === 0) return e; const c = new Proxy(e, i === 2 ? n : s); return o.set(e, c), c } function Ct(e) { return bt(e) ? Ct(e.__v_raw) : !!(e && e.__v_isReactive) } function bt(e) { return !!(e && e.__v_isReadonly) } function Rs(e) { return !!(e && e.__v_isShallow) } function Fr(e) { return Ct(e) || bt(e) } function X(e) { const t = e && e.__v_raw; return t ? X(t) : e } function Dr(e) { return Es(e, "__v_skip", !0), e } const zt = e => re(e) ? Ze(e) : e, qn = e => re(e) ? Qr(e) : e; function Jr(e) { ot && Be && (e = X(e), Br(e.dep || (e.dep = Dn()))) } function Kr(e, t) { e = X(e); const s = e.dep; s && vn(s) } function he(e) { return !!(e && e.__v_isRef === !0) } function be(e) { return Wr(e, !1) } function Io(e) { return Wr(e, !0) } function Wr(e, t) { return he(e) ? e : new sa(e, t) } class sa { constructor(t, s) { this.__v_isShallow = s, this.dep = void 0, this.__v_isRef = !0, this._rawValue = s ? t : X(t), this._value = s ? t : zt(t) } get value() { return Jr(this), this._value } set value(t) { const s = this.__v_isShallow || Rs(t) || bt(t); t = s ? t : X(t), At(t, this._rawValue) && (this._rawValue = t, this._value = s ? t : zt(t), Kr(this)) } } function ne(e) { return he(e) ? e.value : e } const na = { get: (e, t, s) => ne(Reflect.get(e, t, s)), set: (e, t, s, n) => { const o = e[t]; return he(o) && !he(s) ? (o.value = s, !0) : Reflect.set(e, t, s, n) } }; function Vr(e) { return Ct(e) ? e : new Proxy(e, na) } class oa { constructor(t, s, n) { this._object = t, this._key = s, this._defaultValue = n, this.__v_isRef = !0 } get value() { const t = this._object[this._key]; return t === void 0 ? this._defaultValue : t } set value(t) { this._object[this._key] = t } get dep() { return Uc(X(this._object), this._key) } } class ra { constructor(t) { this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0 } get value() { return this._getter() } } function ia(e, t, s) { return he(e) ? e : Q(e) ? new ra(e) : re(e) && arguments.length > 1 ? ca(e, t, s) : be(e) } function ca(e, t, s) { const n = e[t]; return he(n) ? n : new oa(e, t, s) } class aa { constructor(t, s, n, o) { this._setter = s, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new Jn(t, () => { this._dirty || (this._dirty = !0, Kr(this)) }), this.effect.computed = this, this.effect.active = this._cacheable = !o, this.__v_isReadonly = n } get value() { const t = X(this); return Jr(t), (t._dirty || !t._cacheable) && (t._dirty = !1, t._value = t.effect.run()), t._value } set value(t) { this._setter(t) } } function la(e, t, s = !1) { let n, o; const r = Q(e); return r ? (n = e, o = Le) : (n = e.get, o = e.set), new aa(n, o, r || !o, s) } function rt(e, t, s, n) { let o; try { o = n ? e(...n) : e() } catch (r) { $t(r, t, s) } return o } function Oe(e, t, s, n) { if (Q(e)) { const r = rt(e, t, s, n); return r && xr(r) && r.catch(i => { $t(i, t, s) }), r } const o = []; for (let r = 0; r < e.length; r++)o.push(Oe(e[r], t, s, n)); return o } function $t(e, t, s, n = !0) { const o = t ? t.vnode : null; if (t) { let r = t.parent; const i = t.proxy, c = s; for (; r;) { const u = r.ec; if (u) { for (let a = 0; a < u.length; a++)if (u[a](e, i, c) === !1) return } r = r.parent } const l = t.appContext.config.errorHandler; if (l) { rt(l, null, 10, [e, i, c]); return } } ua(e, s, o, n) } function ua(e, t, s, n = !0) { console.error(e) } let Gt = !1, An = !1; const me = []; let Fe = 0; const Rt = []; let Ve = null, pt = 0; const qr = Promise.resolve(); let Yn = null; function Zn(e) { const t = Yn || qr; return e ? t.then(this ? e.bind(this) : e) : t } function fa(e) { let t = Fe + 1, s = me.length; for (; t < s;) { const n = t + s >>> 1; es(me[n]) < e ? t = n + 1 : s = n } return t } function Ws(e) { (!me.length || !me.includes(e, Gt && e.allowRecurse ? Fe + 1 : Fe)) && (e.id == null ? me.push(e) : me.splice(fa(e.id), 0, e), Yr()) } function Yr() { !Gt && !An && (An = !0, Yn = qr.then(Xr)) } function da(e) { const t = me.indexOf(e); t > Fe && me.splice(t, 1) } function Zr(e) { F(e) ? Rt.push(...e) : (!Ve || !Ve.includes(e, e.allowRecurse ? pt + 1 : pt)) && Rt.push(e), Yr() } function Po(e, t = Gt ? Fe + 1 : 0) { for (; t < me.length; t++) { const s = me[t]; s && s.pre && (me.splice(t, 1), t--, s()) } } function Ts(e) { if (Rt.length) { const t = [...new Set(Rt)]; if (Rt.length = 0, Ve) { Ve.push(...t); return } for (Ve = t, Ve.sort((s, n) => es(s) - es(n)), pt = 0; pt < Ve.length; pt++)Ve[pt](); Ve = null, pt = 0 } } const es = e => e.id == null ? 1 / 0 : e.id, ha = (e, t) => { const s = es(e) - es(t); if (s === 0) { if (e.pre && !t.pre) return -1; if (t.pre && !e.pre) return 1 } return s }; function Xr(e) { An = !1, Gt = !0, me.sort(ha); const t = Le; try { for (Fe = 0; Fe < me.length; Fe++) { const s = me[Fe]; s && s.active !== !1 && rt(s, null, 14) } } finally { Fe = 0, me.length = 0, Ts(), Gt = !1, Yn = null, (me.length || Rt.length) && Xr() } } function pa(e, t, ...s) { if (e.isUnmounted) return; const n = e.vnode.props || oe; let o = s; const r = t.startsWith("update:"), i = r && t.slice(7); if (i && i in n) { const a = `${i === "modelValue" ? "model" : i}Modifiers`, { number: f, trim: p } = n[a] || oe; p && (o = s.map(_ => ae(_) ? _.trim() : _)), f && (o = s.map(wc)) } let c, l = n[c = nn(t)] || n[c = nn(De(t))]; !l && r && (l = n[c = nn(Ut(t))]), l && Oe(l, e, 6, o); const u = n[c + "Once"]; if (u) { if (!e.emitted) e.emitted = {}; else if (e.emitted[c]) return; e.emitted[c] = !0, Oe(u, e, 6, o) } } function zr(e, t, s = !1) { const n = t.emitsCache, o = n.get(e); if (o !== void 0) return o; const r = e.emits; let i = {}, c = !1; if (!Q(e)) { const l = u => { const a = zr(u, t, !0); a && (c = !0, ge(i, a)) }; !s && t.mixins.length && t.mixins.forEach(l), e.extends && l(e.extends), e.mixins && e.mixins.forEach(l) } return !r && !c ? (re(e) && n.set(e, null), null) : (F(r) ? r.forEach(l => i[l] = null) : ge(i, r), re(e) && n.set(e, i), i) } function Vs(e, t) { return !e || !is(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), Z(e, t[0].toLowerCase() + t.slice(1)) || Z(e, Ut(t)) || Z(e, t)) } let pe = null, qs = null; function Is(e) { const t = pe; return pe = e, qs = e && e.type.__scopeId || null, t } function Je(e) { qs = e } function Ke() { qs = null } function Ye(e, t = pe, s) { if (!t || e._n) return e; const n = (...o) => { n._d && Jo(-1); const r = Is(t); let i; try { i = e(...o) } finally { Is(r), n._d && Jo(1) } return i }; return n._n = !0, n._c = !0, n._d = !0, n } function rn(e) { const { type: t, vnode: s, proxy: n, withProxy: o, props: r, propsOptions: [i], slots: c, attrs: l, emit: u, render: a, renderCache: f, data: p, setupState: _, ctx: A, inheritAttrs: R } = e; let j, v; const b = Is(e); try { if (s.shapeFlag & 4) { const x = o || n; j = Re(a.call(x, x, f, r, _, p, A)), v = l } else { const x = t; j = Re(x.length > 1 ? x(r, { attrs: l, slots: c, emit: u }) : x(r, null)), v = t.props ? l : ga(l) } } catch (x) { Zt.length = 0, $t(x, e, 1), j = U(Ue) } let $ = j; if (v && R !== !1) { const x = Object.keys(v), { shapeFlag: M } = $; x.length && M & 7 && (i && x.some(jn) && (v = ma(v, i)), $ = Bt($, v)) } return s.dirs && ($ = Bt($), $.dirs = $.dirs ? $.dirs.concat(s.dirs) : s.dirs), s.transition && ($.transition = s.transition), j = $, Is(b), j } function _a(e) { let t; for (let s = 0; s < e.length; s++) { const n = e[s]; if (os(n)) { if (n.type !== Ue || n.children === "v-if") { if (t) return; t = n } } else return } return t } const ga = e => { let t; for (const s in e) (s === "class" || s === "style" || is(s)) && ((t || (t = {}))[s] = e[s]); return t }, ma = (e, t) => { const s = {}; for (const n in e) (!jn(n) || !(n.slice(9) in t)) && (s[n] = e[n]); return s }; function va(e, t, s) { const { props: n, children: o, component: r } = e, { props: i, children: c, patchFlag: l } = t, u = r.emitsOptions; if (t.dirs || t.transition) return !0; if (s && l >= 0) { if (l & 1024) return !0; if (l & 16) return n ? So(n, i, u) : !!i; if (l & 8) { const a = t.dynamicProps; for (let f = 0; f < a.length; f++) { const p = a[f]; if (i[p] !== n[p] && !Vs(u, p)) return !0 } } } else return (o || c) && (!c || !c.$stable) ? !0 : n === i ? !1 : n ? i ? So(n, i, u) : !0 : !!i; return !1 } function So(e, t, s) { const n = Object.keys(t); if (n.length !== Object.keys(e).length) return !0; for (let o = 0; o < n.length; o++) { const r = n[o]; if (t[r] !== e[r] && !Vs(s, r)) return !0 } return !1 } function Xn({ vnode: e, parent: t }, s) { for (; t && t.subTree === e;)(e = t.vnode).el = s, t = t.parent } const Aa = e => e.__isSuspense, ba = { name: "Suspense", __isSuspense: !0, process(e, t, s, n, o, r, i, c, l, u) { e == null ? ka(t, s, n, o, r, i, c, l, u) : wa(e, t, s, n, o, i, c, l, u) }, hydrate: xa, create: zn, normalize: Ea }, ya = ba; function ts(e, t) { const s = e.props && e.props[t]; Q(s) && s() } function ka(e, t, s, n, o, r, i, c, l) { const { p: u, o: { createElement: a } } = l, f = a("div"), p = e.suspense = zn(e, o, n, t, f, s, r, i, c, l); u(null, p.pendingBranch = e.ssContent, f, null, n, p, r, i), p.deps > 0 ? (ts(e, "onPending"), ts(e, "onFallback"), u(null, e.ssFallback, t, s, n, null, r, i), Tt(p, e.ssFallback)) : p.resolve(!1, !0) } function wa(e, t, s, n, o, r, i, c, { p: l, um: u, o: { createElement: a } }) { const f = t.suspense = e.suspense; f.vnode = t, t.el = e.el; const p = t.ssContent, _ = t.ssFallback, { activeBranch: A, pendingBranch: R, isInFallback: j, isHydrating: v } = f; if (R) f.pendingBranch = p, nt(p, R) ? (l(R, p, f.hiddenContainer, null, o, f, r, i, c), f.deps <= 0 ? f.resolve() : j && (l(A, _, s, n, o, null, r, i, c), Tt(f, _))) : (f.pendingId++, v ? (f.isHydrating = !1, f.activeBranch = R) : u(R, o, f), f.deps = 0, f.effects.length = 0, f.hiddenContainer = a("div"), j ? (l(null, p, f.hiddenContainer, null, o, f, r, i, c), f.deps <= 0 ? f.resolve() : (l(A, _, s, n, o, null, r, i, c), Tt(f, _))) : A && nt(p, A) ? (l(A, p, s, n, o, f, r, i, c), f.resolve(!0)) : (l(null, p, f.hiddenContainer, null, o, f, r, i, c), f.deps <= 0 && f.resolve())); else if (A && nt(p, A)) l(A, p, s, n, o, f, r, i, c), Tt(f, p); else if (ts(t, "onPending"), f.pendingBranch = p, f.pendingId++, l(null, p, f.hiddenContainer, null, o, f, r, i, c), f.deps <= 0) f.resolve(); else { const { timeout: b, pendingId: $ } = f; b > 0 ? setTimeout(() => { f.pendingId === $ && f.fallback(_) }, b) : b === 0 && f.fallback(_) } } function zn(e, t, s, n, o, r, i, c, l, u, a = !1) { const { p: f, m: p, um: _, n: A, o: { parentNode: R, remove: j } } = u; let v; const b = Ca(e); b && t != null && t.pendingBranch && (v = t.pendingId, t.deps++); const $ = e.props ? xc(e.props.timeout) : void 0, x = { vnode: e, parent: t, parentComponent: s, isSVG: i, container: n, hiddenContainer: o, anchor: r, deps: 0, pendingId: 0, timeout: typeof $ == "number" ? $ : -1, activeBranch: null, pendingBranch: null, isInFallback: !0, isHydrating: a, isUnmounted: !1, effects: [], resolve(M = !1, J = !1) { const { vnode: N, activeBranch: P, pendingBranch: W, pendingId: q, effects: Y, parentComponent: ve, container: ie } = x; if (x.isHydrating) x.isHydrating = !1; else if (!M) { const z = P && W.transition && W.transition.mode === "out-in"; z && (P.transition.afterLeave = () => { q === x.pendingId && p(W, ie, ee, 0) }); let { anchor: ee } = x; P && (ee = A(P), _(P, ve, x, !0)), z || p(W, ie, ee, 0) } Tt(x, W), x.pendingBranch = null, x.isInFallback = !1; let L = x.parent, xe = !1; for (; L;) { if (L.pendingBranch) { L.effects.push(...Y), xe = !0; break } L = L.parent } xe || Zr(Y), x.effects = [], b && t && t.pendingBranch && v === t.pendingId && (t.deps--, t.deps === 0 && !J && t.resolve()), ts(N, "onResolve") }, fallback(M) { if (!x.pendingBranch) return; const { vnode: J, activeBranch: N, parentComponent: P, container: W, isSVG: q } = x; ts(J, "onFallback"); const Y = A(N), ve = () => { x.isInFallback && (f(null, M, W, Y, P, null, q, c, l), Tt(x, M)) }, ie = M.transition && M.transition.mode === "out-in"; ie && (N.transition.afterLeave = ve), x.isInFallback = !0, _(N, P, null, !0), ie || ve() }, move(M, J, N) { x.activeBranch && p(x.activeBranch, M, J, N), x.container = M }, next() { return x.activeBranch && A(x.activeBranch) }, registerDep(M, J) { const N = !!x.pendingBranch; N && x.deps++; const P = M.vnode.el; M.asyncDep.catch(W => { $t(W, M, 0) }).then(W => { if (M.isUnmounted || x.isUnmounted || x.pendingId !== M.suspenseId) return; M.asyncResolved = !0; const { vnode: q } = M; En(M, W, !1), P && (q.el = P); const Y = !P && M.subTree.el; J(M, q, R(P || M.subTree.el), P ? null : A(M.subTree), x, i, l), Y && j(Y), Xn(M, q.el), N && --x.deps === 0 && x.resolve() }) }, unmount(M, J) { x.isUnmounted = !0, x.activeBranch && _(x.activeBranch, s, M, J), x.pendingBranch && _(x.pendingBranch, s, M, J) } }; return x } function xa(e, t, s, n, o, r, i, c, l) { const u = t.suspense = zn(t, n, s, e.parentNode, document.createElement("div"), null, o, r, i, c, !0), a = l(e, u.pendingBranch = t.ssContent, s, u, r, i); return u.deps === 0 && u.resolve(!1, !0), a } function Ea(e) { const { shapeFlag: t, children: s } = e, n = t & 32; e.ssContent = Mo(n ? s.default : s), e.ssFallback = n ? Mo(s.fallback) : U(Ue) } function Mo(e) { let t; if (Q(e)) { const s = Mt && e._c; s && (e._d = !1, O()), e = e(), s && (e._d = !0, t = Te, bi()) } return F(e) && (e = _a(e)), e = Re(e), t && !e.dynamicChildren && (e.dynamicChildren = t.filter(s => s !== e)), e } function Gr(e, t) { t && t.pendingBranch ? F(e) ? t.effects.push(...e) : t.effects.push(e) : Zr(e) } function Tt(e, t) { e.activeBranch = t; const { vnode: s, parentComponent: n } = e, o = s.el = t.el; n && n.subTree === s && (n.vnode.el = o, Xn(n, o)) } function Ca(e) { var t; return ((t = e.props) == null ? void 0 : t.suspensible) != null && e.props.suspensible !== !1 } function Ra(e, t) { return Gn(e, null, t) } const _s = {}; function ys(e, t, s) { return Gn(e, t, s) } function Gn(e, t, { immediate: s, deep: n, flush: o, onTrack: r, onTrigger: i } = oe) { var c; const l = Hc() === ((c = de) == null ? void 0 : c.scope) ? de : null; let u, a = !1, f = !1; if (he(e) ? (u = () => e.value, a = Rs(e)) : Ct(e) ? (u = () => e, n = !0) : F(e) ? (f = !0, a = e.some(x => Ct(x) || Rs(x)), u = () => e.map(x => { if (he(x)) return x.value; if (Ct(x)) return gt(x); if (Q(x)) return rt(x, l, 2) })) : Q(e) ? t ? u = () => rt(e, l, 2) : u = () => { if (!(l && l.isUnmounted)) return p && p(), Oe(e, l, 3, [_]) } : u = Le, t && n) { const x = u; u = () => gt(x()) } let p, _ = x => { p = b.onStop = () => { rt(x, l, 4) } }, A; if (Lt) if (_ = Le, t ? s && Oe(t, l, 3, [u(), f ? [] : void 0, _]) : u(), o === "sync") { const x = Al(); A = x.__watcherHandles || (x.__watcherHandles = []) } else return Le; let R = f ? new Array(e.length).fill(_s) : _s; const j = () => { if (b.active) if (t) { const x = b.run(); (n || a || (f ? x.some((M, J) => At(M, R[J])) : At(x, R))) && (p && p(), Oe(t, l, 3, [x, R === _s ? void 0 : f && R[0] === _s ? [] : R, _]), R = x) } else b.run() }; j.allowRecurse = !!t; let v; o === "sync" ? v = j : o === "post" ? v = () => ye(j, l && l.suspense) : (j.pre = !0, l && (j.id = l.uid), v = () => Ws(j)); const b = new Jn(u, v); t ? s ? j() : R = b.run() : o === "post" ? ye(b.run.bind(b), l && l.suspense) : b.run(); const $ = () => { b.stop(), l && l.scope && $n(l.scope.effects, b) }; return A && A.push($), $ } function Ta(e, t, s) { const n = this.proxy, o = ae(e) ? e.includes(".") ? ei(n, e) : () => n[e] : e.bind(n, n); let r; Q(t) ? r = t : (r = t.handler, s = t); const i = de; Ht(this); const c = Gn(o, r.bind(n), s); return i ? Ht(i) : vt(), c } function ei(e, t) { const s = t.split("."); return () => { let n = e; for (let o = 0; o < s.length && n; o++)n = n[s[o]]; return n } } function gt(e, t) { if (!re(e) || e.__v_skip || (t = t || new Set, t.has(e))) return e; if (t.add(e), he(e)) gt(e.value, t); else if (F(e)) for (let s = 0; s < e.length; s++)gt(e[s], t); else if (wr(e) || Et(e)) e.forEach(s => { gt(s, t) }); else if (Cr(e)) for (const s in e) gt(e[s], t); return e } function Ia(e, t) { const s = pe; if (s === null) return e; const n = Gs(s) || s.proxy, o = e.dirs || (e.dirs = []); for (let r = 0; r < t.length; r++) { let [i, c, l, u = oe] = t[r]; i && (Q(i) && (i = { mounted: i, updated: i }), i.deep && gt(c), o.push({ dir: i, instance: n, value: c, oldValue: void 0, arg: l, modifiers: u })) } return e } function Qe(e, t, s, n) { const o = e.dirs, r = t && t.dirs; for (let i = 0; i < o.length; i++) { const c = o[i]; r && (c.oldValue = r[i].value); let l = c.dir[n]; l && (Nt(), Oe(l, s, 8, [e.el, c, e, t]), jt()) } }/*! #__NO_SIDE_EFFECTS__ */function Ys(e, t) { return Q(e) ? (() => ge({ name: e.name }, t, { setup: e }))() : e } const It = e => !!e.type.__asyncLoader;/*! #__NO_SIDE_EFFECTS__ */function Bo(e) { Q(e) && (e = { loader: e }); const { loader: t, loadingComponent: s, errorComponent: n, delay: o = 200, timeout: r, suspensible: i = !0, onError: c } = e; let l = null, u, a = 0; const f = () => (a++, l = null, p()), p = () => { let _; return l || (_ = l = t().catch(A => { if (A = A instanceof Error ? A : new Error(String(A)), c) return new Promise((R, j) => { c(A, () => R(f()), () => j(A), a + 1) }); throw A }).then(A => _ !== l && l ? l : (A && (A.__esModule || A[Symbol.toStringTag] === "Module") && (A = A.default), u = A, A))) }; return Ys({ name: "AsyncComponentWrapper", __asyncLoader: p, get __asyncResolved() { return u }, setup() { const _ = de; if (u) return () => cn(u, _); const A = b => { l = null, $t(b, _, 13, !n) }; if (i && _.suspense || Lt) return p().then(b => () => cn(b, _)).catch(b => (A(b), () => n ? U(n, { error: b }) : null)); const R = be(!1), j = be(), v = be(!!o); return o && setTimeout(() => { v.value = !1 }, o), r != null && setTimeout(() => { if (!R.value && !j.value) { const b = new Error(`Async component timed out after ${r}ms.`); A(b), j.value = b } }, r), p().then(() => { R.value = !0, _.parent && eo(_.parent.vnode) && Ws(_.parent.update) }).catch(b => { A(b), j.value = b }), () => { if (R.value && u) return cn(u, _); if (j.value && n) return U(n, { error: j.value }); if (s && !v.value) return U(s) } } }) } function cn(e, t) { const { ref: s, props: n, children: o, ce: r } = t.vnode, i = U(e, n, o); return i.ref = s, i.ce = r, delete t.vnode.ce, i } const eo = e => e.type.__isKeepAlive; function ti(e, t) { ni(e, "a", t) } function si(e, t) { ni(e, "da", t) } function ni(e, t, s = de) { const n = e.__wdc || (e.__wdc = () => { let o = s; for (; o;) { if (o.isDeactivated) return; o = o.parent } return e() }); if (Zs(t, n, s), s) { let o = s.parent; for (; o && o.parent;)eo(o.parent.vnode) && Pa(n, t, s, o), o = o.parent } } function Pa(e, t, s, n) { const o = Zs(t, e, n, !0); oi(() => { $n(n[t], o) }, s) } function Zs(e, t, s = de, n = !1) { if (s) { const o = s[e] || (s[e] = []), r = t.__weh || (t.__weh = (...i) => { if (s.isUnmounted) return; Nt(), Ht(s); const c = Oe(t, s, e, i); return vt(), jt(), c }); return n ? o.unshift(r) : o.push(r), r } } const ze = e => (t, s = de) => (!Lt || e === "sp") && Zs(e, (...n) => t(...n), s), Sa = ze("bm"), Xs = ze("m"), Ma = ze("bu"), Ba = ze("u"), to = ze("bum"), oi = ze("um"), Ha = ze("sp"), La = ze("rtg"), Oa = ze("rtc"); function ri(e, t = de) { Zs("ec", e, t) } const so = "components"; function Ua(e, t) { return ci(so, e, !0, t) || e } const ii = Symbol.for("v-ndc"); function Na(e) { return ae(e) ? ci(so, e, !1) || e : e || ii } function ci(e, t, s = !0, n = !1) { const o = pe || de; if (o) { const r = o.type; if (e === so) { const c = gl(r, !1); if (c && (c === t || c === De(t) || c === Ds(De(t)))) return r } const i = Ho(o[e] || r[e], t) || Ho(o.appContext[e], t); return !i && n ? r : i } } function Ho(e, t) { return e && (e[t] || e[De(t)] || e[Ds(De(t))]) } function ss(e, t, s, n) { let o; const r = s && s[n]; if (F(e) || ae(e)) { o = new Array(e.length); for (let i = 0, c = e.length; i < c; i++)o[i] = t(e[i], i, void 0, r && r[i]) } else if (typeof e == "number") { o = new Array(e); for (let i = 0; i < e; i++)o[i] = t(i + 1, i, void 0, r && r[i]) } else if (re(e)) if (e[Symbol.iterator]) o = Array.from(e, (i, c) => t(i, c, void 0, r && r[c])); else { const i = Object.keys(e); o = new Array(i.length); for (let c = 0, l = i.length; c < l; c++) { const u = i[c]; o[c] = t(e[u], u, c, r && r[c]) } } else o = []; return s && (s[n] = o), o } function ja(e, t, s = {}, n, o) { if (pe.isCE || pe.parent && It(pe.parent) && pe.parent.isCE) return t !== "default" && (s.name = t), U("slot", s, n && n()); let r = e[t]; r && r._c && (r._d = !1), O(); const i = r && ai(r(s)), c = He(ce, { key: s.key || i && i.key || `_${t}` }, i || (n ? n() : []), i && e._ === 1 ? 64 : -2); return !o && c.scopeId && (c.slotScopeIds = [c.scopeId + "-s"]), r && r._c && (r._d = !0), c } function ai(e) { return e.some(t => os(t) ? !(t.type === Ue || t.type === ce && !ai(t.children)) : !0) ? e : null } const bn = e => e ? Ei(e) ? Gs(e) || e.proxy : bn(e.parent) : null, Vt = ge(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => bn(e.parent), $root: e => bn(e.root), $emit: e => e.emit, $options: e => no(e), $forceUpdate: e => e.f || (e.f = () => Ws(e.update)), $nextTick: e => e.n || (e.n = Zn.bind(e.proxy)), $watch: e => Ta.bind(e) }), an = (e, t) => e !== oe && !e.__isScriptSetup && Z(e, t), $a = { get({ _: e }, t) { const { ctx: s, setupState: n, data: o, props: r, accessCache: i, type: c, appContext: l } = e; let u; if (t[0] !== "$") { const _ = i[t]; if (_ !== void 0) switch (_) { case 1: return n[t]; case 2: return o[t]; case 4: return s[t]; case 3: return r[t] } else { if (an(n, t)) return i[t] = 1, n[t]; if (o !== oe && Z(o, t)) return i[t] = 2, o[t]; if ((u = e.propsOptions[0]) && Z(u, t)) return i[t] = 3, r[t]; if (s !== oe && Z(s, t)) return i[t] = 4, s[t]; yn && (i[t] = 0) } } const a = Vt[t]; let f, p; if (a) return t === "$attrs" && ke(e, "get", t), a(e); if ((f = c.__cssModules) && (f = f[t])) return f; if (s !== oe && Z(s, t)) return i[t] = 4, s[t]; if (p = l.config.globalProperties, Z(p, t)) return p[t] }, set({ _: e }, t, s) { const { data: n, setupState: o, ctx: r } = e; return an(o, t) ? (o[t] = s, !0) : n !== oe && Z(n, t) ? (n[t] = s, !0) : Z(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (r[t] = s, !0) }, has({ _: { data: e, setupState: t, accessCache: s, ctx: n, appContext: o, propsOptions: r } }, i) { let c; return !!s[i] || e !== oe && Z(e, i) || an(t, i) || (c = r[0]) && Z(c, i) || Z(n, i) || Z(Vt, i) || Z(o.config.globalProperties, i) }, defineProperty(e, t, s) { return s.get != null ? e._.accessCache[t] = 0 : Z(s, "value") && this.set(e, t, s.value, null), Reflect.defineProperty(e, t, s) } }; function Lo(e) { return F(e) ? e.reduce((t, s) => (t[s] = null, t), {}) : e } let yn = !0; function Qa(e) { const t = no(e), s = e.proxy, n = e.ctx; yn = !1, t.beforeCreate && Oo(t.beforeCreate, e, "bc"); const { data: o, computed: r, methods: i, watch: c, provide: l, inject: u, created: a, beforeMount: f, mounted: p, beforeUpdate: _, updated: A, activated: R, deactivated: j, beforeDestroy: v, beforeUnmount: b, destroyed: $, unmounted: x, render: M, renderTracked: J, renderTriggered: N, errorCaptured: P, serverPrefetch: W, expose: q, inheritAttrs: Y, components: ve, directives: ie, filters: L } = t; if (u && Fa(u, n, null), i) for (const ee in i) { const te = i[ee]; Q(te) && (n[ee] = te.bind(s)) } if (o) { const ee = o.call(s, s); re(ee) && (e.data = Ze(ee)) } if (yn = !0, r) for (const ee in r) { const te = r[ee], lt = Q(te) ? te.bind(s, s) : Q(te.get) ? te.get.bind(s, s) : Le, as = !Q(te) && Q(te.set) ? te.set.bind(s) : Le, ut = Ms({ get: lt, set: as }); Object.defineProperty(n, ee, { enumerable: !0, configurable: !0, get: () => ut.value, set: je => ut.value = je }) } if (c) for (const ee in c) li(c[ee], n, s, ee); if (l) { const ee = Q(l) ? l.call(s) : l; Reflect.ownKeys(ee).forEach(te => { fi(te, ee[te]) }) } a && Oo(a, e, "c"); function z(ee, te) { F(te) ? te.forEach(lt => ee(lt.bind(s))) : te && ee(te.bind(s)) } if (z(Sa, f), z(Xs, p), z(Ma, _), z(Ba, A), z(ti, R), z(si, j), z(ri, P), z(Oa, J), z(La, N), z(to, b), z(oi, x), z(Ha, W), F(q)) if (q.length) { const ee = e.exposed || (e.exposed = {}); q.forEach(te => { Object.defineProperty(ee, te, { get: () => s[te], set: lt => s[te] = lt }) }) } else e.exposed || (e.exposed = {}); M && e.render === Le && (e.render = M), Y != null && (e.inheritAttrs = Y), ve && (e.components = ve), ie && (e.directives = ie) } function Fa(e, t, s = Le) { F(e) && (e = kn(e)); for (const n in e) { const o = e[n]; let r; re(o) ? "default" in o ? r = Pt(o.from || n, o.default, !0) : r = Pt(o.from || n) : r = Pt(o), he(r) ? Object.defineProperty(t, n, { enumerable: !0, configurable: !0, get: () => r.value, set: i => r.value = i }) : t[n] = r } } function Oo(e, t, s) { Oe(F(e) ? e.map(n => n.bind(t.proxy)) : e.bind(t.proxy), t, s) } function li(e, t, s, n) { const o = n.includes(".") ? ei(s, n) : () => s[n]; if (ae(e)) { const r = t[e]; Q(r) && ys(o, r) } else if (Q(e)) ys(o, e.bind(s)); else if (re(e)) if (F(e)) e.forEach(r => li(r, t, s, n)); else { const r = Q(e.handler) ? e.handler.bind(s) : t[e.handler]; Q(r) && ys(o, r, e) } } function no(e) { const t = e.type, { mixins: s, extends: n } = t, { mixins: o, optionsCache: r, config: { optionMergeStrategies: i } } = e.appContext, c = r.get(t); let l; return c ? l = c : !o.length && !s && !n ? l = t : (l = {}, o.length && o.forEach(u => Ps(l, u, i, !0)), Ps(l, t, i)), re(t) && r.set(t, l), l } function Ps(e, t, s, n = !1) { const { mixins: o, extends: r } = t; r && Ps(e, r, s, !0), o && o.forEach(i => Ps(e, i, s, !0)); for (const i in t) if (!(n && i === "expose")) { const c = Da[i] || s && s[i]; e[i] = c ? c(e[i], t[i]) : t[i] } return e } const Da = { data: Uo, props: No, emits: No, methods: Kt, computed: Kt, beforeCreate: Ae, created: Ae, beforeMount: Ae, mounted: Ae, beforeUpdate: Ae, updated: Ae, beforeDestroy: Ae, beforeUnmount: Ae, destroyed: Ae, unmounted: Ae, activated: Ae, deactivated: Ae, errorCaptured: Ae, serverPrefetch: Ae, components: Kt, directives: Kt, watch: Ka, provide: Uo, inject: Ja }; function Uo(e, t) { return t ? e ? function () { return ge(Q(e) ? e.call(this, this) : e, Q(t) ? t.call(this, this) : t) } : t : e } function Ja(e, t) { return Kt(kn(e), kn(t)) } function kn(e) { if (F(e)) { const t = {}; for (let s = 0; s < e.length; s++)t[e[s]] = e[s]; return t } return e } function Ae(e, t) { return e ? [...new Set([].concat(e, t))] : t } function Kt(e, t) { return e ? ge(Object.create(null), e, t) : t } function No(e, t) { return e ? F(e) && F(t) ? [...new Set([...e, ...t])] : ge(Object.create(null), Lo(e), Lo(t ?? {})) : t } function Ka(e, t) { if (!e) return t; if (!t) return e; const s = ge(Object.create(null), e); for (const n in t) s[n] = Ae(e[n], t[n]); return s } function ui() { return { app: null, config: { isNativeTag: mc, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let Wa = 0; function Va(e, t) { return function (n, o = null) { Q(n) || (n = ge({}, n)), o != null && !re(o) && (o = null); const r = ui(), i = new WeakSet; let c = !1; const l = r.app = { _uid: Wa++, _component: n, _props: o, _container: null, _context: r, _instance: null, version: Ri, get config() { return r.config }, set config(u) { }, use(u, ...a) { return i.has(u) || (u && Q(u.install) ? (i.add(u), u.install(l, ...a)) : Q(u) && (i.add(u), u(l, ...a))), l }, mixin(u) { return r.mixins.includes(u) || r.mixins.push(u), l }, component(u, a) { return a ? (r.components[u] = a, l) : r.components[u] }, directive(u, a) { return a ? (r.directives[u] = a, l) : r.directives[u] }, mount(u, a, f) { if (!c) { const p = U(n, o); return p.appContext = r, a && t ? t(p, u) : e(p, u, f), c = !0, l._container = u, u.__vue_app__ = l, Gs(p.component) || p.component.proxy } }, unmount() { c && (e(null, l._container), delete l._container.__vue_app__) }, provide(u, a) { return r.provides[u] = a, l }, runWithContext(u) { ns = l; try { return u() } finally { ns = null } } }; return l } } let ns = null; function fi(e, t) { if (de) { let s = de.provides; const n = de.parent && de.parent.provides; n === s && (s = de.provides = Object.create(n)), s[e] = t } } function Pt(e, t, s = !1) { const n = de || pe; if (n || ns) { const o = n ? n.parent == null ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : ns._context.provides; if (o && e in o) return o[e]; if (arguments.length > 1) return s && Q(t) ? t.call(n && n.proxy) : t } } function di() { return !!(de || pe || ns) } function qa(e, t, s, n = !1) { const o = {}, r = {}; Es(r, zs, 1), e.propsDefaults = Object.create(null), hi(e, t, o, r); for (const i in e.propsOptions[0]) i in o || (o[i] = void 0); s ? e.props = n ? o : $r(o) : e.type.props ? e.props = o : e.props = r, e.attrs = r } function Ya(e, t, s, n) { const { props: o, attrs: r, vnode: { patchFlag: i } } = e, c = X(o), [l] = e.propsOptions; let u = !1; if ((n || i > 0) && !(i & 16)) { if (i & 8) { const a = e.vnode.dynamicProps; for (let f = 0; f < a.length; f++) { let p = a[f]; if (Vs(e.emitsOptions, p)) continue; const _ = t[p]; if (l) if (Z(r, p)) _ !== r[p] && (r[p] = _, u = !0); else { const A = De(p); o[A] = wn(l, c, A, _, e, !1) } else _ !== r[p] && (r[p] = _, u = !0) } } } else { hi(e, t, o, r) && (u = !0); let a; for (const f in c) (!t || !Z(t, f) && ((a = Ut(f)) === f || !Z(t, a))) && (l ? s && (s[f] !== void 0 || s[a] !== void 0) && (o[f] = wn(l, c, f, void 0, e, !0)) : delete o[f]); if (r !== c) for (const f in r) (!t || !Z(t, f)) && (delete r[f], u = !0) } u && qe(e, "set", "$attrs") } function hi(e, t, s, n) { const [o, r] = e.propsOptions; let i = !1, c; if (t) for (let l in t) { if (Wt(l)) continue; const u = t[l]; let a; o && Z(o, a = De(l)) ? !r || !r.includes(a) ? s[a] = u : (c || (c = {}))[a] = u : Vs(e.emitsOptions, l) || (!(l in n) || u !== n[l]) && (n[l] = u, i = !0) } if (r) { const l = X(s), u = c || oe; for (let a = 0; a < r.length; a++) { const f = r[a]; s[f] = wn(o, l, f, u[f], e, !Z(u, f)) } } return i } function wn(e, t, s, n, o, r) { const i = e[s]; if (i != null) { const c = Z(i, "default"); if (c && n === void 0) { const l = i.default; if (i.type !== Function && !i.skipFactory && Q(l)) { const { propsDefaults: u } = o; s in u ? n = u[s] : (Ht(o), n = u[s] = l.call(null, t), vt()) } else n = l } i[0] && (r && !c ? n = !1 : i[1] && (n === "" || n === Ut(s)) && (n = !0)) } return n } function pi(e, t, s = !1) { const n = t.propsCache, o = n.get(e); if (o) return o; const r = e.props, i = {}, c = []; let l = !1; if (!Q(e)) { const a = f => { l = !0; const [p, _] = pi(f, t, !0); ge(i, p), _ && c.push(..._) }; !s && t.mixins.length && t.mixins.forEach(a), e.extends && a(e.extends), e.mixins && e.mixins.forEach(a) } if (!r && !l) return re(e) && n.set(e, xt), xt; if (F(r)) for (let a = 0; a < r.length; a++) { const f = De(r[a]); jo(f) && (i[f] = oe) } else if (r) for (const a in r) { const f = De(a); if (jo(f)) { const p = r[a], _ = i[f] = F(p) || Q(p) ? { type: p } : ge({}, p); if (_) { const A = Fo(Boolean, _.type), R = Fo(String, _.type); _[0] = A > -1, _[1] = R < 0 || A < R, (A > -1 || Z(_, "default")) && c.push(f) } } } const u = [i, c]; return re(e) && n.set(e, u), u } function jo(e) { return e[0] !== "$" } function $o(e) { const t = e && e.toString().match(/^\s*(function|class) (\w+)/); return t ? t[2] : e === null ? "null" : "" } function Qo(e, t) { return $o(e) === $o(t) } function Fo(e, t) { return F(t) ? t.findIndex(s => Qo(s, e)) : Q(t) && Qo(t, e) ? 0 : -1 } const _i = e => e[0] === "_" || e === "$stable", oo = e => F(e) ? e.map(Re) : [Re(e)], Za = (e, t, s) => { if (t._n) return t; const n = Ye((...o) => oo(t(...o)), s); return n._c = !1, n }, gi = (e, t, s) => { const n = e._ctx; for (const o in e) { if (_i(o)) continue; const r = e[o]; if (Q(r)) t[o] = Za(o, r, n); else if (r != null) { const i = oo(r); t[o] = () => i } } }, mi = (e, t) => { const s = oo(t); e.slots.default = () => s }, Xa = (e, t) => { if (e.vnode.shapeFlag & 32) { const s = t._; s ? (e.slots = X(t), Es(t, "_", s)) : gi(t, e.slots = {}) } else e.slots = {}, t && mi(e, t); Es(e.slots, zs, 1) }, za = (e, t, s) => { const { vnode: n, slots: o } = e; let r = !0, i = oe; if (n.shapeFlag & 32) { const c = t._; c ? s && c === 1 ? r = !1 : (ge(o, t), !s && c === 1 && delete o._) : (r = !t.$stable, gi(t, o)), i = t } else t && (mi(e, t), i = { default: 1 }); if (r) for (const c in o) !_i(c) && i[c] == null && delete o[c] }; function Ss(e, t, s, n, o = !1) { if (F(e)) { e.forEach((p, _) => Ss(p, t && (F(t) ? t[_] : t), s, n, o)); return } if (It(n) && !o) return; const r = n.shapeFlag & 4 ? Gs(n.component) || n.component.proxy : n.el, i = o ? null : r, { i: c, r: l } = e, u = t && t.r, a = c.refs === oe ? c.refs = {} : c.refs, f = c.setupState; if (u != null && u !== l && (ae(u) ? (a[u] = null, Z(f, u) && (f[u] = null)) : he(u) && (u.value = null)), Q(l)) rt(l, c, 12, [i, a]); else { const p = ae(l), _ = he(l); if (p || _) { const A = () => { if (e.f) { const R = p ? Z(f, l) ? f[l] : a[l] : l.value; o ? F(R) && $n(R, r) : F(R) ? R.includes(r) || R.push(r) : p ? (a[l] = [r], Z(f, l) && (f[l] = a[l])) : (l.value = [r], e.k && (a[e.k] = l.value)) } else p ? (a[l] = i, Z(f, l) && (f[l] = i)) : _ && (l.value = i, e.k && (a[e.k] = i)) }; i ? (A.id = -1, ye(A, s)) : A() } } } let et = !1; const gs = e => /svg/.test(e.namespaceURI) && e.tagName !== "foreignObject", ms = e => e.nodeType === 8; function Ga(e) { const { mt: t, p: s, o: { patchProp: n, createText: o, nextSibling: r, parentNode: i, remove: c, insert: l, createComment: u } } = e, a = (v, b) => { if (!b.hasChildNodes()) { s(null, v, b), Ts(), b._vnode = v; return } et = !1, f(b.firstChild, v, null, null, null), Ts(), b._vnode = v, et && console.error("Hydration completed but contains mismatches.") }, f = (v, b, $, x, M, J = !1) => { const N = ms(v) && v.data === "[", P = () => R(v, b, $, x, M, N), { type: W, ref: q, shapeFlag: Y, patchFlag: ve } = b; let ie = v.nodeType; b.el = v, ve === -2 && (J = !1, b.dynamicChildren = null); let L = null; switch (W) { case St: ie !== 3 ? b.children === "" ? (l(b.el = o(""), i(v), v), L = v) : L = P() : (v.data !== b.children && (et = !0, v.data = b.children), L = r(v)); break; case Ue: ie !== 8 || N ? L = P() : L = r(v); break; case Yt: if (N && (v = r(v), ie = v.nodeType), ie === 1 || ie === 3) { L = v; const xe = !b.children.length; for (let z = 0; z < b.staticCount; z++)xe && (b.children += L.nodeType === 1 ? L.outerHTML : L.data), z === b.staticCount - 1 && (b.anchor = L), L = r(L); return N ? r(L) : L } else P(); break; case ce: N ? L = A(v, b, $, x, M, J) : L = P(); break; default: if (Y & 1) ie !== 1 || b.type.toLowerCase() !== v.tagName.toLowerCase() ? L = P() : L = p(v, b, $, x, M, J); else if (Y & 6) { b.slotScopeIds = M; const xe = i(v); if (t(b, xe, null, $, x, gs(xe), J), L = N ? j(v) : r(v), L && ms(L) && L.data === "teleport end" && (L = r(L)), It(b)) { let z; N ? (z = U(ce), z.anchor = L ? L.previousSibling : xe.lastChild) : z = v.nodeType === 3 ? Xe("") : U("div"), z.el = v, b.component.subTree = z } } else Y & 64 ? ie !== 8 ? L = P() : L = b.type.hydrate(v, b, $, x, M, J, e, _) : Y & 128 && (L = b.type.hydrate(v, b, $, x, gs(i(v)), M, J, e, f)) }return q != null && Ss(q, null, x, b), L }, p = (v, b, $, x, M, J) => { J = J || !!b.dynamicChildren; const { type: N, props: P, patchFlag: W, shapeFlag: q, dirs: Y } = b, ve = N === "input" && Y || N === "option"; if (ve || W !== -1) { if (Y && Qe(b, null, $, "created"), P) if (ve || !J || W & 48) for (const L in P) (ve && L.endsWith("value") || is(L) && !Wt(L)) && n(v, L, null, P[L], !1, void 0, $); else P.onClick && n(v, "onClick", null, P.onClick, !1, void 0, $); let ie; if ((ie = P && P.onVnodeBeforeMount) && Ce(ie, $, b), Y && Qe(b, null, $, "beforeMount"), ((ie = P && P.onVnodeMounted) || Y) && Gr(() => { ie && Ce(ie, $, b), Y && Qe(b, null, $, "mounted") }, x), q & 16 && !(P && (P.innerHTML || P.textContent))) { let L = _(v.firstChild, b, v, $, x, M, J); for (; L;) { et = !0; const xe = L; L = L.nextSibling, c(xe) } } else q & 8 && v.textContent !== b.children && (et = !0, v.textContent = b.children) } return v.nextSibling }, _ = (v, b, $, x, M, J, N) => { N = N || !!b.dynamicChildren; const P = b.children, W = P.length; for (let q = 0; q < W; q++) { const Y = N ? P[q] : P[q] = Re(P[q]); if (v) v = f(v, Y, x, M, J, N); else { if (Y.type === St && !Y.children) continue; et = !0, s(null, Y, $, null, x, M, gs($), J) } } return v }, A = (v, b, $, x, M, J) => { const { slotScopeIds: N } = b; N && (M = M ? M.concat(N) : N); const P = i(v), W = _(r(v), b, P, $, x, M, J); return W && ms(W) && W.data === "]" ? r(b.anchor = W) : (et = !0, l(b.anchor = u("]"), P, W), W) }, R = (v, b, $, x, M, J) => { if (et = !0, b.el = null, J) { const W = j(v); for (; ;) { const q = r(v); if (q && q !== W) c(q); else break } } const N = r(v), P = i(v); return c(v), s(null, b, P, N, $, x, gs(P), M), N }, j = v => { let b = 0; for (; v;)if (v = r(v), v && ms(v) && (v.data === "[" && b++, v.data === "]")) { if (b === 0) return r(v); b-- } return v }; return [a, f] } const ye = Gr; function el(e) { return vi(e) } function tl(e) { return vi(e, Ga) } function vi(e, t) { const s = _n(); s.__VUE__ = !0; const { insert: n, remove: o, patchProp: r, createElement: i, createText: c, createComment: l, setText: u, setElementText: a, parentNode: f, nextSibling: p, setScopeId: _ = Le, insertStaticContent: A } = e, R = (d, h, g, k = null, y = null, C = null, I = !1, E = null, T = !!h.dynamicChildren) => { if (d === h) return; d && !nt(d, h) && (k = ls(d), je(d, y, C, !0), d = null), h.patchFlag === -2 && (T = !1, h.dynamicChildren = null); const { type: w, ref: B, shapeFlag: S } = h; switch (w) { case St: j(d, h, g, k); break; case Ue: v(d, h, g, k); break; case Yt: d == null && b(h, g, k, I); break; case ce: ve(d, h, g, k, y, C, I, E, T); break; default: S & 1 ? M(d, h, g, k, y, C, I, E, T) : S & 6 ? ie(d, h, g, k, y, C, I, E, T) : (S & 64 || S & 128) && w.process(d, h, g, k, y, C, I, E, T, yt) }B != null && y && Ss(B, d && d.ref, C, h || d, !h) }, j = (d, h, g, k) => { if (d == null) n(h.el = c(h.children), g, k); else { const y = h.el = d.el; h.children !== d.children && u(y, h.children) } }, v = (d, h, g, k) => { d == null ? n(h.el = l(h.children || ""), g, k) : h.el = d.el }, b = (d, h, g, k) => { [d.el, d.anchor] = A(d.children, h, g, k, d.el, d.anchor) }, $ = ({ el: d, anchor: h }, g, k) => { let y; for (; d && d !== h;)y = p(d), n(d, g, k), d = y; n(h, g, k) }, x = ({ el: d, anchor: h }) => { let g; for (; d && d !== h;)g = p(d), o(d), d = g; o(h) }, M = (d, h, g, k, y, C, I, E, T) => { I = I || h.type === "svg", d == null ? J(h, g, k, y, C, I, E, T) : W(d, h, y, C, I, E, T) }, J = (d, h, g, k, y, C, I, E) => { let T, w; const { type: B, props: S, shapeFlag: H, transition: D, dirs: V } = d; if (T = d.el = i(d.type, C, S && S.is, S), H & 8 ? a(T, d.children) : H & 16 && P(d.children, T, null, k, y, C && B !== "foreignObject", I, E), V && Qe(d, null, k, "created"), N(T, d, d.scopeId, I, k), S) { for (const G in S) G !== "value" && !Wt(G) && r(T, G, null, S[G], C, d.children, k, y, We); "value" in S && r(T, "value", null, S.value), (w = S.onVnodeBeforeMount) && Ce(w, k, d) } V && Qe(d, null, k, "beforeMount"); const se = (!y || y && !y.pendingBranch) && D && !D.persisted; se && D.beforeEnter(T), n(T, h, g), ((w = S && S.onVnodeMounted) || se || V) && ye(() => { w && Ce(w, k, d), se && D.enter(T), V && Qe(d, null, k, "mounted") }, y) }, N = (d, h, g, k, y) => { if (g && _(d, g), k) for (let C = 0; C < k.length; C++)_(d, k[C]); if (y) { let C = y.subTree; if (h === C) { const I = y.vnode; N(d, I, I.scopeId, I.slotScopeIds, y.parent) } } }, P = (d, h, g, k, y, C, I, E, T = 0) => { for (let w = T; w < d.length; w++) { const B = d[w] = E ? st(d[w]) : Re(d[w]); R(null, B, h, g, k, y, C, I, E) } }, W = (d, h, g, k, y, C, I) => { const E = h.el = d.el; let { patchFlag: T, dynamicChildren: w, dirs: B } = h; T |= d.patchFlag & 16; const S = d.props || oe, H = h.props || oe; let D; g && ft(g, !1), (D = H.onVnodeBeforeUpdate) && Ce(D, g, h, d), B && Qe(h, d, g, "beforeUpdate"), g && ft(g, !0); const V = y && h.type !== "foreignObject"; if (w ? q(d.dynamicChildren, w, E, g, k, V, C) : I || te(d, h, E, null, g, k, V, C, !1), T > 0) { if (T & 16) Y(E, h, S, H, g, k, y); else if (T & 2 && S.class !== H.class && r(E, "class", null, H.class, y), T & 4 && r(E, "style", S.style, H.style, y), T & 8) { const se = h.dynamicProps; for (let G = 0; G < se.length; G++) { const fe = se[G], Pe = S[fe], kt = H[fe]; (kt !== Pe || fe === "value") && r(E, fe, Pe, kt, y, d.children, g, k, We) } } T & 1 && d.children !== h.children && a(E, h.children) } else !I && w == null && Y(E, h, S, H, g, k, y); ((D = H.onVnodeUpdated) || B) && ye(() => { D && Ce(D, g, h, d), B && Qe(h, d, g, "updated") }, k) }, q = (d, h, g, k, y, C, I) => { for (let E = 0; E < h.length; E++) { const T = d[E], w = h[E], B = T.el && (T.type === ce || !nt(T, w) || T.shapeFlag & 70) ? f(T.el) : g; R(T, w, B, null, k, y, C, I, !0) } }, Y = (d, h, g, k, y, C, I) => { if (g !== k) { if (g !== oe) for (const E in g) !Wt(E) && !(E in k) && r(d, E, g[E], null, I, h.children, y, C, We); for (const E in k) { if (Wt(E)) continue; const T = k[E], w = g[E]; T !== w && E !== "value" && r(d, E, w, T, I, h.children, y, C, We) } "value" in k && r(d, "value", g.value, k.value) } }, ve = (d, h, g, k, y, C, I, E, T) => { const w = h.el = d ? d.el : c(""), B = h.anchor = d ? d.anchor : c(""); let { patchFlag: S, dynamicChildren: H, slotScopeIds: D } = h; D && (E = E ? E.concat(D) : D), d == null ? (n(w, g, k), n(B, g, k), P(h.children, g, B, y, C, I, E, T)) : S > 0 && S & 64 && H && d.dynamicChildren ? (q(d.dynamicChildren, H, g, y, C, I, E), (h.key != null || y && h === y.subTree) && ro(d, h, !0)) : te(d, h, g, B, y, C, I, E, T) }, ie = (d, h, g, k, y, C, I, E, T) => { h.slotScopeIds = E, d == null ? h.shapeFlag & 512 ? y.ctx.activate(h, g, k, I, T) : L(h, g, k, y, C, I, T) : xe(d, h, T) }, L = (d, h, g, k, y, C, I) => { const E = d.component = fl(d, k, y); if (eo(d) && (E.ctx.renderer = yt), dl(E), E.asyncDep) { if (y && y.registerDep(E, z), !d.el) { const T = E.subTree = U(Ue); v(null, T, h, g) } return } z(E, d, h, g, y, C, I) }, xe = (d, h, g) => { const k = h.component = d.component; if (va(d, h, g)) if (k.asyncDep && !k.asyncResolved) { ee(k, h, g); return } else k.next = h, da(k.update), k.update(); else h.el = d.el, k.vnode = h }, z = (d, h, g, k, y, C, I) => { const E = () => { if (d.isMounted) { let { next: B, bu: S, u: H, parent: D, vnode: V } = d, se = B, G; ft(d, !1), B ? (B.el = V.el, ee(d, B, I)) : B = V, S && on(S), (G = B.props && B.props.onVnodeBeforeUpdate) && Ce(G, D, B, V), ft(d, !0); const fe = rn(d), Pe = d.subTree; d.subTree = fe, R(Pe, fe, f(Pe.el), ls(Pe), d, y, C), B.el = fe.el, se === null && Xn(d, fe.el), H && ye(H, y), (G = B.props && B.props.onVnodeUpdated) && ye(() => Ce(G, D, B, V), y) } else { let B; const { el: S, props: H } = h, { bm: D, m: V, parent: se } = d, G = It(h); if (ft(d, !1), D && on(D), !G && (B = H && H.onVnodeBeforeMount) && Ce(B, se, h), ft(d, !0), S && sn) { const fe = () => { d.subTree = rn(d), sn(S, d.subTree, d, y, null) }; G ? h.type.__asyncLoader().then(() => !d.isUnmounted && fe()) : fe() } else { const fe = d.subTree = rn(d); R(null, fe, g, k, d, y, C), h.el = fe.el } if (V && ye(V, y), !G && (B = H && H.onVnodeMounted)) { const fe = h; ye(() => Ce(B, se, fe), y) } (h.shapeFlag & 256 || se && It(se.vnode) && se.vnode.shapeFlag & 256) && d.a && ye(d.a, y), d.isMounted = !0, h = g = k = null } }, T = d.effect = new Jn(E, () => Ws(w), d.scope), w = d.update = () => T.run(); w.id = d.uid, ft(d, !0), w() }, ee = (d, h, g) => { h.component = d; const k = d.vnode.props; d.vnode = h, d.next = null, Ya(d, h.props, k, g), za(d, h.children, g), Nt(), Po(), jt() }, te = (d, h, g, k, y, C, I, E, T = !1) => { const w = d && d.children, B = d ? d.shapeFlag : 0, S = h.children, { patchFlag: H, shapeFlag: D } = h; if (H > 0) { if (H & 128) { as(w, S, g, k, y, C, I, E, T); return } else if (H & 256) { lt(w, S, g, k, y, C, I, E, T); return } } D & 8 ? (B & 16 && We(w, y, C), S !== w && a(g, S)) : B & 16 ? D & 16 ? as(w, S, g, k, y, C, I, E, T) : We(w, y, C, !0) : (B & 8 && a(g, ""), D & 16 && P(S, g, k, y, C, I, E, T)) }, lt = (d, h, g, k, y, C, I, E, T) => { d = d || xt, h = h || xt; const w = d.length, B = h.length, S = Math.min(w, B); let H; for (H = 0; H < S; H++) { const D = h[H] = T ? st(h[H]) : Re(h[H]); R(d[H], D, g, null, y, C, I, E, T) } w > B ? We(d, y, C, !0, !1, S) : P(h, g, k, y, C, I, E, T, S) }, as = (d, h, g, k, y, C, I, E, T) => { let w = 0; const B = h.length; let S = d.length - 1, H = B - 1; for (; w <= S && w <= H;) { const D = d[w], V = h[w] = T ? st(h[w]) : Re(h[w]); if (nt(D, V)) R(D, V, g, null, y, C, I, E, T); else break; w++ } for (; w <= S && w <= H;) { const D = d[S], V = h[H] = T ? st(h[H]) : Re(h[H]); if (nt(D, V)) R(D, V, g, null, y, C, I, E, T); else break; S--, H-- } if (w > S) { if (w <= H) { const D = H + 1, V = D < B ? h[D].el : k; for (; w <= H;)R(null, h[w] = T ? st(h[w]) : Re(h[w]), g, V, y, C, I, E, T), w++ } } else if (w > H) for (; w <= S;)je(d[w], y, C, !0), w++; else { const D = w, V = w, se = new Map; for (w = V; w <= H; w++) { const Ee = h[w] = T ? st(h[w]) : Re(h[w]); Ee.key != null && se.set(Ee.key, w) } let G, fe = 0; const Pe = H - V + 1; let kt = !1, vo = 0; const Dt = new Array(Pe); for (w = 0; w < Pe; w++)Dt[w] = 0; for (w = D; w <= S; w++) { const Ee = d[w]; if (fe >= Pe) { je(Ee, y, C, !0); continue } let $e; if (Ee.key != null) $e = se.get(Ee.key); else for (G = V; G <= H; G++)if (Dt[G - V] === 0 && nt(Ee, h[G])) { $e = G; break } $e === void 0 ? je(Ee, y, C, !0) : (Dt[$e - V] = w + 1, $e >= vo ? vo = $e : kt = !0, R(Ee, h[$e], g, null, y, C, I, E, T), fe++) } const Ao = kt ? sl(Dt) : xt; for (G = Ao.length - 1, w = Pe - 1; w >= 0; w--) { const Ee = V + w, $e = h[Ee], bo = Ee + 1 < B ? h[Ee + 1].el : k; Dt[w] === 0 ? R(null, $e, g, bo, y, C, I, E, T) : kt && (G < 0 || w !== Ao[G] ? ut($e, g, bo, 2) : G--) } } }, ut = (d, h, g, k, y = null) => { const { el: C, type: I, transition: E, children: T, shapeFlag: w } = d; if (w & 6) { ut(d.component.subTree, h, g, k); return } if (w & 128) { d.suspense.move(h, g, k); return } if (w & 64) { I.move(d, h, g, yt); return } if (I === ce) { n(C, h, g); for (let S = 0; S < T.length; S++)ut(T[S], h, g, k); n(d.anchor, h, g); return } if (I === Yt) { $(d, h, g); return } if (k !== 2 && w & 1 && E) if (k === 0) E.beforeEnter(C), n(C, h, g), ye(() => E.enter(C), y); else { const { leave: S, delayLeave: H, afterLeave: D } = E, V = () => n(C, h, g), se = () => { S(C, () => { V(), D && D() }) }; H ? H(C, V, se) : se() } else n(C, h, g) }, je = (d, h, g, k = !1, y = !1) => { const { type: C, props: I, ref: E, children: T, dynamicChildren: w, shapeFlag: B, patchFlag: S, dirs: H } = d; if (E != null && Ss(E, null, g, d, !0), B & 256) { h.ctx.deactivate(d); return } const D = B & 1 && H, V = !It(d); let se; if (V && (se = I && I.onVnodeBeforeUnmount) && Ce(se, h, d), B & 6) gc(d.component, g, k); else { if (B & 128) { d.suspense.unmount(g, k); return } D && Qe(d, null, h, "beforeUnmount"), B & 64 ? d.type.remove(d, h, g, y, yt, k) : w && (C !== ce || S > 0 && S & 64) ? We(w, h, g, !1, !0) : (C === ce && S & 384 || !y && B & 16) && We(T, h, g), k && go(d) } (V && (se = I && I.onVnodeUnmounted) || D) && ye(() => { se && Ce(se, h, d), D && Qe(d, null, h, "unmounted") }, g) }, go = d => { const { type: h, el: g, anchor: k, transition: y } = d; if (h === ce) { _c(g, k); return } if (h === Yt) { x(d); return } const C = () => { o(g), y && !y.persisted && y.afterLeave && y.afterLeave() }; if (d.shapeFlag & 1 && y && !y.persisted) { const { leave: I, delayLeave: E } = y, T = () => I(g, C); E ? E(d.el, C, T) : T() } else C() }, _c = (d, h) => { let g; for (; d !== h;)g = p(d), o(d), d = g; o(h) }, gc = (d, h, g) => { const { bum: k, scope: y, update: C, subTree: I, um: E } = d; k && on(k), y.stop(), C && (C.active = !1, je(I, d, h, g)), E && ye(E, h), ye(() => { d.isUnmounted = !0 }, h), h && h.pendingBranch && !h.isUnmounted && d.asyncDep && !d.asyncResolved && d.suspenseId === h.pendingId && (h.deps--, h.deps === 0 && h.resolve()) }, We = (d, h, g, k = !1, y = !1, C = 0) => { for (let I = C; I < d.length; I++)je(d[I], h, g, k, y) }, ls = d => d.shapeFlag & 6 ? ls(d.component.subTree) : d.shapeFlag & 128 ? d.suspense.next() : p(d.anchor || d.el), mo = (d, h, g) => { d == null ? h._vnode && je(h._vnode, null, null, !0) : R(h._vnode || null, d, h, null, null, null, g), Po(), Ts(), h._vnode = d }, yt = { p: R, um: je, m: ut, r: go, mt: L, mc: P, pc: te, pbc: q, n: ls, o: e }; let tn, sn; return t && ([tn, sn] = t(yt)), { render: mo, hydrate: tn, createApp: Va(mo, tn) } } function ft({ effect: e, update: t }, s) { e.allowRecurse = t.allowRecurse = s } function ro(e, t, s = !1) { const n = e.children, o = t.children; if (F(n) && F(o)) for (let r = 0; r < n.length; r++) { const i = n[r]; let c = o[r]; c.shapeFlag & 1 && !c.dynamicChildren && ((c.patchFlag <= 0 || c.patchFlag === 32) && (c = o[r] = st(o[r]), c.el = i.el), s || ro(i, c)), c.type === St && (c.el = i.el) } } function sl(e) { const t = e.slice(), s = [0]; let n, o, r, i, c; const l = e.length; for (n = 0; n < l; n++) { const u = e[n]; if (u !== 0) { if (o = s[s.length - 1], e[o] < u) { t[n] = o, s.push(n); continue } for (r = 0, i = s.length - 1; r < i;)c = r + i >> 1, e[s[c]] < u ? r = c + 1 : i = c; u < e[s[r]] && (r > 0 && (t[n] = s[r - 1]), s[r] = n) } } for (r = s.length, i = s[r - 1]; r-- > 0;)s[r] = i, i = t[i]; return s } const nl = e => e.__isTeleport, qt = e => e && (e.disabled || e.disabled === ""), Do = e => typeof SVGElement < "u" && e instanceof SVGElement, xn = (e, t) => { const s = e && e.to; return ae(s) ? t ? t(s) : null : s }, ol = { __isTeleport: !0, process(e, t, s, n, o, r, i, c, l, u) { const { mc: a, pc: f, pbc: p, o: { insert: _, querySelector: A, createText: R, createComment: j } } = u, v = qt(t.props); let { shapeFlag: b, children: $, dynamicChildren: x } = t; if (e == null) { const M = t.el = R(""), J = t.anchor = R(""); _(M, s, n), _(J, s, n); const N = t.target = xn(t.props, A), P = t.targetAnchor = R(""); N && (_(P, N), i = i || Do(N)); const W = (q, Y) => { b & 16 && a($, q, Y, o, r, i, c, l) }; v ? W(s, J) : N && W(N, P) } else { t.el = e.el; const M = t.anchor = e.anchor, J = t.target = e.target, N = t.targetAnchor = e.targetAnchor, P = qt(e.props), W = P ? s : J, q = P ? M : N; if (i = i || Do(J), x ? (p(e.dynamicChildren, x, W, o, r, i, c), ro(e, t, !0)) : l || f(e, t, W, q, o, r, i, c, !1), v) P ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : vs(t, s, M, u, 1); else if ((t.props && t.props.to) !== (e.props && e.props.to)) { const Y = t.target = xn(t.props, A); Y && vs(t, Y, null, u, 0) } else P && vs(t, J, N, u, 1) } Ai(t) }, remove(e, t, s, n, { um: o, o: { remove: r } }, i) { const { shapeFlag: c, children: l, anchor: u, targetAnchor: a, target: f, props: p } = e; if (f && r(a), i && r(u), c & 16) { const _ = i || !qt(p); for (let A = 0; A < l.length; A++) { const R = l[A]; o(R, t, s, _, !!R.dynamicChildren) } } }, move: vs, hydrate: rl }; function vs(e, t, s, { o: { insert: n }, m: o }, r = 2) { r === 0 && n(e.targetAnchor, t, s); const { el: i, anchor: c, shapeFlag: l, children: u, props: a } = e, f = r === 2; if (f && n(i, t, s), (!f || qt(a)) && l & 16) for (let p = 0; p < u.length; p++)o(u[p], t, s, 2); f && n(c, t, s) } function rl(e, t, s, n, o, r, { o: { nextSibling: i, parentNode: c, querySelector: l } }, u) { const a = t.target = xn(t.props, l); if (a) { const f = a._lpa || a.firstChild; if (t.shapeFlag & 16) if (qt(t.props)) t.anchor = u(i(e), t, c(e), s, n, o, r), t.targetAnchor = f; else { t.anchor = i(e); let p = f; for (; p;)if (p = i(p), p && p.nodeType === 8 && p.data === "teleport anchor") { t.targetAnchor = p, a._lpa = t.targetAnchor && i(t.targetAnchor); break } u(f, t, a, s, n, o, r) } Ai(t) } return t.anchor && i(t.anchor) } const il = ol; function Ai(e) { const t = e.ctx; if (t && t.ut) { let s = e.children[0].el; for (; s && s !== e.targetAnchor;)s.nodeType === 1 && s.setAttribute("data-v-owner", t.uid), s = s.nextSibling; t.ut() } } const ce = Symbol.for("v-fgt"), St = Symbol.for("v-txt"), Ue = Symbol.for("v-cmt"), Yt = Symbol.for("v-stc"), Zt = []; let Te = null; function O(e = !1) { Zt.push(Te = e ? null : []) } function bi() { Zt.pop(), Te = Zt[Zt.length - 1] || null } let Mt = 1; function Jo(e) { Mt += e } function yi(e) { return e.dynamicChildren = Mt > 0 ? Te || xt : null, bi(), Mt > 0 && Te && Te.push(e), e } function K(e, t, s, n, o, r) { return yi(m(e, t, s, n, o, r, !0)) } function He(e, t, s, n, o) { return yi(U(e, t, s, n, o, !0)) } function os(e) { return e ? e.__v_isVNode === !0 : !1 } function nt(e, t) { return e.type === t.type && e.key === t.key } const zs = "__vInternal", ki = ({ key: e }) => e ?? null, ks = ({ ref: e, ref_key: t, ref_for: s }) => (typeof e == "number" && (e = "" + e), e != null ? ae(e) || he(e) || Q(e) ? { i: pe, r: e, k: t, f: !!s } : e : null); function m(e, t = null, s = null, n = 0, o = null, r = e === ce ? 0 : 1, i = !1, c = !1) { const l = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && ki(t), ref: t && ks(t), scopeId: qs, slotScopeIds: null, children: s, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag: r, patchFlag: n, dynamicProps: o, dynamicChildren: null, appContext: null, ctx: pe }; return c ? (io(l, s), r & 128 && e.normalize(l)) : s && (l.shapeFlag |= ae(s) ? 8 : 16), Mt > 0 && !i && Te && (l.patchFlag > 0 || r & 6) && l.patchFlag !== 32 && Te.push(l), l } const U = cl; function cl(e, t = null, s = null, n = 0, o = null, r = !1) { if ((!e || e === ii) && (e = Ue), os(e)) { const c = Bt(e, t, !0); return s && io(c, s), Mt > 0 && !r && Te && (c.shapeFlag & 6 ? Te[Te.indexOf(e)] = c : Te.push(c)), c.patchFlag |= -2, c } if (ml(e) && (e = e.__vccOpts), t) { t = wi(t); let { class: c, style: l } = t; c && !ae(c) && (t.class = _e(c)), re(l) && (Fr(l) && !F(l) && (l = ge({}, l)), t.style = Js(l)) } const i = ae(e) ? 1 : Aa(e) ? 128 : nl(e) ? 64 : re(e) ? 4 : Q(e) ? 2 : 0; return m(e, t, s, n, o, i, r, !0) } function wi(e) { return e ? Fr(e) || zs in e ? ge({}, e) : e : null } function Bt(e, t, s = !1) { const { props: n, ref: o, patchFlag: r, children: i } = e, c = t ? al(n || {}, t) : n; return { __v_isVNode: !0, __v_skip: !0, type: e.type, props: c, key: c && ki(c), ref: t && t.ref ? s && o ? F(o) ? o.concat(ks(t)) : [o, ks(t)] : ks(t) : o, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: i, target: e.target, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== ce ? r === -1 ? 16 : r | 16 : r, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: e.transition, component: e.component, suspense: e.suspense, ssContent: e.ssContent && Bt(e.ssContent), ssFallback: e.ssFallback && Bt(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce } } function Xe(e = " ", t = 0) { return U(St, null, e, t) } function we(e, t) { const s = U(Yt, null, e); return s.staticCount = t, s } function rs(e = "", t = !1) { return t ? (O(), He(Ue, null, e)) : U(Ue, null, e) } function Re(e) { return e == null || typeof e == "boolean" ? U(Ue) : F(e) ? U(ce, null, e.slice()) : typeof e == "object" ? st(e) : U(St, null, String(e)) } function st(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : Bt(e) } function io(e, t) { let s = 0; const { shapeFlag: n } = e; if (t == null) t = null; else if (F(t)) s = 16; else if (typeof t == "object") if (n & 65) { const o = t.default; o && (o._c && (o._d = !1), io(e, o()), o._c && (o._d = !0)); return } else { s = 32; const o = t._; !o && !(zs in t) ? t._ctx = pe : o === 3 && pe && (pe.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else Q(t) ? (t = { default: t, _ctx: pe }, s = 32) : (t = String(t), n & 64 ? (s = 16, t = [Xe(t)]) : s = 8); e.children = t, e.shapeFlag |= s } function al(...e) { const t = {}; for (let s = 0; s < e.length; s++) { const n = e[s]; for (const o in n) if (o === "class") t.class !== n.class && (t.class = _e([t.class, n.class])); else if (o === "style") t.style = Js([t.style, n.style]); else if (is(o)) { const r = t[o], i = n[o]; i && r !== i && !(F(r) && r.includes(i)) && (t[o] = r ? [].concat(r, i) : i) } else o !== "" && (t[o] = n[o]) } return t } function Ce(e, t, s, n = null) { Oe(e, t, 7, [s, n]) } const ll = ui(); let ul = 0; function fl(e, t, s) { const n = e.type, o = (t ? t.appContext : e.appContext) || ll, r = { uid: ul++, vnode: e, type: n, parent: t, appContext: o, root: null, next: null, subTree: null, effect: null, update: null, scope: new Ir(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(o.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: pi(n, o), emitsOptions: zr(n, o), emit: null, emitted: null, propsDefaults: oe, inheritAttrs: n.inheritAttrs, ctx: oe, data: oe, props: oe, attrs: oe, slots: oe, refs: oe, setupState: oe, setupContext: null, attrsProxy: null, slotsProxy: null, suspense: s, suspenseId: s ? s.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return r.ctx = { _: r }, r.root = t ? t.root : r, r.emit = pa.bind(null, r), e.ce && e.ce(r), r } let de = null; const xi = () => de || pe; let co, wt, Ko = "__VUE_INSTANCE_SETTERS__"; (wt = _n()[Ko]) || (wt = _n()[Ko] = []), wt.push(e => de = e), co = e => { wt.length > 1 ? wt.forEach(t => t(e)) : wt[0](e) }; const Ht = e => { co(e), e.scope.on() }, vt = () => { de && de.scope.off(), co(null) }; function Ei(e) { return e.vnode.shapeFlag & 4 } let Lt = !1; function dl(e, t = !1) { Lt = t; const { props: s, children: n } = e.vnode, o = Ei(e); qa(e, s, o, t), Xa(e, n); const r = o ? hl(e, t) : void 0; return Lt = !1, r } function hl(e, t) { const s = e.type; e.accessCache = Object.create(null), e.proxy = Dr(new Proxy(e.ctx, $a)); const { setup: n } = s; if (n) { const o = e.setupContext = n.length > 1 ? _l(e) : null; Ht(e), Nt(); const r = rt(n, e, 0, [e.props, o]); if (jt(), vt(), xr(r)) { if (r.then(vt, vt), t) return r.then(i => { En(e, i, t) }).catch(i => { $t(i, e, 0) }); e.asyncDep = r } else En(e, r, t) } else Ci(e, t) } function En(e, t, s) { Q(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : re(t) && (e.setupState = Vr(t)), Ci(e, s) } let Wo; function Ci(e, t, s) { const n = e.type; if (!e.render) { if (!t && Wo && !n.render) { const o = n.template || no(e).template; if (o) { const { isCustomElement: r, compilerOptions: i } = e.appContext.config, { delimiters: c, compilerOptions: l } = n, u = ge(ge({ isCustomElement: r, delimiters: c }, i), l); n.render = Wo(o, u) } } e.render = n.render || Le } { Ht(e), Nt(); try { Qa(e) } finally { jt(), vt() } } } function pl(e) { return e.attrsProxy || (e.attrsProxy = new Proxy(e.attrs, { get(t, s) { return ke(e, "get", "$attrs"), t[s] } })) } function _l(e) { const t = s => { e.exposed = s || {} }; return { get attrs() { return pl(e) }, slots: e.slots, emit: e.emit, expose: t } } function Gs(e) { if (e.exposed) return e.exposeProxy || (e.exposeProxy = new Proxy(Vr(Dr(e.exposed)), { get(t, s) { if (s in t) return t[s]; if (s in Vt) return Vt[s](e) }, has(t, s) { return s in t || s in Vt } })) } function gl(e, t = !0) { return Q(e) ? e.displayName || e.name : e.name || t && e.__name } function ml(e) { return Q(e) && "__vccOpts" in e } const Ms = (e, t) => la(e, t, Lt); function Cn(e, t, s) { const n = arguments.length; return n === 2 ? re(t) && !F(t) ? os(t) ? U(e, null, [t]) : U(e, t) : U(e, null, t) : (n > 3 ? s = Array.prototype.slice.call(arguments, 2) : n === 3 && os(s) && (s = [s]), U(e, t, s)) } const vl = Symbol.for("v-scx"), Al = () => Pt(vl), Ri = "3.3.6", bl = "http://www.w3.org/2000/svg", _t = typeof document < "u" ? document : null, Vo = _t && _t.createElement("template"), yl = { insert: (e, t, s) => { t.insertBefore(e, s || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, s, n) => { const o = t ? _t.createElementNS(bl, e) : _t.createElement(e, s ? { is: s } : void 0); return e === "select" && n && n.multiple != null && o.setAttribute("multiple", n.multiple), o }, createText: e => _t.createTextNode(e), createComment: e => _t.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => _t.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, s, n, o, r) { const i = s ? s.previousSibling : t.lastChild; if (o && (o === r || o.nextSibling)) for (; t.insertBefore(o.cloneNode(!0), s), !(o === r || !(o = o.nextSibling));); else { Vo.innerHTML = n ? `<svg>${e}</svg>` : e; const c = Vo.content; if (n) { const l = c.firstChild; for (; l.firstChild;)c.appendChild(l.firstChild); c.removeChild(l) } t.insertBefore(c, s) } return [i ? i.nextSibling : t.firstChild, s ? s.previousSibling : t.lastChild] } }, kl = Symbol("_vtc"); function wl(e, t, s) { const n = e[kl]; n && (t = (t ? [t, ...n] : [...n]).join(" ")), t == null ? e.removeAttribute("class") : s ? e.setAttribute("class", t) : e.className = t } const xl = Symbol("_vod"); function El(e, t, s) { const n = e.style, o = ae(s); if (s && !o) { if (t && !ae(t)) for (const r in t) s[r] == null && Rn(n, r, ""); for (const r in s) Rn(n, r, s[r]) } else { const r = n.display; o ? t !== s && (n.cssText = s) : t && e.removeAttribute("style"), xl in e && (n.display = r) } } const qo = /\s*!important$/; function Rn(e, t, s) { if (F(s)) s.forEach(n => Rn(e, t, n)); else if (s == null && (s = ""), t.startsWith("--")) e.setProperty(t, s); else { const n = Cl(e, t); qo.test(s) ? e.setProperty(Ut(n), s.replace(qo, ""), "important") : e[n] = s } } const Yo = ["Webkit", "Moz", "ms"], ln = {}; function Cl(e, t) { const s = ln[t]; if (s) return s; let n = De(t); if (n !== "filter" && n in e) return ln[t] = n; n = Ds(n); for (let o = 0; o < Yo.length; o++) { const r = Yo[o] + n; if (r in e) return ln[t] = r } return t } const Zo = "http://www.w3.org/1999/xlink"; function Rl(e, t, s, n, o) { if (n && t.startsWith("xlink:")) s == null ? e.removeAttributeNS(Zo, t.slice(6, t.length)) : e.setAttributeNS(Zo, t, s); else { const r = Sc(t); s == null || r && !Rr(s) ? e.removeAttribute(t) : e.setAttribute(t, r ? "" : s) } } function Tl(e, t, s, n, o, r, i) { if (t === "innerHTML" || t === "textContent") { n && i(n, o, r), e[t] = s ?? ""; return } const c = e.tagName; if (t === "value" && c !== "PROGRESS" && !c.includes("-")) { e._value = s; const u = c === "OPTION" ? e.getAttribute("value") : e.value, a = s ?? ""; u !== a && (e.value = a), s == null && e.removeAttribute(t); return } let l = !1; if (s === "" || s == null) { const u = typeof e[t]; u === "boolean" ? s = Rr(s) : s == null && u === "string" ? (s = "", l = !0) : u === "number" && (s = 0, l = !0) } try { e[t] = s } catch { } l && e.removeAttribute(t) } function Il(e, t, s, n) { e.addEventListener(t, s, n) } function Pl(e, t, s, n) { e.removeEventListener(t, s, n) } const Xo = Symbol("_vei"); function Sl(e, t, s, n, o = null) { const r = e[Xo] || (e[Xo] = {}), i = r[t]; if (n && i) i.value = n; else { const [c, l] = Ml(t); if (n) { const u = r[t] = Ll(n, o); Il(e, c, u, l) } else i && (Pl(e, c, i, l), r[t] = void 0) } } const zo = /(?:Once|Passive|Capture)$/; function Ml(e) { let t; if (zo.test(e)) { t = {}; let n; for (; n = e.match(zo);)e = e.slice(0, e.length - n[0].length), t[n[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : Ut(e.slice(2)), t] } let un = 0; const Bl = Promise.resolve(), Hl = () => un || (Bl.then(() => un = 0), un = Date.now()); function Ll(e, t) { const s = n => { if (!n._vts) n._vts = Date.now(); else if (n._vts <= s.attached) return; Oe(Ol(n, s.value), t, 5, [n]) }; return s.value = e, s.attached = Hl(), s } function Ol(e, t) { if (F(t)) { const s = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { s.call(e), e._stopped = !0 }, t.map(n => o => !o._stopped && n && n(o)) } else return t } const Go = /^on[a-z]/, Ul = (e, t, s, n, o = !1, r, i, c, l) => { t === "class" ? wl(e, n, o) : t === "style" ? El(e, s, n) : is(t) ? jn(t) || Sl(e, t, s, n, i) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : Nl(e, t, n, o)) ? Tl(e, t, n, r, i, c, l) : (t === "true-value" ? e._trueValue = n : t === "false-value" && (e._falseValue = n), Rl(e, t, n, o)) }; function Nl(e, t, s, n) { return n ? !!(t === "innerHTML" || t === "textContent" || t in e && Go.test(t) && Q(s)) : t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA" || Go.test(t) && ae(s) ? !1 : t in e } const Ti = ge({ patchProp: Ul }, yl); let Xt, er = !1; function jl() { return Xt || (Xt = el(Ti)) } function $l() { return Xt = er ? Xt : tl(Ti), er = !0, Xt } const Ql = (...e) => { const t = jl().createApp(...e), { mount: s } = t; return t.mount = n => { const o = Ii(n); if (!o) return; const r = t._component; !Q(r) && !r.render && !r.template && (r.template = o.innerHTML), o.innerHTML = ""; const i = s(o, !1, o instanceof SVGElement); return o instanceof Element && (o.removeAttribute("v-cloak"), o.setAttribute("data-v-app", "")), i }, t }, Fl = (...e) => { const t = $l().createApp(...e), { mount: s } = t; return t.mount = n => { const o = Ii(n); if (o) return s(o, !0, o instanceof SVGElement) }, t }; function Ii(e) { return ae(e) ? document.querySelector(e) : e } const Dl = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, Jl = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, Kl = /^\s*["[{]|^\s*-?\d[\d.]{0,14}\s*$/; function Wl(e, t) { if (e === "__proto__" || e === "constructor" && t && typeof t == "object" && "prototype" in t) { Vl(e); return } return t } function Vl(e) { console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`) } function Bs(e, t = {}) { if (typeof e != "string") return e; const s = e.trim(); if (e[0] === '"' && e[e.length - 1] === '"') return s.slice(1, -1); if (s.length <= 9) { const n = s.toLowerCase(); if (n === "true") return !0; if (n === "false") return !1; if (n === "undefined") return; if (n === "null") return null; if (n === "nan") return Number.NaN; if (n === "infinity") return Number.POSITIVE_INFINITY; if (n === "-infinity") return Number.NEGATIVE_INFINITY } if (!Kl.test(e)) { if (t.strict) throw new SyntaxError("[destr] Invalid JSON"); return e } try { if (Dl.test(e) || Jl.test(e)) { if (t.strict) throw new Error("[destr] Possible prototype pollution"); return JSON.parse(e, Wl) } return JSON.parse(e) } catch (n) { if (t.strict) throw n; return e } } const ql = /#/g, Yl = /&/g, Zl = /=/g, ao = /\+/g, Xl = /%5e/gi, zl = /%60/gi, Gl = /%7c/gi, eu = /%20/gi; function tu(e) { return encodeURI("" + e).replace(Gl, "|") } function Tn(e) { return tu(typeof e == "string" ? e : JSON.stringify(e)).replace(ao, "%2B").replace(eu, "+").replace(ql, "%23").replace(Yl, "%26").replace(zl, "`").replace(Xl, "^") } function fn(e) { return Tn(e).replace(Zl, "%3D") } function Hs(e = "") { try { return decodeURIComponent("" + e) } catch { return "" + e } } function su(e) { return Hs(e.replace(ao, " ")) } function nu(e) { return Hs(e.replace(ao, " ")) } function lo(e = "") { const t = {}; e[0] === "?" && (e = e.slice(1)); for (const s of e.split("&")) { const n = s.match(/([^=]+)=?(.*)/) || []; if (n.length < 2) continue; const o = su(n[1]); if (o === "__proto__" || o === "constructor") continue; const r = nu(n[2] || ""); t[o] === void 0 ? t[o] = r : Array.isArray(t[o]) ? t[o].push(r) : t[o] = [t[o], r] } return t } function ou(e, t) { return (typeof t == "number" || typeof t == "boolean") && (t = String(t)), t ? Array.isArray(t) ? t.map(s => `${fn(e)}=${Tn(s)}`).join("&") : `${fn(e)}=${Tn(t)}` : fn(e) } function Pi(e) { return Object.keys(e).filter(t => e[t] !== void 0).map(t => ou(t, e[t])).filter(Boolean).join("&") } const ru = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/, iu = /^[\s\w\0+.-]{2,}:([/\\]{2})?/, cu = /^([/\\]\s*){2,}[^/\\]/; function cs(e, t = {}) { return typeof t == "boolean" && (t = { acceptRelative: t }), t.strict ? ru.test(e) : iu.test(e) || (t.acceptRelative ? cu.test(e) : !1) } const au = /^[\s\0]*(blob|data|javascript|vbscript):$/i; function lu(e) { return !!e && au.test(e) } const uu = /\/$|\/\?/; function In(e = "", t = !1) { return t ? uu.test(e) : e.endsWith("/") } function uo(e = "", t = !1) { if (!t) return (In(e) ? e.slice(0, -1) : e) || "/"; if (!In(e, !0)) return e || "/"; const [s, ...n] = e.split("?"); return (s.slice(0, -1) || "/") + (n.length > 0 ? `?${n.join("?")}` : "") } function Ls(e = "", t = !1) { if (!t) return e.endsWith("/") ? e : e + "/"; if (In(e, !0)) return e || "/"; const [s, ...n] = e.split("?"); return s + "/" + (n.length > 0 ? `?${n.join("?")}` : "") } function fu(e = "") { return e.startsWith("/") } function tr(e = "") { return fu(e) ? e : "/" + e } function du(e, t) { if (Mi(t) || cs(e)) return e; const s = uo(t); return e.startsWith(s) ? e : ct(s, e) } function hu(e, t) { if (Mi(t)) return e; const s = uo(t); if (!e.startsWith(s)) return e; const n = e.slice(s.length); return n[0] === "/" ? n : "/" + n } function Si(e, t) { const s = Qt(e), n = { ...lo(s.search), ...t }; return s.search = Pi(n), Bi(s) } function Mi(e) { return !e || e === "/" } function pu(e) { return e && e !== "/" } const _u = /^\.?\//; function ct(e, ...t) { let s = e || ""; for (const n of t.filter(o => pu(o))) if (s) { const o = n.replace(_u, ""); s = Ls(s) + o } else s = n; return s } function gu(e, t, s = {}) { return s.trailingSlash || (e = Ls(e), t = Ls(t)), s.leadingSlash || (e = tr(e), t = tr(t)), s.encoding || (e = Hs(e), t = Hs(t)), e === t } function Qt(e = "", t) { const s = e.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/); if (s) { const [, f, p = ""] = s; return { protocol: f, pathname: p, href: f + p, auth: "", host: "", search: "", hash: "" } } if (!cs(e, { acceptRelative: !0 })) return t ? Qt(t + e) : sr(e); const [, n = "", o, r = ""] = e.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [], [, i = "", c = ""] = r.match(/([^#/?]*)(.*)?/) || [], { pathname: l, search: u, hash: a } = sr(c.replace(/\/(?=[A-Za-z]:)/, "")); return { protocol: n, auth: o ? o.slice(0, Math.max(0, o.length - 1)) : "", host: i, pathname: l, search: u, hash: a } } function sr(e = "") { const [t = "", s = "", n = ""] = (e.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1); return { pathname: t, search: s, hash: n } } function Bi(e) { const t = e.pathname || "", s = e.search ? (e.search.startsWith("?") ? "" : "?") + e.search : "", n = e.hash || "", o = e.auth ? e.auth + "@" : "", r = e.host || ""; return (e.protocol ? e.protocol + "//" : "") + o + r + t + s + n } class mu extends Error { constructor(t, s) { super(t, s), this.name = "FetchError", s != null && s.cause && !this.cause && (this.cause = s.cause) } } function vu(e) { var l, u, a, f, p; const t = ((l = e.error) == null ? void 0 : l.message) || ((u = e.error) == null ? void 0 : u.toString()) || "", s = ((a = e.request) == null ? void 0 : a.method) || ((f = e.options) == null ? void 0 : f.method) || "GET", n = ((p = e.request) == null ? void 0 : p.url) || String(e.request) || "/", o = `[${s}] ${JSON.stringify(n)}`, r = e.response ? `${e.response.status} ${e.response.statusText}` : "<no response>", i = `${o}: ${r}${t ? ` ${t}` : ""}`, c = new mu(i, e.error ? { cause: e.error } : void 0); for (const _ of ["request", "options", "response"]) Object.defineProperty(c, _, { get() { return e[_] } }); for (const [_, A] of [["data", "_data"], ["status", "status"], ["statusCode", "status"], ["statusText", "statusText"], ["statusMessage", "statusText"]]) Object.defineProperty(c, _, { get() { return e.response && e.response[A] } }); return c } const Au = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"])); function nr(e = "GET") { return Au.has(e.toUpperCase()) } function bu(e) { if (e === void 0) return !1; const t = typeof e; return t === "string" || t === "number" || t === "boolean" || t === null ? !0 : t !== "object" ? !1 : Array.isArray(e) ? !0 : e.buffer ? !1 : e.constructor && e.constructor.name === "Object" || typeof e.toJSON == "function" } const yu = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"]), ku = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i; function wu(e = "") { if (!e) return "json"; const t = e.split(";").shift() || ""; return ku.test(t) ? "json" : yu.has(t) || t.startsWith("text/") ? "text" : "blob" } function xu(e, t, s = globalThis.Headers) { const n = { ...t, ...e }; if (t != null && t.params && (e != null && e.params) && (n.params = { ...t == null ? void 0 : t.params, ...e == null ? void 0 : e.params }), t != null && t.query && (e != null && e.query) && (n.query = { ...t == null ? void 0 : t.query, ...e == null ? void 0 : e.query }), t != null && t.headers && (e != null && e.headers)) { n.headers = new s((t == null ? void 0 : t.headers) || {}); for (const [o, r] of new s((e == null ? void 0 : e.headers) || {})) n.headers.set(o, r) } return n } const Eu = new Set([408, 409, 425, 429, 500, 502, 503, 504]), Cu = new Set([101, 204, 205, 304]); function Hi(e = {}) { const { fetch: t = globalThis.fetch, Headers: s = globalThis.Headers, AbortController: n = globalThis.AbortController } = e; async function o(c) { const l = c.error && c.error.name === "AbortError" && !c.options.timeout || !1; if (c.options.retry !== !1 && !l) { let a; typeof c.options.retry == "number" ? a = c.options.retry : a = nr(c.options.method) ? 0 : 1; const f = c.response && c.response.status || 500; if (a > 0 && (Array.isArray(c.options.retryStatusCodes) ? c.options.retryStatusCodes.includes(f) : Eu.has(f))) { const p = c.options.retryDelay || 0; return p > 0 && await new Promise(_ => setTimeout(_, p)), r(c.request, { ...c.options, retry: a - 1, timeout: c.options.timeout }) } } const u = vu(c); throw Error.captureStackTrace && Error.captureStackTrace(u, r), u } const r = async function (l, u = {}) { var p; const a = { request: l, options: xu(u, e.defaults, s), response: void 0, error: void 0 }; if (a.options.method = (p = a.options.method) == null ? void 0 : p.toUpperCase(), a.options.onRequest && await a.options.onRequest(a), typeof a.request == "string" && (a.options.baseURL && (a.request = du(a.request, a.options.baseURL)), (a.options.query || a.options.params) && (a.request = Si(a.request, { ...a.options.params, ...a.options.query }))), a.options.body && nr(a.options.method) && (bu(a.options.body) ? (a.options.body = typeof a.options.body == "string" ? a.options.body : JSON.stringify(a.options.body), a.options.headers = new s(a.options.headers || {}), a.options.headers.has("content-type") || a.options.headers.set("content-type", "application/json"), a.options.headers.has("accept") || a.options.headers.set("accept", "application/json")) : ("pipeTo" in a.options.body && typeof a.options.body.pipeTo == "function" || typeof a.options.body.pipe == "function") && ("duplex" in a.options || (a.options.duplex = "half"))), !a.options.signal && a.options.timeout) { const _ = new n; setTimeout(() => _.abort(), a.options.timeout), a.options.signal = _.signal } try { a.response = await t(a.request, a.options) } catch (_) { return a.error = _, a.options.onRequestError && await a.options.onRequestError(a), await o(a) } if (a.response.body && !Cu.has(a.response.status) && a.options.method !== "HEAD") { const _ = (a.options.parseResponse ? "json" : a.options.responseType) || wu(a.response.headers.get("content-type") || ""); switch (_) { case "json": { const A = await a.response.text(), R = a.options.parseResponse || Bs; a.response._data = R(A); break } case "stream": { a.response._data = a.response.body; break } default: a.response._data = await a.response[_]() } } return a.options.onResponse && await a.options.onResponse(a), !a.options.ignoreResponseError && a.response.status >= 400 && a.response.status < 600 ? (a.options.onResponseError && await a.options.onResponseError(a), await o(a)) : a.response }, i = async function (l, u) { return (await r(l, u))._data }; return i.raw = r, i.native = (...c) => t(...c), i.create = (c = {}) => Hi({ ...e, defaults: { ...e.defaults, ...c } }), i } const fo = function () { if (typeof globalThis < "u") return globalThis; if (typeof self < "u") return self; if (typeof window < "u") return window; if (typeof global < "u") return global; throw new Error("unable to locate global object") }(), Ru = fo.fetch || (() => Promise.reject(new Error("[ofetch] global.fetch is not supported!"))), Tu = fo.Headers, Iu = fo.AbortController, Pu = Hi({ fetch: Ru, Headers: Tu, AbortController: Iu }), Su = Pu, Mu = () => { var e; return ((e = window == null ? void 0 : window.__NUXT__) == null ? void 0 : e.config) || {} }, Os = Mu().app, Bu = () => Os.baseURL, Hu = () => Os.buildAssetsDir, Lu = (...e) => ct(Li(), Hu(), ...e), Li = (...e) => { const t = Os.cdnURL || Os.baseURL; return e.length ? ct(t, ...e) : t }; globalThis.__buildAssetsURL = Lu, globalThis.__publicAssetsURL = Li; function Pn(e, t = {}, s) { for (const n in e) { const o = e[n], r = s ? `${s}:${n}` : n; typeof o == "object" && o !== null ? Pn(o, t, r) : typeof o == "function" && (t[r] = o) } return t } const Ou = { run: e => e() }, Uu = () => Ou, Oi = typeof console.createTask < "u" ? console.createTask : Uu; function Nu(e, t) { const s = t.shift(), n = Oi(s); return e.reduce((o, r) => o.then(() => n.run(() => r(...t))), Promise.resolve()) } function ju(e, t) { const s = t.shift(), n = Oi(s); return Promise.all(e.map(o => n.run(() => o(...t)))) } function dn(e, t) { for (const s of [...e]) s(t) } class $u { constructor() { this._hooks = {}, this._before = void 0, this._after = void 0, this._deprecatedMessages = void 0, this._deprecatedHooks = {}, this.hook = this.hook.bind(this), this.callHook = this.callHook.bind(this), this.callHookWith = this.callHookWith.bind(this) } hook(t, s, n = {}) { if (!t || typeof s != "function") return () => { }; const o = t; let r; for (; this._deprecatedHooks[t];)r = this._deprecatedHooks[t], t = r.to; if (r && !n.allowDeprecated) { let i = r.message; i || (i = `${o} hook has been deprecated` + (r.to ? `, please use ${r.to}` : "")), this._deprecatedMessages || (this._deprecatedMessages = new Set), this._deprecatedMessages.has(i) || (console.warn(i), this._deprecatedMessages.add(i)) } if (!s.name) try { Object.defineProperty(s, "name", { get: () => "_" + t.replace(/\W+/g, "_") + "_hook_cb", configurable: !0 }) } catch { } return this._hooks[t] = this._hooks[t] || [], this._hooks[t].push(s), () => { s && (this.removeHook(t, s), s = void 0) } } hookOnce(t, s) { let n, o = (...r) => (typeof n == "function" && n(), n = void 0, o = void 0, s(...r)); return n = this.hook(t, o), n } removeHook(t, s) { if (this._hooks[t]) { const n = this._hooks[t].indexOf(s); n !== -1 && this._hooks[t].splice(n, 1), this._hooks[t].length === 0 && delete this._hooks[t] } } deprecateHook(t, s) { this._deprecatedHooks[t] = typeof s == "string" ? { to: s } : s; const n = this._hooks[t] || []; delete this._hooks[t]; for (const o of n) this.hook(t, o) } deprecateHooks(t) { Object.assign(this._deprecatedHooks, t); for (const s in t) this.deprecateHook(s, t[s]) } addHooks(t) { const s = Pn(t), n = Object.keys(s).map(o => this.hook(o, s[o])); return () => { for (const o of n.splice(0, n.length)) o() } } removeHooks(t) { const s = Pn(t); for (const n in s) this.removeHook(n, s[n]) } removeAllHooks() { for (const t in this._hooks) delete this._hooks[t] } callHook(t, ...s) { return s.unshift(t), this.callHookWith(Nu, t, ...s) } callHookParallel(t, ...s) { return s.unshift(t), this.callHookWith(ju, t, ...s) } callHookWith(t, s, ...n) { const o = this._before || this._after ? { name: s, args: n, context: {} } : void 0; this._before && dn(this._before, o); const r = t(s in this._hooks ? [...this._hooks[s]] : [], n); return r instanceof Promise ? r.finally(() => { this._after && o && dn(this._after, o) }) : (this._after && o && dn(this._after, o), r) } beforeEach(t) { return this._before = this._before || [], this._before.push(t), () => { if (this._before !== void 0) { const s = this._before.indexOf(t); s !== -1 && this._before.splice(s, 1) } } } afterEach(t) { return this._after = this._after || [], this._after.push(t), () => { if (this._after !== void 0) { const s = this._after.indexOf(t); s !== -1 && this._after.splice(s, 1) } } } } function Ui() { return new $u } function Qu(e = {}) { let t, s = !1; const n = i => { if (t && t !== i) throw new Error("Context conflict") }; let o; if (e.asyncContext) { const i = e.AsyncLocalStorage || globalThis.AsyncLocalStorage; i ? o = new i : console.warn("[unctx] `AsyncLocalStorage` is not provided.") } const r = () => { if (o && t === void 0) { const i = o.getStore(); if (i !== void 0) return i } return t }; return { use: () => { const i = r(); if (i === void 0) throw new Error("Context is not available"); return i }, tryUse: () => r(), set: (i, c) => { c || n(i), t = i, s = !0 }, unset: () => { t = void 0, s = !1 }, call: (i, c) => { n(i), t = i; try { return o ? o.run(i, c) : c() } finally { s || (t = void 0) } }, async callAsync(i, c) { t = i; const l = () => { t = i }, u = () => t === i ? l : void 0; Sn.add(u); try { const a = o ? o.run(i, c) : c(); return s || (t = void 0), await a } finally { Sn.delete(u) } } } } function Fu(e = {}) { const t = {}; return { get(s, n = {}) { return t[s] || (t[s] = Qu({ ...e, ...n })), t[s], t[s] } } } const Us = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof global < "u" ? global : typeof window < "u" ? window : {}, or = "__unctx__", Du = Us[or] || (Us[or] = Fu()), Ju = (e, t = {}) => Du.get(e, t), rr = "__unctx_async_handlers__", Sn = Us[rr] || (Us[rr] = new Set); function Ni(e) { const t = []; for (const o of Sn) { const r = o(); r && t.push(r) } const s = () => { for (const o of t) o() }; let n = e(); return n && typeof n == "object" && "catch" in n && (n = n.catch(o => { throw s(), o })), [n, s] } const ji = Ju("nuxt-app", { asyncContext: !1 }), Ku = "__nuxt_plugin"; function Wu(e) { let t = 0; const s = { _scope: Mc(), provide: void 0, globalName: "nuxt", versions: { get nuxt() { return "3.8.0" }, get vue() { return s.vueApp.version } }, payload: Ze({ data: {}, state: {}, _errors: {}, ...window.__NUXT__ ?? {} }), static: { data: {} }, runWithContext: o => s._scope.run(() => Yu(s, o)), isHydrating: !0, deferHydration() { if (!s.isHydrating) return () => { }; t++; let o = !1; return () => { if (!o && (o = !0, t--, t === 0)) return s.isHydrating = !1, s.callHook("app:suspense:resolve") } }, _asyncDataPromises: {}, _asyncData: {}, _payloadRevivers: {}, ...e }; s.hooks = Ui(), s.hook = s.hooks.hook, s.callHook = s.hooks.callHook, s.provide = (o, r) => { const i = "$" + o; As(s, i, r), As(s.vueApp.config.globalProperties, i, r) }, As(s.vueApp, "$nuxt", s), As(s.vueApp.config.globalProperties, "$nuxt", s); { window.addEventListener("nuxt.preloadError", r => { s.callHook("app:chunkError", { error: r.payload }) }), window.useNuxtApp = window.useNuxtApp || le; const o = s.hook("app:error", (...r) => { console.error("[nuxt] error caught during app initialization", ...r) }); s.hook("app:mounted", o) } const n = Ze(s.payload.config); return s.provide("config", n), s } async function Vu(e, t) { if (t.hooks && e.hooks.addHooks(t.hooks), typeof t == "function") { const { provide: s } = await e.runWithContext(() => t(e)) || {}; if (s && typeof s == "object") for (const n in s) e.provide(n, s[n]) } } async function qu(e, t) { const s = [], n = []; for (const o of t) { const r = Vu(e, o); o.parallel ? s.push(r.catch(i => n.push(i))) : await r } if (await Promise.all(s), n.length) throw n[0] }/*! @__NO_SIDE_EFFECTS__ */function at(e) { return typeof e == "function" ? e : (delete e.name, Object.assign(e.setup || (() => { }), e, { [Ku]: !0 })) } function Yu(e, t, s) { const n = () => s ? t(...s) : t(); return ji.set(e), e.vueApp.runWithContext(n) }/*! @__NO_SIDE_EFFECTS__ */function le() { var t; let e; if (di() && (e = (t = xi()) == null ? void 0 : t.appContext.app.$nuxt), e = e || ji.tryUse(), !e) throw new Error("[nuxt] instance unavailable"); return e }/*! @__NO_SIDE_EFFECTS__ */function Ot() { return le().$config } function As(e, t, s) { Object.defineProperty(e, t, { get: () => s }) } const Zu = "modulepreload", Xu = function (e, t) { return e[0] === "." ? new URL(e, t).href : e }, ir = {}, zu = function (t, s, n) { if (!s || s.length === 0) return t(); const o = document.getElementsByTagName("link"); return Promise.all(s.map(r => { if (r = Xu(r, n), r in ir) return; ir[r] = !0; const i = r.endsWith(".css"), c = i ? '[rel="stylesheet"]' : ""; if (!!n) for (let a = o.length - 1; a >= 0; a--) { const f = o[a]; if (f.href === r && (!i || f.rel === "stylesheet")) return } else if (document.querySelector(`link[href="${r}"]${c}`)) return; const u = document.createElement("link"); if (u.rel = i ? "stylesheet" : Zu, i || (u.as = "script", u.crossOrigin = ""), u.href = r, document.head.appendChild(u), i) return new Promise((a, f) => { u.addEventListener("load", a), u.addEventListener("error", () => f(new Error(`Unable to preload CSS for ${r}`))) }) })).then(() => t()).catch(r => { const i = new Event("vite:preloadError", { cancelable: !0 }); if (i.payload = r, window.dispatchEvent(i), !i.defaultPrevented) throw r }) }, cr = (...e) => zu(...e).catch(t => { const s = new Event("nuxt.preloadError"); throw s.payload = t, window.dispatchEvent(s), t }), Gu = -1, ef = -2, tf = -3, sf = -4, nf = -5, of = -6; function rf(e, t) { return cf(JSON.parse(e), t) } function cf(e, t) { if (typeof e == "number") return o(e, !0); if (!Array.isArray(e) || e.length === 0) throw new Error("Invalid input"); const s = e, n = Array(s.length); function o(r, i = !1) { if (r === Gu) return; if (r === tf) return NaN; if (r === sf) return 1 / 0; if (r === nf) return -1 / 0; if (r === of) return -0; if (i) throw new Error("Invalid input"); if (r in n) return n[r]; const c = s[r]; if (!c || typeof c != "object") n[r] = c; else if (Array.isArray(c)) if (typeof c[0] == "string") { const l = c[0], u = t == null ? void 0 : t[l]; if (u) return n[r] = u(o(c[1])); switch (l) { case "Date": n[r] = new Date(c[1]); break; case "Set": const a = new Set; n[r] = a; for (let _ = 1; _ < c.length; _ += 1)a.add(o(c[_])); break; case "Map": const f = new Map; n[r] = f; for (let _ = 1; _ < c.length; _ += 2)f.set(o(c[_]), o(c[_ + 1])); break; case "RegExp": n[r] = new RegExp(c[1], c[2]); break; case "Object": n[r] = Object(c[1]); break; case "BigInt": n[r] = BigInt(c[1]); break; case "null": const p = Object.create(null); n[r] = p; for (let _ = 1; _ < c.length; _ += 2)p[c[_]] = o(c[_ + 1]); break; default: throw new Error(`Unknown type ${l}`) } } else { const l = new Array(c.length); n[r] = l; for (let u = 0; u < c.length; u += 1) { const a = c[u]; a !== ef && (l[u] = o(a)) } } else { const l = {}; n[r] = l; for (const u in c) { const a = c[u]; l[u] = o(a) } } return n[r] } return o(0) } function af(e) { return Array.isArray(e) ? e : [e] } const lf = ["title", "titleTemplate", "script", "style", "noscript"], ws = ["base", "meta", "link", "style", "script", "noscript"], uf = ["title", "titleTemplate", "templateParams", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"], ff = ["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"], $i = ["tagPosition", "tagPriority", "tagDuplicateStrategy", "innerHTML", "textContent", "processTemplateParams"], df = typeof window < "u"; function Qi(e) { let t = 9; for (let s = 0; s < e.length;)t = Math.imul(t ^ e.charCodeAt(s++), 9 ** 9); return ((t ^ t >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase() } function ar(e) { return e._h || Qi(e._d ? e._d : `${e.tag}:${e.textContent || e.innerHTML || ""}:${Object.entries(e.props).map(([t, s]) => `${t}:${String(s)}`).join(",")}`) } function Fi(e, t) { const { props: s, tag: n } = e; if (ff.includes(n)) return n; if (n === "link" && s.rel === "canonical") return "canonical"; if (s.charset) return "charset"; const o = ["id"]; n === "meta" && o.push("name", "property", "http-equiv"); for (const r of o) if (typeof s[r] < "u") { const i = String(s[r]); return t && !t(i) ? !1 : `${n}:${r}:${i}` } return !1 } function lr(e, t) { return e == null ? t || null : typeof e == "function" ? e(t) : e } async function hf(e, t, s) { const n = { tag: e, props: await Di(typeof t == "object" && typeof t != "function" && !(t instanceof Promise) ? { ...t } : { [["script", "noscript", "style"].includes(e) ? "innerHTML" : "textContent"]: t }, ["templateParams", "titleTemplate"].includes(e)) }; return $i.forEach(o => { const r = typeof n.props[o] < "u" ? n.props[o] : s[o]; typeof r < "u" && ((!["innerHTML", "textContent"].includes(o) || lf.includes(n.tag)) && (n[o] = r), delete n.props[o]) }), n.props.body && (n.tagPosition = "bodyClose", delete n.props.body), n.props.children && (n.innerHTML = n.props.children, delete n.props.children), n.tag === "script" && (typeof n.innerHTML == "object" && (n.innerHTML = JSON.stringify(n.innerHTML), n.props.type = n.props.type || "application/json"), n.innerHTML && ["application/ld+json", "application/json"].includes(n.props.type) && (n.innerHTML = n.innerHTML.replace(/</g, "\\u003C"))), Array.isArray(n.props.content) ? n.props.content.map(o => ({ ...n, props: { ...n.props, content: o } })) : n } function pf(e) { return typeof e == "object" && !Array.isArray(e) && (e = Object.keys(e).filter(t => e[t])), (Array.isArray(e) ? e.join(" ") : e).split(" ").filter(t => t.trim()).filter(Boolean).join(" ") } async function Di(e, t) { for (const s of Object.keys(e)) { if (s === "class") { e[s] = pf(e[s]); continue } if (e[s] instanceof Promise && (e[s] = await e[s]), !t && !$i.includes(s)) { const n = String(e[s]), o = s.startsWith("data-"); n === "true" || n === "" ? e[s] = o ? "true" : !0 : e[s] || (o && n === "false" ? e[s] = "false" : delete e[s]) } } return e } const _f = 10; async function gf(e) { const t = []; return Object.entries(e.resolvedInput).filter(([s, n]) => typeof n < "u" && uf.includes(s)).forEach(([s, n]) => { const o = af(n); t.push(...o.map(r => hf(s, r, e)).flat()) }), (await Promise.all(t)).flat().filter(Boolean).map((s, n) => (s._e = e._i, e.mode && (s._m = e.mode), s._p = (e._i << _f) + n, s)) } const ur = { base: -10, title: 10 }, fr = { critical: -80, high: -10, low: 20 }; function Ns(e) { let t = 100; const s = e.tagPriority; return typeof s == "number" ? s : (e.tag === "meta" ? (e.props["http-equiv"] === "content-security-policy" && (t = -30), e.props.charset && (t = -20), e.props.name === "viewport" && (t = -15)) : e.tag === "link" && e.props.rel === "preconnect" ? t = 20 : e.tag in ur && (t = ur[e.tag]), typeof s == "string" && s in fr ? t + fr[s] : t) } const mf = [{ prefix: "before:", offset: -1 }, { prefix: "after:", offset: 1 }], tt = "%separator"; function dt(e, t, s) { if (typeof e != "string" || !e.includes("%")) return e; function n(i) { let c; return ["s", "pageTitle"].includes(i) ? c = t.pageTitle : i.includes(".") ? c = i.split(".").reduce((l, u) => l && l[u] || void 0, t) : c = t[i], typeof c < "u" ? (c || "").replace(/"/g, '\\"') : !1 } let o = e; try { o = decodeURI(e) } catch { } return (o.match(/%(\w+\.+\w+)|%(\w+)/g) || []).sort().reverse().forEach(i => { const c = n(i.slice(1)); typeof c == "string" && (e = e.replace(new RegExp(`\\${i}(\\W|$)`, "g"), (l, u) => `${c}${u}`).trim()) }), e.includes(tt) && (e.endsWith(tt) && (e = e.slice(0, -tt.length).trim()), e.startsWith(tt) && (e = e.slice(tt.length).trim()), e = e.replace(new RegExp(`\\${tt}\\s*\\${tt}`, "g"), tt), e = dt(e, { separator: s }, s)), e } async function vf(e) { const t = { tag: e.tagName.toLowerCase(), props: await Di(e.getAttributeNames().reduce((s, n) => ({ ...s, [n]: e.getAttribute(n) }), {})), innerHTML: e.innerHTML }; return t._d = Fi(t), t } async function Ji(e, t = {}) { var a; const s = t.document || e.resolvedOptions.document; if (!s) return; const n = { shouldRender: e.dirty, tags: [] }; if (await e.hooks.callHook("dom:beforeRender", n), !n.shouldRender) return; const o = (await e.resolveTags()).map(f => ({ tag: f, id: ws.includes(f.tag) ? ar(f) : f.tag, shouldRender: !0 })); let r = e._dom; if (!r) { r = { elMap: { htmlAttrs: s.documentElement, bodyAttrs: s.body } }; for (const f of ["body", "head"]) { const p = (a = s == null ? void 0 : s[f]) == null ? void 0 : a.children; for (const _ of [...p].filter(A => ws.includes(A.tagName.toLowerCase()))) r.elMap[_.getAttribute("data-hid") || ar(await vf(_))] = _ } } r.pendingSideEffects = { ...r.sideEffects || {} }, r.sideEffects = {}; function i(f, p, _) { const A = `${f}:${p}`; r.sideEffects[A] = _, delete r.pendingSideEffects[A] } function c({ id: f, $el: p, tag: _ }) { const A = _.tag.endsWith("Attrs"); r.elMap[f] = p, A || (["textContent", "innerHTML"].forEach(R => { _[R] && _[R] !== p[R] && (p[R] = _[R]) }), i(f, "el", () => { r.elMap[f].remove(), delete r.elMap[f] })), Object.entries(_.props).forEach(([R, j]) => { const v = `attr:${R}`; if (R === "class") for (const b of (j || "").split(" ").filter(Boolean)) A && i(f, `${v}:${b}`, () => p.classList.remove(b)), !p.classList.contains(b) && p.classList.add(b); else p.getAttribute(R) !== j && p.setAttribute(R, j === !0 ? "" : String(j)), A && i(f, v, () => p.removeAttribute(R)) }) } const l = [], u = { bodyClose: void 0, bodyOpen: void 0, head: void 0 }; for (const f of o) { const { tag: p, shouldRender: _, id: A } = f; if (_) { if (p.tag === "title") { s.title = p.textContent; continue } f.$el = f.$el || r.elMap[A], f.$el ? c(f) : ws.includes(p.tag) && l.push(f) } } for (const f of l) { const p = f.tag.tagPosition || "head"; f.$el = s.createElement(f.tag.tag), c(f), u[p] = u[p] || s.createDocumentFragment(), u[p].appendChild(f.$el) } for (const f of o) await e.hooks.callHook("dom:renderTag", f, s, i); u.head && s.head.appendChild(u.head), u.bodyOpen && s.body.insertBefore(u.bodyOpen, s.body.firstChild), u.bodyClose && s.body.appendChild(u.bodyClose), Object.values(r.pendingSideEffects).forEach(f => f()), e._dom = r, e.dirty = !1, await e.hooks.callHook("dom:rendered", { renders: o }) } async function Af(e, t = {}) { const s = t.delayFn || (n => setTimeout(n, 10)); return e._domUpdatePromise = e._domUpdatePromise || new Promise(n => s(async () => { await Ji(e, t), delete e._domUpdatePromise, n() })) } function bf(e) { return t => { var n, o; const s = ((o = (n = t.resolvedOptions.document) == null ? void 0 : n.head.querySelector('script[id="unhead:payload"]')) == null ? void 0 : o.innerHTML) || !1; return s && t.push(JSON.parse(s)), { mode: "client", hooks: { "entries:updated": function (r) { Af(r, e) } } } } } const yf = ["templateParams", "htmlAttrs", "bodyAttrs"], kf = { hooks: { "tag:normalise": function ({ tag: e }) { ["hid", "vmid", "key"].forEach(n => { e.props[n] && (e.key = e.props[n], delete e.props[n]) }); const s = Fi(e) || (e.key ? `${e.tag}:${e.key}` : !1); s && (e._d = s) }, "tags:resolve": function (e) { const t = {}; e.tags.forEach(n => { const o = (n.key ? `${n.tag}:${n.key}` : n._d) || n._p, r = t[o]; if (r) { let c = n == null ? void 0 : n.tagDuplicateStrategy; if (!c && yf.includes(n.tag) && (c = "merge"), c === "merge") { const l = r.props;["class", "style"].forEach(u => { n.props[u] && l[u] && (u === "style" && !l[u].endsWith(";") && (l[u] += ";"), n.props[u] = `${l[u]} ${n.props[u]}`) }), t[o].props = { ...l, ...n.props }; return } else if (n._e === r._e) { r._duped = r._duped || [], n._d = `${r._d}:${r._duped.length + 1}`, r._duped.push(n); return } else if (Ns(n) > Ns(r)) return } const i = Object.keys(n.props).length + (n.innerHTML ? 1 : 0) + (n.textContent ? 1 : 0); if (ws.includes(n.tag) && i === 0) { delete t[o]; return } t[o] = n }); const s = []; Object.values(t).forEach(n => { const o = n._duped; delete n._duped, s.push(n), o && s.push(...o) }), e.tags = s, e.tags = e.tags.filter(n => !(n.tag === "meta" && (n.props.name || n.props.property) && !n.props.content)) } } }, wf = { mode: "server", hooks: { "tags:resolve": function (e) { const t = {}; e.tags.filter(s => ["titleTemplate", "templateParams", "title"].includes(s.tag) && s._m === "server").forEach(s => { t[s.tag] = s.tag.startsWith("title") ? s.textContent : s.props }), Object.keys(t).length && e.tags.push({ tag: "script", innerHTML: JSON.stringify(t), props: { id: "unhead:payload", type: "application/json" } }) } } }, dr = ["script", "link", "bodyAttrs"]; function hr(e) { const t = {}, s = {}; return Object.entries(e.props).forEach(([n, o]) => { n.startsWith("on") && typeof o == "function" ? s[n] = o : t[n] = o }), { props: t, eventHandlers: s } } const xf = { hooks: { "ssr:render": function (e) { e.tags = e.tags.map(t => (!dr.includes(t.tag) || !Object.entries(t.props).find(([s, n]) => s.startsWith("on") && typeof n == "function") || (t.props = hr(t).props), t)) }, "tags:resolve": function (e) { e.tags = e.tags.map(t => { if (!dr.includes(t.tag)) return t; const { props: s, eventHandlers: n } = hr(t); return Object.keys(n).length && (t.props = s, t._eventHandlers = n), t }) }, "dom:renderTag": function (e, t, s) { if (!e.tag._eventHandlers) return; const n = e.tag.tag === "bodyAttrs" ? t.defaultView : e.$el; Object.entries(e.tag._eventHandlers).forEach(([o, r]) => { const i = `${e.tag._d || e.tag._p}:${o}`, c = o.slice(2).toLowerCase(), l = `data-h-${c}`; if (s(e.id, i, () => { }), e.$el.hasAttribute(l)) return; const u = r; e.$el.setAttribute(l, ""), n.addEventListener(c, u), e.entry && s(e.id, i, () => { n.removeEventListener(c, u), e.$el.removeAttribute(l) }) }) } } }, Ef = ["link", "style", "script", "noscript"], Cf = { hooks: { "tag:normalise": ({ tag: e }) => { e.key && Ef.includes(e.tag) && (e.props["data-hid"] = e._h = Qi(e.key)) } } }, Rf = { hooks: { "tags:resolve": e => { const t = s => { var n; return (n = e.tags.find(o => o._d === s)) == null ? void 0 : n._p }; for (const { prefix: s, offset: n } of mf) for (const o of e.tags.filter(r => typeof r.tagPriority == "string" && r.tagPriority.startsWith(s))) { const r = t(o.tagPriority.replace(s, "")); typeof r < "u" && (o._p = r + n) } e.tags.sort((s, n) => s._p - n._p).sort((s, n) => Ns(s) - Ns(n)) } } }, Tf = { hooks: { "tags:resolve": e => { var i; const { tags: t } = e, s = (i = t.find(c => c.tag === "title")) == null ? void 0 : i.textContent, n = t.findIndex(c => c.tag === "templateParams"), o = n !== -1 ? t[n].props : {}, r = o.separator || "|"; delete o.separator, o.pageTitle = dt(o.pageTitle || s || "", o, r); for (const c of t) c.processTemplateParams !== !1 && (["titleTemplate", "title"].includes(c.tag) && typeof c.textContent == "string" ? c.textContent = dt(c.textContent, o, r) : c.tag === "meta" && typeof c.props.content == "string" ? c.props.content = dt(c.props.content, o, r) : c.tag === "link" && typeof c.props.href == "string" ? c.props.href = dt(c.props.href, o, r) : c.processTemplateParams === !0 && (c.innerHTML ? c.innerHTML = dt(c.innerHTML, o, r) : c.textContent && (c.textContent = dt(c.textContent, o, r)))); e.tags = t.filter(c => c.tag !== "templateParams") } } }, If = { hooks: { "tags:resolve": e => { const { tags: t } = e; let s = t.findIndex(o => o.tag === "titleTemplate"); const n = t.findIndex(o => o.tag === "title"); if (n !== -1 && s !== -1) { const o = lr(t[s].textContent, t[n].textContent); o !== null ? t[n].textContent = o || t[n].textContent : delete t[n] } else if (s !== -1) { const o = lr(t[s].textContent); o !== null && (t[s].textContent = o, t[s].tag = "title", s = -1) } s !== -1 && delete t[s], e.tags = t.filter(Boolean) } } }; let Ki; function Pf(e = {}) { const t = Sf(e); return t.use(bf()), Ki = t } function pr(e, t) { return !e || e === "server" && t || e === "client" && !t } function Sf(e = {}) { const t = Ui(); t.addHooks(e.hooks || {}), e.document = e.document || (df ? document : void 0); const s = !e.document; e.plugins = [kf, wf, xf, Cf, Rf, Tf, If, ...(e == null ? void 0 : e.plugins) || []]; const n = () => { i.dirty = !0, t.callHook("entries:updated", i) }; let o = 0, r = []; const i = { dirty: !1, resolvedOptions: e, hooks: t, headEntries() { return r }, use(c) { const l = typeof c == "function" ? c(i) : c; pr(l.mode, s) && t.addHooks(l.hooks || {}) }, push(c, l) { l == null || delete l.head; const u = { _i: o++, input: c, ...l }; return pr(u.mode, s) && (r.push(u), n()), { dispose() { r = r.filter(a => a._i !== u._i), t.callHook("entries:updated", i), n() }, patch(a) { r = r.map(f => (f._i === u._i && (f.input = u.input = a), f)), n() } } }, async resolveTags() { const c = { tags: [], entries: [...r] }; await t.callHook("entries:resolve", c); for (const l of c.entries) { const u = l.resolvedInput || l.input; if (l.resolvedInput = await (l.transform ? l.transform(u) : u), l.resolvedInput) for (const a of await gf(l)) { const f = { tag: a, entry: l, resolvedOptions: i.resolvedOptions }; await t.callHook("tag:normalise", f), c.tags.push(f.tag) } } return await t.callHook("tags:beforeResolve", c), await t.callHook("tags:resolve", c), c.tags }, ssr: s }; return e.plugins.forEach(c => i.use(c)), i.hooks.callHook("init", i), i } function Mf() { return Ki } const Bf = Ri.startsWith("3"); function Hf(e) { return typeof e == "function" ? e() : ne(e) } function js(e, t = "") { if (e instanceof Promise) return e; const s = Hf(e); return !e || !s ? s : Array.isArray(s) ? s.map(n => js(n, t)) : typeof s == "object" ? Object.fromEntries(Object.entries(s).map(([n, o]) => n === "titleTemplate" || n.startsWith("on") ? [n, ne(o)] : [n, js(o, n)])) : s } const Lf = { hooks: { "entries:resolve": function (e) { for (const t of e.entries) t.resolvedInput = js(t.input) } } }, Wi = "usehead"; function Of(e) { return { install(s) { Bf && (s.config.globalProperties.$unhead = e, s.config.globalProperties.$head = e, s.provide(Wi, e)) } }.install } function Uf(e = {}) { e.domDelayFn = e.domDelayFn || (s => Zn(() => setTimeout(() => s(), 0))); const t = Pf(e); return t.use(Lf), t.install = Of(t), t } const Mn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Bn = "__unhead_injection_handler__"; function Nf(e) { Mn[Bn] = e } function jf() { if (Bn in Mn) return Mn[Bn](); const e = Pt(Wi); return e || Mf() } function Vi(e, t = {}) { const s = t.head || jf(); if (s) return s.ssr ? s.push(e, t) : $f(s, e, t) } function $f(e, t, s = {}) { const n = be(!1), o = be({}); Ra(() => { o.value = n.value ? {} : js(t) }); const r = e.push(o.value, s); return ys(o, c => { r.patch(c) }), xi() && (to(() => { r.dispose() }), si(() => { n.value = !0 }), ti(() => { n.value = !1 })), r } function Qf(e) { return { ctx: { table: e }, matchAll: t => Yi(t, e) } } function qi(e) { const t = {}; for (const s in e) t[s] = s === "dynamic" ? new Map(Object.entries(e[s]).map(([n, o]) => [n, qi(o)])) : new Map(Object.entries(e[s])); return t } function Ff(e) { return Qf(qi(e)) } function Yi(e, t) { const s = []; for (const [o, r] of _r(t.wildcard)) e.startsWith(o) && s.push(r); for (const [o, r] of _r(t.dynamic)) if (e.startsWith(o + "/")) { const i = "/" + e.slice(o.length).split("/").splice(2).join("/"); s.push(...Yi(i, r)) } const n = t.static.get(e); return n && s.push(n), s.filter(Boolean) } function _r(e) { return [...e.entries()].sort((t, s) => t[0].length - s[0].length) } function hn(e) { return e !== null && typeof e == "object" } function Hn(e, t, s = ".", n) { if (!hn(t)) return Hn(e, {}, s, n); const o = Object.assign({}, t); for (const r in e) { if (r === "__proto__" || r === "constructor") continue; const i = e[r]; i != null && (n && n(o, r, i, s) || (Array.isArray(i) && Array.isArray(o[r]) ? o[r] = [...i, ...o[r]] : hn(i) && hn(o[r]) ? o[r] = Hn(i, o[r], (s ? `${s}.` : "") + r.toString(), n) : o[r] = i)) } return o } function Zi(e) { return (...t) => t.reduce((s, n) => Hn(s, n, "", e), {}) } const Df = Zi(), Jf = Zi((e, t, s) => { if (typeof e[t] < "u" && typeof s == "function") return e[t] = s(e[t]), !0 }); function Kf(e, t) { try { return t in e } catch { return !1 } } var Wf = Object.defineProperty, Vf = (e, t, s) => t in e ? Wf(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, ht = (e, t, s) => (Vf(e, typeof t != "symbol" ? t + "" : t, s), s); class Ln extends Error { constructor(t, s = {}) { super(t, s), ht(this, "statusCode", 500), ht(this, "fatal", !1), ht(this, "unhandled", !1), ht(this, "statusMessage"), ht(this, "data"), ht(this, "cause"), s.cause && !this.cause && (this.cause = s.cause) } toJSON() { const t = { message: this.message, statusCode: On(this.statusCode, 500) }; return this.statusMessage && (t.statusMessage = Xi(this.statusMessage)), this.data !== void 0 && (t.data = this.data), t } } ht(Ln, "__h3_error__", !0); function qf(e) { if (typeof e == "string") return new Ln(e); if (Yf(e)) return e; const t = new Ln(e.message ?? e.statusMessage ?? "", { cause: e.cause || e }); if (Kf(e, "stack")) try { Object.defineProperty(t, "stack", { get() { return e.stack } }) } catch { try { t.stack = e.stack } catch { } } if (e.data && (t.data = e.data), e.statusCode ? t.statusCode = On(e.statusCode, t.statusCode) : e.status && (t.statusCode = On(e.status, t.statusCode)), e.statusMessage ? t.statusMessage = e.statusMessage : e.statusText && (t.statusMessage = e.statusText), t.statusMessage) { const s = t.statusMessage; Xi(t.statusMessage) !== s && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.") } return e.fatal !== void 0 && (t.fatal = e.fatal), e.unhandled !== void 0 && (t.unhandled = e.unhandled), t } function Yf(e) { var t; return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.__h3_error__) === !0 } const Zf = /[^\u0009\u0020-\u007E]/g; function Xi(e = "") { return e.replace(Zf, "") } function On(e, t = 200) { return !e || (typeof e == "string" && (e = Number.parseInt(e, 10)), e < 100 || e > 999) ? t : e } const zi = Symbol("route"), Ft = () => { var e; return (e = le()) == null ? void 0 : e.$router }, Gi = () => di() ? Pt(zi, le()._route) : le()._route;/*! @__NO_SIDE_EFFECTS__ */const Xf = () => { try { if (le()._processingMiddleware) return !0 } catch { return !0 } return !1 }, ec = (e, t) => { e || (e = "/"); const s = typeof e == "string" ? e : Si(e.path || "/", e.query || {}) + (e.hash || ""); if (t != null && t.open) { { const { target: c = "_blank", windowFeatures: l = {} } = t.open, u = Object.entries(l).filter(([a, f]) => f !== void 0).map(([a, f]) => `${a.toLowerCase()}=${f}`).join(", "); open(s, c, u) } return Promise.resolve() } const n = (t == null ? void 0 : t.external) || cs(s, { acceptRelative: !0 }); if (n) { if (!(t != null && t.external)) throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`."); const c = Qt(s).protocol; if (c && lu(c)) throw new Error(`Cannot navigate to a URL with '${c}' protocol.`) } const o = Xf(); if (!n && o) return e; const r = Ft(), i = le(); return n ? (i._scope.stop(), t != null && t.replace ? location.replace(s) : location.href = s, o ? i.isHydrating ? new Promise(() => { }) : !1 : Promise.resolve()) : t != null && t.replace ? r.replace(e) : r.push(e) }, ho = () => ia(le().payload, "error"), zf = e => { const t = tc(e); try { const s = le(), n = ho(); s.hooks.callHook("app:error", t), n.value = n.value || t } catch { throw t } return t }, Gf = async (e = {}) => { const t = le(), s = ho(); t.callHook("app:error:cleared", e), e.redirect && await Ft().replace(e.redirect), s.value = null }, ed = e => !!(e && typeof e == "object" && "__nuxt_error" in e), tc = e => { const t = qf(e); return t.__nuxt_error = !0, t }, Un = globalThis.requestIdleCallback || (e => { const t = Date.now(), s = { didTimeout: !1, timeRemaining: () => Math.max(0, 50 - (Date.now() - t)) }; return setTimeout(() => { e(s) }, 1) }), td = globalThis.cancelIdleCallback || (e => { clearTimeout(e) }), po = e => { const t = le(); t.isHydrating ? t.hooks.hookOnce("app:suspense:resolve", () => { Un(e) }) : Un(e) }, sd = { componentName: "NuxtLink" }, nd = "#__nuxt"; async function sc(e, t = Ft()) { const { path: s, matched: n } = t.resolve(e); if (!n.length || (t._routePreloaded || (t._routePreloaded = new Set), t._routePreloaded.has(s))) return; const o = t._preloadPromises = t._preloadPromises || []; if (o.length > 4) return Promise.all(o).then(() => sc(e, t)); t._routePreloaded.add(s); const r = n.map(i => { var c; return (c = i.components) == null ? void 0 : c.default }).filter(i => typeof i == "function"); for (const i of r) { const c = Promise.resolve(i()).catch(() => { }).finally(() => o.splice(o.indexOf(c))); o.push(c) } await Promise.all(o) } function od(e = {}) { const t = e.path || window.location.pathname; let s = {}; try { s = Bs(sessionStorage.getItem("nuxt:reload") || "{}") } catch { } if (e.force || (s == null ? void 0 : s.path) !== t || (s == null ? void 0 : s.expires) < Date.now()) { try { sessionStorage.setItem("nuxt:reload", JSON.stringify({ path: t, expires: Date.now() + (e.ttl ?? 1e4) })) } catch { } if (e.persistState) try { sessionStorage.setItem("nuxt:reload:state", JSON.stringify({ state: le().payload.state })) } catch { } window.location.pathname !== t ? window.location.href = t : window.location.reload() } } const rd = (...e) => e.find(t => t !== void 0), id = "noopener noreferrer";/*! @__NO_SIDE_EFFECTS__ */function cd(e) { const t = e.componentName || "NuxtLink", s = (n, o) => { if (!n || e.trailingSlash !== "append" && e.trailingSlash !== "remove") return n; const r = e.trailingSlash === "append" ? Ls : uo; if (typeof n == "string") return r(n, !0); const i = "path" in n ? n.path : o(n).path; return { ...n, name: void 0, path: r(i, !0) } }; return Ys({ name: t, props: { to: { type: [String, Object], default: void 0, required: !1 }, href: { type: [String, Object], default: void 0, required: !1 }, target: { type: String, default: void 0, required: !1 }, rel: { type: String, default: void 0, required: !1 }, noRel: { type: Boolean, default: void 0, required: !1 }, prefetch: { type: Boolean, default: void 0, required: !1 }, noPrefetch: { type: Boolean, default: void 0, required: !1 }, activeClass: { type: String, default: void 0, required: !1 }, exactActiveClass: { type: String, default: void 0, required: !1 }, prefetchedClass: { type: String, default: void 0, required: !1 }, replace: { type: Boolean, default: void 0, required: !1 }, ariaCurrentValue: { type: String, default: void 0, required: !1 }, external: { type: Boolean, default: void 0, required: !1 }, custom: { type: Boolean, default: void 0, required: !1 } }, setup(n, { slots: o }) { const r = Ft(), i = Ms(() => { const f = n.to || n.href || ""; return s(f, r.resolve) }), c = Ms(() => n.external || n.target && n.target !== "_self" ? !0 : typeof i.value == "object" ? !1 : i.value === "" || cs(i.value, { acceptRelative: !0 })), l = be(!1), u = be(null), a = f => { var p; u.value = n.custom ? (p = f == null ? void 0 : f.$el) == null ? void 0 : p.nextElementSibling : f == null ? void 0 : f.$el }; if (n.prefetch !== !1 && n.noPrefetch !== !0 && n.target !== "_blank" && !ld()) { const p = le(); let _, A = null; Xs(() => { const R = ad(); po(() => { _ = Un(() => { var j; (j = u == null ? void 0 : u.value) != null && j.tagName && (A = R.observe(u.value, async () => { A == null || A(), A = null; const v = typeof i.value == "string" ? i.value : r.resolve(i.value).fullPath; await Promise.all([p.hooks.callHook("link:prefetch", v).catch(() => { }), !c.value && sc(i.value, r).catch(() => { })]), l.value = !0 })) }) }) }), to(() => { _ && td(_), A == null || A(), A = null }) } return () => { var R, j; if (!c.value) { const v = { ref: a, to: i.value, activeClass: n.activeClass || e.activeClass, exactActiveClass: n.exactActiveClass || e.exactActiveClass, replace: n.replace, ariaCurrentValue: n.ariaCurrentValue, custom: n.custom }; return n.custom || (l.value && (v.class = n.prefetchedClass || e.prefetchedClass), v.rel = n.rel), Cn(Ua("RouterLink"), v, o.default) } const f = typeof i.value == "object" ? ((R = r.resolve(i.value)) == null ? void 0 : R.href) ?? null : i.value || null, p = n.target || null, _ = n.noRel ? null : rd(n.rel, e.externalRelAttribute, f ? id : "") || null, A = () => ec(f, { replace: n.replace }); return n.custom ? o.default ? o.default({ href: f, navigate: A, get route() { if (!f) return; const v = Qt(f); return { path: v.pathname, fullPath: v.pathname, get query() { return lo(v.search) }, hash: v.hash, params: {}, name: void 0, matched: [], redirectedFrom: void 0, meta: {}, href: f } }, rel: _, target: p, isExternal: c.value, isActive: !1, isExactActive: !1 }) : null : Cn("a", { ref: u, href: f, rel: _, target: p }, (j = o.default) == null ? void 0 : j.call(o)) } } }) } const nc = cd(sd); function ad() { const e = le(); if (e._observer) return e._observer; let t = null; const s = new Map, n = (r, i) => (t || (t = new IntersectionObserver(c => { for (const l of c) { const u = s.get(l.target); (l.isIntersecting || l.intersectionRatio > 0) && u && u() } })), s.set(r, i), t.observe(r), () => { s.delete(r), t.unobserve(r), s.size === 0 && (t.disconnect(), t = null) }); return e._observer = { observe: n } } function ld() { const e = navigator.connection; return !!(e && (e.saveData || /2g/.test(e.effectiveType))) } const ud = { nuxt: { buildId: "884b7617-275c-4117-8ba5-0f68600f9488" } }, fd = Jf(ud); function dd() { const e = le(); return e._appConfig || (e._appConfig = Ze(fd)), e._appConfig } let xs, oc; function hd() { var s; const e = Ot(), t = (s = dd().nuxt) == null ? void 0 : s.buildId; return xs = $fetch(ct(e.app.cdnURL || e.app.baseURL, e.app.buildAssetsDir, `builds/meta/${t}.json`)), xs.then(n => { oc = Ff(n.matcher) }), xs } function en() { return xs || hd() } async function rc(e) { return await en(), Df({}, ...oc.matchAll(e).reverse()) } function gr(e, t = {}) { const s = pd(e, t), n = le(), o = n._payloadCache = n._payloadCache || {}; return s in o || (o[s] = _d().then(r => r ? ic(s).then(i => i || (delete o[s], null)) : (o[s] = null, null))), o[s] } const mr = "json"; function pd(e, t = {}) { const s = new URL(e, "http://localhost"); if (s.search) throw new Error("Payload URL cannot contain search params: " + e); if (s.host !== "localhost" || cs(s.pathname, { acceptRelative: !0 })) throw new Error("Payload URL must not include hostname: " + e); const n = t.hash || (t.fresh ? Date.now() : ""); return ct(Ot().app.baseURL, s.pathname, n ? `_payload.${n}.${mr}` : `_payload.${mr}`) } async function ic(e) { const t = fetch(e).then(s => s.text().then(cc)); try { return await t } catch (s) { console.warn("[nuxt] Cannot load payload ", e, s) } return null } async function _d(e = Gi().path) { if (le().payload.prerenderedAt || (await en()).prerendered.includes(e)) return !0; const n = await rc(e); return !!n.prerender && !n.redirect } let bs = null; async function gd() { if (bs) return bs; const e = document.getElementById("__NUXT_DATA__"); if (!e) return {}; const t = cc(e.textContent || ""), s = e.dataset.src ? await ic(e.dataset.src) : void 0; return bs = { ...t, ...s, ...window.__NUXT__ }, bs } function cc(e) { return rf(e, le()._payloadRevivers) } function md(e, t) { le()._payloadRevivers[e] = t } const vr = { NuxtError: e => tc(e), EmptyShallowRef: e => Io(e === "_" ? void 0 : e === "0n" ? BigInt(0) : Bs(e)), EmptyRef: e => be(e === "_" ? void 0 : e === "0n" ? BigInt(0) : Bs(e)), ShallowRef: e => Io(e), ShallowReactive: e => $r(e), Ref: e => be(e), Reactive: e => Ze(e) }, vd = at({ name: "nuxt:revive-payload:client", order: -30, async setup(e) { let t, s; for (const n in vr) md(n, vr[n]); Object.assign(e.payload, ([t, s] = Ni(() => e.runWithContext(gd)), t = await t, s(), t)), window.__NUXT__ = e.payload } }), Ad = [], bd = at({ name: "nuxt:head", enforce: "pre", setup(e) { const t = Uf({ plugins: Ad }); Nf(() => le().vueApp._context.provides.usehead), e.vueApp.use(t); { let s = !0; const n = async () => { s = !1, await Ji(t) }; t.hooks.hook("dom:beforeRender", o => { o.shouldRender = !s }), e.hooks.hook("page:start", () => { s = !0 }), e.hooks.hook("page:finish", () => { e.isHydrating || n() }), e.hooks.hook("app:error", n), e.hooks.hook("app:suspense:resolve", n) } } }), yd = async e => { let t, s; const n = ([t, s] = Ni(() => rc(e.path)), t = await t, s(), t); if (n.redirect) return n.redirect }, kd = [yd]; function pn(e) { typeof e == "object" && (e = Bi({ pathname: e.path || "", search: Pi(e.query || {}), hash: e.hash || "" })); const t = Qt(e.toString()); return { path: t.pathname, fullPath: e, query: lo(t.search), hash: t.hash, params: {}, name: void 0, matched: [], redirectedFrom: void 0, meta: {}, href: e } } const wd = at({ name: "nuxt:router", enforce: "pre", setup(e) { const t = hu(window.location.pathname, Ot().app.baseURL) + window.location.search + window.location.hash, s = [], n = { "navigate:before": [], "resolve:before": [], "navigate:after": [], error: [] }, o = (a, f) => (n[a].push(f), () => n[a].splice(n[a].indexOf(f), 1)), r = Ot().app.baseURL, i = Ze(pn(t)); async function c(a, f) { try { const p = pn(a); for (const _ of n["navigate:before"]) { const A = await _(p, i); if (A === !1 || A instanceof Error) return; if (typeof A == "string" && A.length) return c(A, !0) } for (const _ of n["resolve:before"]) await _(p, i); Object.assign(i, p), window.history[f ? "replaceState" : "pushState"]({}, "", ct(r, p.fullPath)), e.isHydrating || await e.runWithContext(Gf); for (const _ of n["navigate:after"]) await _(p, i) } catch (p) { for (const _ of n.error) await _(p) } } const l = { currentRoute: i, isReady: () => Promise.resolve(), options: {}, install: () => Promise.resolve(), push: a => c(a, !1), replace: a => c(a, !0), back: () => window.history.go(-1), go: a => window.history.go(a), forward: () => window.history.go(1), beforeResolve: a => o("resolve:before", a), beforeEach: a => o("navigate:before", a), afterEach: a => o("navigate:after", a), onError: a => o("error", a), resolve: pn, addRoute: (a, f) => { s.push(f) }, getRoutes: () => s, hasRoute: a => s.some(f => f.name === a), removeRoute: a => { const f = s.findIndex(p => p.name === a); f !== -1 && s.splice(f, 1) } }; e.vueApp.component("RouterLink", { functional: !0, props: { to: String, custom: Boolean, replace: Boolean, activeClass: String, exactActiveClass: String, ariaCurrentValue: String }, setup: (a, { slots: f }) => { const p = () => c(a.to, a.replace); return () => { var A; const _ = l.resolve(a.to); return a.custom ? (A = f.default) == null ? void 0 : A.call(f, { href: a.to, navigate: p, route: _ }) : Cn("a", { href: a.to, onClick: R => (R.preventDefault(), p()) }, f) } } }), window.addEventListener("popstate", a => { const f = a.target.location; l.replace(f.href.replace(f.origin, "")) }), e._route = i, e._middleware = e._middleware || { global: [], named: {} }; const u = e.payload.state._layout; return e.hooks.hookOnce("app:created", async () => { l.beforeEach(async (a, f) => { a.meta = Ze(a.meta || {}), e.isHydrating && u && !bt(a.meta.layout) && (a.meta.layout = u), e._processingMiddleware = !0; { const p = new Set([...kd, ...e._middleware.global]); for (const _ of p) { const A = await e.runWithContext(() => _(a, f)); if (A !== !0 && (A || A === !1)) return A } } }), l.afterEach(() => { delete e._processingMiddleware }), await l.replace(t), gu(i.fullPath, t) || await e.runWithContext(() => ec(i.fullPath)) }), { provide: { route: i, router: l } } } }), xd = at({ name: "nuxt:payload", setup(e) { Ft().beforeResolve(async (t, s) => { if (t.path === s.path) return; const n = await gr(t.path); n && Object.assign(e.static.data, n.data) }), po(() => { var t; e.hooks.hook("link:prefetch", async s => { Qt(s).protocol || await gr(s) }), ((t = navigator.connection) == null ? void 0 : t.effectiveType) !== "slow-2g" && setTimeout(en, 1e3) }) } }), Ed = at({ name: "nuxt:global-components" }), Cd = at({ name: "nuxt:chunk-reload", setup(e) { const t = Ft(), s = Ot(), n = new Set; t.beforeEach(() => { n.clear() }), e.hook("app:chunkError", ({ error: r }) => { n.add(r) }); function o(r) { const c = "href" in r && r.href.startsWith("#") ? s.app.baseURL + r.href : ct(s.app.baseURL, r.fullPath); od({ path: c, persistState: !0 }) } e.hook("app:manifest:update", () => { t.beforeResolve(o) }), t.onError((r, i) => { n.has(r) && o(i) }) } }), Rd = at(e => { let t; const s = Ot(); async function n() { const o = await en(); t && clearTimeout(t), t = setTimeout(n, 1e3 * 60 * 60); const r = await $fetch(ct(s.app.cdnURL || s.app.baseURL, s.app.buildAssetsDir, "builds/latest.json")); r.id !== o.id && e.hooks.callHook("app:manifest:update", r) } po(() => { t = setTimeout(n, 1e3 * 60 * 60) }) }), Td = at(() => ({ provide: { windowWidth: be(window.innerWidth) } })), Id = [vd, bd, wd, xd, Ed, Cd, Rd, Td]; const ue = (e, t) => { const s = e.__vccOpts || e; for (const [n, o] of t) s[n] = o; return s }, Pd = {}, Sd = { href: "https://kupikod.com/shop/?utm_source=kupikod.com", target: "_blank", class: "block-10k-games" }, Md = we('<svg class="block-10k-games__bg-figure" width="554" height="544" viewBox="0 0 554 544" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-593eb48c><path fill-rule="evenodd" clip-rule="evenodd" d="M111.907 272L0 207.371L82.4819 64.6294L194.454 129.147L194.517 0H359.483L359.546 129.147L471.517 64.6294L554 207.371L442.092 272L554 336.629L471.517 479.371L359.546 414.853L359.483 544H194.517L194.454 414.853L82.4819 479.371L0 336.629L111.907 272Z" fill="#00FF92" fill-opacity="0.05" data-v-593eb48c></path></svg><div class="block-10k-games__description" data-v-593eb48c> Делаем игры доступными, чтобы вам не приходилось грустить </div><div class="block-10k-games__title" data-v-593eb48c> 10 000+ игр<span data-v-593eb48c>В каталоге Kupikod</span></div><svg class="block-10k-games__arrow" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-593eb48c><path opacity="0.5" d="M2 18L18 2M18 2H2M18 2V18" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" data-v-593eb48c></path></svg>', 4), Bd = [Md]; function Hd(e, t) { return O(), K("a", Sd, Bd) } const Ld = ue(Pd, [["render", Hd], ["__scopeId", "data-v-593eb48c"]]), Od = "data:image/webp;base64,UklGRsYFAABXRUJQVlA4WAoAAAAQAAAAQwAAJwAAQUxQSIQBAAABkHPb1tpG795PVuIuMMxMHfbh/IakGrdTMVY8U4bTcjnMzMw8pRSqDX/gDcif1/LTmjoiJkDKgnRB2H7w2lRBtfj9dk/3+p1Hx9/Mqmrp7f1jHVtaT53/MaOq08+Hu5ZmazKBAwDxBUg3/2RevUsl9Z5T/8nObJghIb4AXEOfVveTjWFAAl7cm9eq7w8DRy/2qcV4nSOAJNQ/UpvxOkdIIvBJrcZrHZHUq3ajeUnYpZbHCIjIqsiUtvCfEbUdNVBklVrfA8iIuc+EROa0GU1q/wSPp8AjXEqBPD+lgK7Op0Gz/jfkUyFKg62X0oB7UuAxm1KgF5K31wI5bi6iSJ25HESk11hEQKQ+bytHiIjsMTXmkCC9huJ5hCTikZl4nYOUqf9kJF5PegC9Jr6sDyi+YC6qvoEFAcUfXDtWZU86woBABaBbNxb7lSqY8ytc66zNBI6QCgG6IOw4fe1rQbU4fedk94adu8fezKrq7K+L59q2tB6++6OoqtM3hruWZGvCgEQZVlA4IBwEAADwEwCdASpEACgAPpFCmkolo6IhpnVcqLASCWgMpJEOPYW3egdpTHulS22PmA84DTiI/R+zSODbr464h9KtjV9GPPv9XewV/Iv6l/w+xF6AH6NGpgPhvnXX6fuIJ4/TkRw3a72Xk/fAq3ljITZMyYIJuZyP6wYQxBe717toaLSei0GVQ3+TBbU7WyxRaDoUWkdVWSumW0RDlDlSRCPNIPK4yY2TqLi3S8AA/vlziPuh5CYHoZlVdwd9+cvkuXZ9BahVlIj8pqkx3SHRyBpwF0XSxoZ+lTfP4L7Ovw/gssRnVftPPkLZErAlC05G47OQDSuRWCEqBmWsat290VRCLsfSrYsiF7XMbHl8u1IMp4a8L2EgS4bfhK55sUiJfLXMpMx7NiwabfA7+Rp62TlVGj4q3h8DjPJ9irGhyZ4VKhH9OXQTy9FUz6IlooZj1N+uzxvy8MYPDwU/G0ZFtrBhp1afgobJNGC6L81y7/siTqaACVLSvS6IgfZco4jJyd+NGHrExW3TnkvlGI5NENjt20RfUYfbFF3MMas4NPP+nbkrJXT7uT/eyT8Pj8lBgVP0KELLtukk2Jcyd1RkQN47Or8cldLO3DS8UBSTmV8EqTzOmA+QrfKcN/U8+/ZQ695/wa/m5a9n/WP4UbS5/debOznvifWrQfU/x7+q1HeAn5KM/Xb4Z07hTfWxjZH3ie5fLZHqJbtj3+vpcbda8P6Qduo4MsqDRT+6Ameju8c7+HtEu9weQ9Lv7aO6R6L4+rvP/zyrVz4d8FNVaBLRMTU5QpGZgN68l7RwoNEY53D8eGbUaQR7JlARQ9Zf0evpfk4Wzze9BMYH/ACztzbG9f0goJqMLMAM1HnLRWLu+nnV+YYQGcm0quk7j5+LP86zhzb1qwDa1ZMEhPhmMQCNZ2pTz+fZ494aW+RcBq3ptvV3fRY2QSQdelb6lK3u/Ks/OmTwpN41X8V2h4fUEeKaOMvhLq/sUOJ101cvXy7Pd7pTNmrBaJfWgl2jlegzmuN0K0br8s42O7bFv1ua7/hzyMX13AtOP7fgR2ef8SvG9fYiFPDhHkNzCdfolr3+DO/aV3PWVvP6U9BmlUhskz/sHSyvzv4iZKps19/J8gVZb79jAZG0wvreboz+2CMRfJkCqYm22d6Qhc1ledmNCtZh+nIzYQf851F281kaj4tWrJup4BvfvEMs15Eqpg9wI28aIzJFF2QN2qeF6AmFo1vtdqjZGT2gQau63WjPtuuu42sTY09HIi6B5E663KndcWGwIkSWzoFdM6dkHWo3o+GqLyaYKzageh7z3JKPFZws8x027QUvhFOy+Z3H+YfeNpu8fkwEwnnezvriJhEJZ496jYvJNakr/YRlQL40aN9fybJNKBVNHqTfPhrj5BfDvHQAAA=="; const Ud = {}, Nd = { href: "https://vk.com/topic-215731237_49133433?utm_source=kupikod.com", target: "_blank", class: "block-read" }, jd = we('<div class="block-read__container" data-v-79f4e56f><svg class="block-read__figure" width="289" height="289" viewBox="0 0 289 289" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-79f4e56f><path d="M0 0H96.3338V96.3338H192.666V192.666H289V289H0V0Z" fill="white" fill-opacity="0.05" data-v-79f4e56f></path></svg><svg class="block-read__arrow" width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-79f4e56f><path opacity="0.5" d="M1 17L17 1M17 1H1M17 1V17" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-v-79f4e56f></path></svg><div class="regular-users" data-v-79f4e56f><div data-v-79f4e56f>400 000 +<img src="' + Od + '" data-v-79f4e56f></div><div data-v-79f4e56f><span data-v-79f4e56f>Регулярных юзеров</span></div></div><div class="block-read__text" data-v-79f4e56f>Почитай отзывы</div></div>', 1), $d = [jd]; function Qd(e, t) { return O(), K("a", Nd, $d) } const Fd = ue(Ud, [["render", Qd], ["__scopeId", "data-v-79f4e56f"]]), Dd = "" + new URL("YT-icon.c8fedaff.webp", import.meta.url).href, Jd = "" + new URL("twitch-icon.3ad4bd13.webp", import.meta.url).href; const Kd = {}, Wd = { class: "block-blog" }, Vd = we('<div class="block-blog__mobile_bg" data-v-901ce72e></div><svg class="block-blog__bg" width="233" height="282" viewBox="0 0 233 282" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-901ce72e><path d="M32 0H201C218.673 0 233 14.3269 233 32V109C233 126.673 218.673 141 201 141C218.673 141 233 155.327 233 173V250C233 267.673 218.673 282 201 282H32C14.3269 282 0 267.673 0 250V173C0 155.327 14.3269 141 32 141C14.3269 141 0 126.673 0 109V32C0 14.3269 14.3269 0 32 0Z" fill="url(#paint0_linear_315_1711)" fill-opacity="0.9" data-v-901ce72e></path><defs data-v-901ce72e><linearGradient id="paint0_linear_315_1711" x1="116.5" y1="0" x2="116.5" y2="282" gradientUnits="userSpaceOnUse" data-v-901ce72e><stop stop-color="#00FF92" data-v-901ce72e></stop><stop offset="0.9999" stop-color="#13C9C6" data-v-901ce72e></stop><stop offset="1" stop-color="#278EFF" data-v-901ce72e></stop></linearGradient></defs></svg><img class="block-blog__youtube" src="' + Dd + '" alt="" data-v-901ce72e><img class="block-blog__twitch" src="' + Jd + '" alt="" data-v-901ce72e><div class="block-blog__text" data-v-901ce72e><div class="block-blog__count" data-v-901ce72e>300+</div><div class="block-blog__description" data-v-901ce72e> Блогеров говорят о нас каждый день </div></div>', 5), qd = [Vd]; function Yd(e, t) { return O(), K("div", Wd, qd) } const ac = ue(Kd, [["render", Yd], ["__scopeId", "data-v-901ce72e"]]), Zd = "data:image/webp;base64,UklGRlIBAABXRUJQVlA4WAoAAAAQAAAAJAAAJAAAQUxQSOgAAAABgGpb2zLlmRncLbkTaRCdC7Do7onqVHeSu7tVu4aJaHJ3fZHve+f7EsSImAD85cMj9bnVHhHl6jHEbrwREfXqcKvYJXG9utjOJ5KnK3JM2yZ2tBKv2isS7jeKvBXEDnyQuMGxVnAOS22TN0l6EI1aEu5Y4FZ5QfJuN9SReJIV2HhD8uNEoJGklZwk4g66Az0kT+UU3MuucgDHWWJGcOCdOXT4a9kbcFsjrhXrd3BWSRQAXzNxzVA9R+wNZSu8VmWBq6xMZUD5ISNWAwLHZME6gPwTwQM0B278WtcFFO7TW5w+mGJ98K8IVlA4IEQAAACQBACdASolACUAPnUmkEekoiGhPH34AJAOiWkAAN88iBQDsr/XL10PAMyX+AAA/TH//9alj/xgGH/0iAe//DyygAAAAA==", Xd = "data:image/webp;base64,UklGRmABAABXRUJQVlA4WAoAAAAQAAAAIwAAIwAAQUxQSAMBAAABgKpts2rlp7m7D5Bdurt7dU3W3DpcgF/BqTSH5p4OB022qT5hzZ5DgxgRE4B/UD8iIm8pmswgOyKiQMPFzPyQYlSwnCmts1kL4NHgOSPwWioRKllMBrAsWL4AkKvbE9YAoFLgBgOWJpfFHMPXEjYEl8YlrECcFrjAnRE2XSQFW8K5h47ehVbYTgk8rAp3sumAfaAlWEl2LaFHbLpIgUGBjwNsXBaLrVBvCHxQ9yPYp+kS3wT3XaTCwC+xi1RY0DkGnBKfRat89lUlwKTER34aBG5pCgB0STyvAmYVJQDQKnG/DmkuHQakJzeAvNUrZrZIwMiP4XILgCfFwN6fiMjzN/7UAFZQOCA2AAAAkAMAnQEqJAAkAD55LpFHpKKhoTjIAJAPCWkAAOXND86Dan8feAD9Mf//1UFTf83Zqf6R4AAA", zd = "data:image/webp;base64,UklGRo4BAABXRUJQVlA4WAoAAAAQAAAAJAAAJAAAQUxQSCEBAAABkCvbtmlb89qMbNu2bdu2bSOy7Xtf7Ngvs23bmI/7vDW/ICImAHgXEgnWFxEA9mHaQDHBkES+FYlaFxI9ESSmC0js76PAd3+LgvrX8xQi8ZMcO/5lxAJ2Zs8RL4mzkjqCiD/a+NiIjHxHRPyWxM8LPyfF1e/417etEtz4hf7BJ28/+Ao53qkxkuAgbGnvGZKQ3TBx9NlX5PHr/YMDpenRge42IGXr7B+TUTWw7/Sj77x8fnh8s7c8PdLHEQSE4J/itqPvuFwvMZEAjvz/AgDlff/40icODEUmvv/xNYEfmIrt/tHBB4zN3yNekgbWgsuIecA+Bt8rEFD9dgYI8j3cpQCHh0jM55EYDCbRaE+iyJREmi6JSDUC/OLhOqJCzP4vAFZQOCBGAAAAEAQAnQEqJQAlAD55LpFHpKKhoTjIAJAPCWkAAOAW1ho3oUYF/zMbToAA/TH//9VL/+aKf/DcPL/SS0dP//1Oj///ZYAAAA==", Gd = "data:image/webp;base64,UklGRuoAAABXRUJQVlA4WAoAAAAQAAAAKgAADQAAQUxQSJ0AAAABgJpt27LsSeRvBDQzgGZ9NsAhkd1hAaIzABWWgAloHDT/3fUOr2ALRMQEkBnq/4WfiD6gXaEuNLUANK8Jnst1WRwDmFKImSMAJszMDuGb5ZIkSWfAhkTzP9AmaRd4I6VWB3i+NRzF5ZVIdycMgMdrca2B+Vm+m2JO9rrb7XZ7AMic5Y2UgubKdD0Tgy5jNNVZJymNWq3mkwVqtaICAFZQOCAmAAAA0AIAnQEqKwAOAD6RQJtJJaOioSqoALASCWkAAFH2AAD++E0AAAA=", eh = "data:image/webp;base64,UklGRmgBAABXRUJQVlA4WAoAAAAQAAAAJAAAGgAAQUxQSBoBAAAFgGPb1jHp1l9W22ZuDUCZItu2EdmZbXem3ByCbbsLzR81goiYAADgGmtqSAQCPpfD4RAES6mUyz8/P15fXl8fb05k+M3NS9MDg7Le8n0ATRlg+MzhFN5zYLw1ET0RzL3rYMOJObizbtVVIFTzkiAlO7CiJdViC6SfTQNzLWgo052nIIFRWLwFpUa1cUqARWykIYV2YR8NgEVmnIBUL9FDC2A14kIKNNlXebIYs6rxJ0C6VzZAzbTGVwiK7c/TVIxLQ8SgXH+5QO69OUYKGksP9snRnXL8zFcBH/muhQq4YySAuU8JgoaY64wFd8aDqXu7PUBSnKDByEroNn4TthbW+hKhgM/lcNgEoVQoZLLPj7e3l9uT3b1jqCxWUDggKAAAAPACAJ0BKiUAGwA+kUaeSyWjoqGlaACwEglpAAApQ23wAP74TQAAAAA=", th = "data:image/webp;base64,UklGRgABAABXRUJQVlA4WAoAAAAQAAAAJwAAJwAAQUxQSKQAAAABgFXbdtzmQhAEQxAEQwiExyBikMcgZuAwCCRBeBBOR00dPyNiAvTHvFaG11vTjamlpc6pLcBpgx9Ah2mwfQv7/i5dtlkGRdKTSJMecEoC7J/hgENSwD4pHUeStJ1FkzrLKjmgrpADsAVyAK6O0+yyvUvWGICrufJhJCkH7a728hGmHLS7er1+lIPmWjQUuAfgms3HrkVci7gWca0Y4FpyO4t+o1ZQOCA2AAAAUAMAnQEqKAAoAD6RPJlIJaOioS4oALASCWkAAG2YGbxroAAA/vhNErJP/+NGa/wZ///jDgAA"; const Ie = e => (Je("data-v-69b3cd9f"), e = e(), Ke(), e), sh = ["href"], nh = Ie(() => m("div", { class: "nav-item__img" }, [m("img", { src: Zd, alt: "" }), m("div", { class: "nav-item__badge" }, "50К+")], -1)), oh = Ie(() => m("div", { class: "nav-item__label" }, "Telegram", -1)), rh = [nh, oh], ih = ["href"], ch = Ie(() => m("div", { class: "nav-item__img" }, [m("img", { src: Xd, alt: "" }), m("div", { class: "nav-item__badge" }, "80К+")], -1)), ah = Ie(() => m("div", { class: "nav-item__label" }, "VK", -1)), lh = [ch, ah], uh = ["href"], fh = Ie(() => m("div", { class: "nav-item__img" }, [m("img", { src: zd, alt: "" })], -1)), dh = Ie(() => m("div", { class: "nav-item__label" }, "Dzen", -1)), hh = [fh, dh], ph = ["href"], _h = Ie(() => m("div", { class: "nav-item__img" }, [m("img", { src: Gd, alt: "" })], -1)), gh = Ie(() => m("div", { class: "nav-item__label" }, "DTF", -1)), mh = [_h, gh], vh = Ie(() => m("div", { class: "nav-item__img" }, [m("img", { src: eh, alt: "" })], -1)), Ah = Ie(() => m("div", { class: "nav-item__label" }, "YouTube", -1)), bh = [vh, Ah], yh = Ie(() => m("div", { class: "nav-item__img" }, [m("img", { src: th, alt: "" })], -1)), kh = Ie(() => m("div", { class: "nav-item__label" }, "Twitch", -1)), wh = [yh, kh], xh = { __name: "NavigationSocials", props: { activeTab: { default: null }, noBadges: { default: !1, type: Boolean }, activeItem: { type: String, default: "" }, items: { type: Array } }, setup(e) { return (t, s) => (O(), K("div", { class: _e(["social-nav", { "social-nav--no-badges": e.noBadges }]) }, [m("a", { onMouseover: s[0] || (s[0] = n => t.$emit("changeItem", "tg")), href: e.noBadges ? "https://t.me/steamkupikod?utm_source=kupikod.com" : "https://t.me/steamkupikod/1017?utm_source=kupikod.com", target: "_blank", class: _e(["nav-item nav-item--telegram", { "nav-item--active": e.activeItem == "tg" }]) }, rh, 42, sh), m("a", { onMouseover: s[1] || (s[1] = n => t.$emit("changeItem", "vk")), href: e.noBadges ? "https://vk.com/kupikod_com?utm_source=kupikod.com" : "https://vk.com/kupikod_com?w=wall-215731237_67866&utm_source=kupikod.com", target: "_blank", class: _e(["nav-item nav-item--vk", { "nav-item--active": e.activeItem == "vk" }]) }, lh, 42, ih), m("a", { onMouseover: s[2] || (s[2] = n => t.$emit("changeItem", "dzen")), href: e.noBadges ? "https://dzen.ru/kupikod?utm_source=kupikod.com?utm_source=kupikod.com" : "https://dzen.ru/media/kupikod/novye-igry-v-podpiske-xbox-game-pass-6540dbdca3eab52d9fd439ae?utm_source=kupikod.com", target: "_blank", class: _e(["nav-item nav-item--dzen", { "nav-item--active": e.activeItem == "dzen" }]) }, hh, 42, uh), m("a", { onMouseover: s[3] || (s[3] = n => t.$emit("changeItem", "dtf")), class: _e(["nav-item nav-item--dtf", { "nav-item--active": e.activeItem == "dtf" }]), target: "_blank", href: e.noBadges ? "https://dtf.ru/s/954970-kupikod?utm_source=kupikod.com" : "https://dtf.ru/games/2132943-voruy-ubivay-pokupay-shapki-obzor-payday-3?utm_source=kupikod.com" }, mh, 42, ph), e.noBadges ? (O(), K("a", { key: 0, onMouseover: s[4] || (s[4] = n => t.$emit("changeItem", "youtube")), class: _e(["nav-item nav-item--youtube", { "nav-item--active": e.activeItem == "youtube" }]), target: "_blank", href: "https://www.youtube.com/@kupikod/featured?utm_source=site&utm_medium=button&utm_campaign=promo" }, bh, 34)) : rs("", !0), e.noBadges ? (O(), K("a", { key: 1, onMouseover: s[5] || (s[5] = n => t.$emit("changeItem", "twitch")), class: _e(["nav-item nav-item--twitch", { "nav-item--active": e.activeItem == "twitch" }]), target: "_blank", href: "https://www.twitch.tv/kupikod?utm_source=site&utm_medium=button&utm_campaign=promo" }, wh, 34)) : rs("", !0)], 2)) } }, lc = ue(xh, [["__scopeId", "data-v-69b3cd9f"]]); const uc = e => (Je("data-v-9b8cf016"), e = e(), Ke(), e), Eh = { class: "block-read-us" }, Ch = uc(() => m("svg", { class: "block-read-us__stairs", width: "377", height: "453", viewBox: "0 0 377 453", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M377 0H251.333V151.001H125.667V301.999H-1.29938e-05V453H377V0Z", fill: "white", "fill-opacity": "0.05" })], -1)), Rh = uc(() => m("div", { class: "block-read-us__header" }, "Читай нас в соцсетях:", -1)), Th = { class: "block-read-us__content content" }, Ih = { class: "content__arrows" }, Ph = we('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-9b8cf016><g opacity="0.2" clip-path="url(#clip0_374_146)" data-v-9b8cf016><path d="M5 18L3.37766e-07 13L5 8" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-v-9b8cf016></path></g><defs data-v-9b8cf016><clipPath id="clip0_374_146" data-v-9b8cf016><rect width="24" height="24" fill="white" transform="matrix(-1 0 0 1 24 0)" data-v-9b8cf016></rect></clipPath></defs></svg>', 1), Sh = [Ph], Mh = we('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-9b8cf016><g opacity="0.2" clip-path="url(#clip0_374_148)" data-v-9b8cf016><path d="M19 18L24 13L19 8" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-v-9b8cf016></path></g><defs data-v-9b8cf016><clipPath id="clip0_374_148" data-v-9b8cf016><rect width="24" height="24" fill="white" data-v-9b8cf016></rect></clipPath></defs></svg>', 1), Bh = [Mh], Hh = { class: "content__text" }, Lh = ["href"], Oh = { __name: "BlockReadUs", setup(e) { const t = be("tg"), s = r => t.value = r, n = r => { const i = Object.keys(o), c = i.findIndex(l => l == t.value.toString()); r == "next" ? c + 1 < 4 ? t.value = i[c + 1] : t.value = i[0] : c - 1 < 0 ? t.value = i[3] : t.value = i[c - 1] }, o = { tg: { description: "Cистемные требования Call of Duty: Modern Warfare III 🔫", link: "https://t.me/steamkupikod/1017?utm_source=kupikod.com" }, vk: { description: "Актуальные скидки в Steam", link: "https://vk.com/kupikod_com?w=wall-215731237_67866&utm_source=kupikod.com" }, dzen: { description: "Новые игры в подписке XBOX Game Pass", link: "https://dzen.ru/media/kupikod/novye-igry-v-podpiske-xbox-game-pass-6540dbdca3eab52d9fd439ae?utm_source=kupikod.com" }, dtf: { description: "Воруй, убивай, покупай шапки. Обзор Payday 3 ", link: "https://dtf.ru/games/2132943-voruy-ubivay-pokupay-shapki-obzor-payday-3?utm_source=kupikod.com" } }; return (r, i) => { const c = ac, l = lc; return O(), K("div", Eh, [Ch, Rh, U(c, { class: "block-read-us__blogers" }), m("div", Th, [m("div", Ih, [m("div", { class: "content__arrow content__arrow--back", onClick: i[0] || (i[0] = u => n("prev")) }, Sh), m("div", { class: "content__arrow content__arrow--next", onClick: i[1] || (i[1] = u => n("next")) }, Bh)]), m("div", Hh, Me(o[ne(t)].description), 1), m("a", { class: "content__link", target: "_blank", href: o[ne(t)].link }, Me(o[ne(t)].link), 9, Lh)]), U(l, { onChangeItem: s, activeItem: ne(t), class: "block-read-us__nav" }, null, 8, ["activeItem"])]) } } }, Uh = ue(Oh, [["__scopeId", "data-v-9b8cf016"]]); const Nh = {}, fc = e => (Je("data-v-7c9632e6"), e = e(), Ke(), e), jh = { id: "section-title", class: "section-title" }, $h = fc(() => m("h1", { class: "section-title__title" }, " Покупай и пополняй игры без головной боли ", -1)), Qh = fc(() => m("div", { class: "section-title__description" }, " Игры, подписки софт для РФ и не только ", -1)), Fh = { class: "container" }, Dh = { class: "section-title__grid" }; function Jh(e, t) { const s = Ld, n = Fd, o = ac, r = Uh; return O(), K("div", jh, [$h, Qh, m("div", Fh, [m("div", Dh, [U(s), U(n), U(o, { class: "section-title__300-blogers--desktop" }), U(r, { class: "section-title__read-us" })])])]) } const Kh = ue(Nh, [["render", Jh], ["__scopeId", "data-v-7c9632e6"]]), Wh = "" + new URL("block-gift-line.8038b851.webp", import.meta.url).href, Vh = "" + new URL("block-gift-cards.1c455de7.webp", import.meta.url).href; const qh = {}, Yh = { href: "https://steam.kupikod.com/ru-ru/games?utm_source=kupikod.com", target: "_blank", class: "block-gifts" }, Zh = we('<div class="block-gifts__container" data-v-9dbd36e5><div class="block-gifts__backdrop" data-v-9dbd36e5></div><div class="block-gifts__text" data-v-9dbd36e5><div class="block-gifts__header" data-v-9dbd36e5>Steam Gifts</div><div class="block-gifts__description" data-v-9dbd36e5>Игры недоступные в РФ</div></div><img class="block-gifts__img-line" src="' + Wh + '" alt="" data-v-9dbd36e5><svg class="block-gifts__arrow" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-9dbd36e5><path d="M2 14L14 2M14 2H2M14 2V14" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" data-v-9dbd36e5></path></svg></div><img class="block-gifts__img-cards" src="' + Vh + '" alt="" data-v-9dbd36e5>', 2), Xh = [Zh]; function zh(e, t) { return O(), K("a", Yh, Xh) } const Gh = ue(qh, [["render", zh], ["__scopeId", "data-v-9dbd36e5"]]), ep = "" + new URL("block-skins-guns.32f23246.webp", import.meta.url).href; const tp = {}, sp = { href: "https://steam.kupikod.com/skins", target: "_blank", class: "block-skins" }, np = we('<div class="block-skins__text" data-v-c19425ec><div class="block-skins__header" data-v-c19425ec>Пополняй Steam скинами</div><div class="block-skins__description" data-v-c19425ec>Комиссия 0%</div></div><svg class="block-skins__arrow" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-c19425ec><path d="M2 14L14 2M14 2H2M14 2V14" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" data-v-c19425ec></path></svg><img class="block-skins__img-gun" src="' + ep + '" alt="" data-v-c19425ec><div class="block-skins__backdrop" data-v-c19425ec></div><div class="block-skins__bg" data-v-c19425ec></div>', 5), op = [np]; function rp(e, t) { return O(), K("a", sp, op) } const ip = ue(tp, [["render", rp], ["__scopeId", "data-v-c19425ec"]]), cp = "" + new URL("block-codes-cards.ea36c931.webp", import.meta.url).href; const ap = {}, _o = e => (Je("data-v-5079c060"), e = e(), Ke(), e), lp = { href: "https://kupikod.com/shop/?utm_source=kupikod.com", target: "_blank", class: "block-codes" }, up = _o(() => m("img", { class: "block-codes__img", src: cp }, null, -1)), fp = _o(() => m("div", { class: "block-codes__text" }, [Xe(" Коды"), m("br"), Xe(" активации ")], -1)), dp = _o(() => m("svg", { class: "block-codes__arrow", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [m("path", { d: "M2 14L14 2M14 2H2M14 2V14", stroke: "white", "stroke-width": "3", "stroke-linecap": "round", "stroke-linejoin": "round" })], -1)), hp = [up, fp, dp]; function pp(e, t) { return O(), K("a", lp, hp) } const _p = ue(ap, [["render", pp], ["__scopeId", "data-v-5079c060"]]), gp = "" + new URL("block-genshin-box.8a8b18b8.webp", import.meta.url).href, mp = "" + new URL("block-genshin-paymon.a557750c.webp", import.meta.url).href; const vp = {}, Ap = { href: "https://kupikod.com/gold/", target: "_blank", class: "block-genshin" }, bp = we('<img src="' + gp + '" alt="" class="block-genshin__img-box" data-v-a3780212><img src="' + mp + '" alt="" class="block-genshin__img-paymon" data-v-a3780212><div class="block-genshin__text" data-v-a3780212><div class="block-genshin__title" data-v-a3780212>Genshin Impact</div><div class="block-genshin__description" data-v-a3780212>Самые дешевые примогемы</div></div><svg class="block-genshin__arrow" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-a3780212><path d="M2 14L14 2M14 2H2M14 2V14" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" data-v-a3780212></path></svg>', 4), yp = [bp]; function kp(e, t) { return O(), K("a", Ap, yp) } const wp = ue(vp, [["render", kp], ["__scopeId", "data-v-a3780212"]]), xp = "" + new URL("block-consoles-1.d77201ec.webp", import.meta.url).href, Ep = "" + new URL("block-consoles-2.436b94e8.webp", import.meta.url).href; const Cp = {}, Rp = { href: "https://kupikod.com/shop/?utm_source=kupikod.com", target: "_blank", class: "block-consoles" }, Tp = we('<img src="' + xp + '" alt="" class="block-consoles__img-1" data-v-effa2e7c><img src="' + Ep + '" alt="" class="block-consoles__img-2" data-v-effa2e7c><div class="block-consoles__text" data-v-effa2e7c>Подписки:<br data-v-effa2e7c>Xbox<br data-v-effa2e7c>Playstation</div><svg class="block-consoles__arrow" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-effa2e7c><path d="M2 14L14 2M14 2H2M14 2V14" stroke="#131313" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" data-v-effa2e7c></path></svg>', 4), Ip = [Tp]; function Pp(e, t) { return O(), K("a", Rp, Ip) } const Sp = ue(Cp, [["render", Pp], ["__scopeId", "data-v-effa2e7c"]]), Mp = "" + new URL("block-clash-persons.beb6f470.webp", import.meta.url).href, Bp = "" + new URL("block-clash-line.fa2144f3.webp", import.meta.url).href; const Hp = {}, Lp = e => (Je("data-v-535f647c"), e = e(), Ke(), e), Op = { href: "https://kupikod.com/gold/", target: "_blank", class: "block-clash" }, Up = Lp(() => m("div", { class: "block-clash__container" }, [m("img", { src: Mp, alt: "", class: "block-clash__img-person" }), m("img", { src: Bp, alt: "", class: "block-clash__img-line" }), m("div", { class: "block-clash__text" }, "Пополнение мобильных игр")], -1)), Np = [Up]; function jp(e, t) { return O(), K("a", Op, Np) } const $p = ue(Hp, [["render", jp], ["__scopeId", "data-v-535f647c"]]), Qp = "" + new URL("block-steam-line-2.d543b103.webp", import.meta.url).href, Fp = "" + new URL("block-steam-pet.6621b9b6.webp", import.meta.url).href, Ar = "" + new URL("block-steam-line-1.df301517.webp", import.meta.url).href, Dp = "data:image/webp;base64,UklGRoAIAABXRUJQVlA4WAoAAAAQAAAAbgAAbgAAQUxQSJMCAAABkETbsmk79WPbtm3btm3btm3bZsu2bdv5fK44derstJJGREwA/ccwVOQE6bLlzpY2QTh8yWrN2HLpjZt/6nW8urhvdPPkYUDFrbfykZdF766pnxBO1Dp7fWwyZGf1aEgyzfvM5j/MTwnCL89WBytdngVBug2s2L0yhW2RxrtYt3twZKsK3mT9N4vaE3oYW+k/LrIlSY6yrXsTWZH3A9v7KIcFtRxs85vS6jp72fKOyvr52HZPK1VtGaC3jqJybgTM5dSk9meMz9Ipif2QUd5LqmM149yooi0j7a4guT+UD+nN7Wes2/1MtWa0DQzFegTnZRgzAxnvUCMJHgN6EdPESEbc04DfI0jPIso1Zcy15Y6AOiCWhkEHxpHqgor7SV2FdUIotj8sR3yZ+oy7nsxKYGNlzgI7IxLJAyw4skReRp5OojG0BhJ9oQ2SmAdtgcQOaJsljkM7IHEF2jGJ29DOSdz521yDdlTiBLT9Eruh7ZRYDG25xEhoEyQaQWsjkRNaAYlQn4A5I0rQeWDXSXQusDUyDYFVl0kCLI0MXYN1lYQHweooVQBWDim6B+oiiU8A1UYumT+k52HlaAukaWQwjw+QL4UJWgJoGBlN/BnOq4RmaBScnmTY7w6YB9FMUXEw2cn8ciijSGHYa0DOkMrMHhjvkuugyl4QrnKkdSCIEaR3LIQxpDjieABjQ2simm3dTNI+0rKRpN6vi8OigLZkY8G31jwoSnYmPWvJjuRk7fAvFnzqH5YsTr9X3b4UZHnpm6ruVCWAna6pedImCkH0a3pKxdmWoQhnzrnPDH0Yl5PA+pVbeNkn5Lg7sXBkgpys7rj9j3y/5b69Y2ajeAQ9bNjMRas1b9OuXdO6ZVNFpH+mAQBWUDggxgUAADAaAJ0BKm8AbwA+kTyYSKWjIiEsdR2YsBIJaAhwByA34WIW152/m/PHsD+W4mNIdh71E7bDzG/t9+sHvM+lneT95frR/K8bgdgDeYrpOM3SKTL/GJ9W+wb0nf2W9klRyRbAu0KVxv05EsvduBt8VYuAJN3ykf+ZroOyUS0YbisfB66MfNZyBWWdIKK3OlYm1WPErouRNBqSK/mgDXZHpozm9MwSmOmXP2jLkIbMeweDXvnoJxirAkyLEHl34cy48wmMwIAizuwZaGdSb6ywT4P3nk13e9qOiIQgAP7NcBsRSX/nVaAzP9Gf+y0L9/I9KlZD0ohCOivDo3+i+tBOmZn80FzbTyETVFyVjSdin+ActafwlCyWEABkj4ehXjecTZ0YxXyqSTSUxM2ubYbGjEJ8KcBHog/U+ZurFfnL/ydmFk2cNrj5Qes1XROg5L85/aY28Ml/wm4D3r7ThdsLYlEL1HB+bUrB2KAe1BSzxrpuRTOfNhLbJoGNtgtz9WNXThfVMUdp4aLt9xMemr/vLjQaVFqo2alLIq61nKDXJir9onb3/p4iwBv81lkW9i8jgEhOKJyEvNGiPGJMtSKTvFpiHYLbKbxHDrSCTbRev7fcVZBdwRXwtajk9mZ2MNX9afv1A4Bj8iRUnciewX6h7iZ1T67EMfm9oqmYcW7Vs5l4jsuirCi3xGS4xQW8fmrob5Cp7vz6MdhI3lQffuT8pVJQKo5sWYJaOOeu3BGAAYxZnFkFjhkwQdjKBHvGamAhc49jb/68SP0solzv7ADvY61PvvKsTgkKOk/muwxM+UZyAAkOg0HI+RPriOzEQqX26FmecQPQgbf6Pzobb4/Ye4GSoTUf0VGC69UCj//Si6wAEyK2iOcGPg4G1SpKyHoQJubNHLRwu3gLph+bp6/Cjsyr0nn89quirB/XG8HKsKJ+RtCYqPJ0RB9T/hbyMsWL10ywWaggD3Vf06EskXLnPH77uyOSPwhizHydfy+Ub5A04wgzP0WsPXuOhxn6BahjMfY4xYaspmXi3R4vR4gyYYmxlBbFDWaEuOK8Wk3JuyLzV2cUolhVV8Rbi4m8EA/lO3hQdzRTcgE0CavuuoVI5lhJhfBz1HjC4x9DrrbcG7C1C4q1YQep1wJzNz3vS0C9ai0Z2nU/QmJ2N4vBjqksQ0sbD5vr1mv9UYttf+om6sxlX/WiXPl4qBs3bLHc+i/RiCOGwS9sJKImK1bD21peEkXyQS69hxF0/h2fE9w0NPL7NSqNE9RZDRnEgvM8iv89rEFj3meVtGfq0KlYj2sdlElGDSjMaAVuM7FHIRRtQRuiSOuW/DZKkt2hOuqEHf47MOo6kg3E/Tj++O3ygRBO0tuCsnr/3z9YO0wmBPPD9/CkOK6FTZXVElU1Gjz5te37k0ZtxIeNJPZG89g4NFThecFCJtNn6gJHg8emVeg9gjAU9hT4TKj+uOAfX4EJV9mVDUnKocYIZsPeJDHB/4d29KJsyTxpl/dvPW6ZYc2bSMNryXhybj0J+e5rGTZMkWJc6FodFSfuefd/htDPf41dEH0x5s6rdvtsEYQjxbYi8CuQwFiuqKeRbLv/27zuQkeFcQoJdf0DaPZo/10KUfkeROM4sOfrRAHpcihCDQJ4Q9hBeks9zn0SIsnY/i5r9C6GkT0Nb6N2ZutqTx0XOWTdYVFhUH1Uj/zH9tNt4JqKQAHA/8hNu5lUMCecWZ+cEDm+8GIq3q/YPLRXS2AwwEelhMuXE1C+7WT9g2KSi0tDveXRvy1wfwvblL0xYoubZGU17pz7pJ+lR0QRNvU1zKOnf1KZJPyfkh3JViayj+CLhNUMPfwBNOtlmlnr8jrnwB86iUAVs89sO+ZyNaZhh24lFNRSG6XTUtvPOb+SFIue5UuA9Dy/JOSJH9Vz1L+7cglqOCkKK/Dc7xFLHvdXmtnxmZwP2JMIw0l2rb/uhb8/HBEsHeDyEAAA"; const Jp = {}, Kp = { href: "https://steam.kupikod.com", target: "_blank", class: "block-steam" }, Wp = we('<div class="block-steam__container" data-v-a3370276><img src="' + Qp + '" alt="" class="block-steam__img-line-2" data-v-a3370276><img src="' + Fp + '" alt="" class="block-steam__img-pet" data-v-a3370276><img src="' + Ar + '" alt="" class="block-steam__img-line-1" data-v-a3370276><img src="' + Ar + '" alt="" class="block-steam__img-line-3" data-v-a3370276><div class="block-steam__backdrop-1" data-v-a3370276></div><div class="block-steam__backdrop-2" data-v-a3370276></div><svg class="block-steam__arrow" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-a3370276><path d="M2 13.6446L14 1.64459M14 1.64459H2M14 1.64459V13.6446" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" data-v-a3370276></path></svg><div class="block-steam__text" data-v-a3370276><div href="https://steam.kupikod.com" class="block-steam__title" data-v-a3370276>Пополнение Steam</div><div class="block-steam__description" data-v-a3370276> Моментально<br data-v-a3370276> и безопасно </div></div></div><div class="block-steam__icon icon" data-v-a3370276><img src="' + Dp + '" alt="" class="icon__img" data-v-a3370276><div class="icon__text" data-v-a3370276>Steam</div></div>', 2), Vp = [Wp]; function qp(e, t) { return O(), K("a", Kp, Vp) } const Yp = ue(Jp, [["render", qp], ["__scopeId", "data-v-a3370276"]]); const Zp = {}, dc = e => (Je("data-v-3ca4c476"), e = e(), Ke(), e), Xp = { class: "section-our-products" }, zp = dc(() => m("div", { id: "section-our-products", class: "--anchor" }, null, -1)), Gp = { class: "container" }, e_ = dc(() => m("div", { class: "section-our-products__header" }, [m("div", { class: "section-our-products__title" }, "Наши продукты"), m("div", { class: "section-our-products__description" }, " Купикод — это не только игры и софт для геймеров. Мы организовываем киберспортивные мероприятия, участвуем в съемках и у нас есть свой продакшн в медиа. ")], -1)), t_ = { class: "section-our-products__grid" }; function s_(e, t) { const s = Gh, n = ip, o = _p, r = wp, i = Sp, c = $p, l = Yp; return O(), K("div", Xp, [zp, m("div", Gp, [e_, m("div", t_, [U(s, { class: "grid-item grid-item--gift" }), U(n, { class: "grid-item grid-item--skins" }), U(o, { class: "grid-item grid-item--codes" }), U(r, { class: "grid-item grid-item--genshin" }), U(i, { class: "grid-item grid-item--consoles" }), U(c, { class: "grid-item grid-item--clash" }), U(l, { class: "grid-item grid-item--steam" })])])]) } const n_ = ue(Zp, [["render", s_], ["__scopeId", "data-v-3ca4c476"]]); const o_ = {}, r_ = { class: "section-bonus-system" }, i_ = we('<div id="section-bonus-system" class="--anchor" data-v-1ad72289></div><div class="section-bonus-system__bg" data-v-1ad72289></div><div class="container" data-v-1ad72289><div class="section-bonus-system__window window" data-v-1ad72289><div class="window__title" data-v-1ad72289> Экономь на пополнении с бонусной системой </div><div class="window__description" data-v-1ad72289> Получайте бонусы за пополнение баланса, покупки, участие в ивентах и активностях </div><a href="https://steam.kupikod.com/bonus-program?utm_source=kupikod.com" target="_blank" class="window__button" data-v-1ad72289>Подробнее</a><svg class="window__coin" xmlns="http://www.w3.org/2000/svg" width="66" height="66" viewBox="0 0 66 66" fill="none" data-v-1ad72289><g clip-path="url(#clip0_260_4753)" data-v-1ad72289><path fill-rule="evenodd" clip-rule="evenodd" d="M28.0933 60.9814C43.6093 63.6286 58.3334 53.1966 60.9807 37.6806C63.628 22.1647 53.1959 7.44059 37.68 4.79331C22.1641 2.14604 7.4399 12.5781 4.79263 28.094C2.14535 43.61 12.5774 58.3341 28.0933 60.9814ZM19.0312 44.9793L25.9844 46.1656L28.0342 34.1519L36.5688 47.9715L45.0287 49.4149L35.12 32.6974L47.7108 22.0448L39.3668 20.6212L28.8382 29.4391L30.598 19.1251L23.6447 17.9388L19.0312 44.9793Z" fill="#FFE500" data-v-1ad72289></path></g><defs data-v-1ad72289><clipPath id="clip0_260_4753" data-v-1ad72289><rect width="57" height="57" fill="white" transform="translate(9.58594) rotate(9.68238)" data-v-1ad72289></rect></clipPath></defs></svg></div></div>', 3), c_ = [i_]; function a_(e, t) { return O(), K("div", r_, c_) } const l_ = ue(o_, [["render", a_], ["__scopeId", "data-v-1ad72289"]]); const u_ = e => (Je("data-v-f26c6372"), e = e(), Ke(), e), f_ = ["href"], d_ = { class: "job-item__title" }, h_ = { class: "job-item__tags" }, p_ = { class: "job-item__skils" }, __ = u_(() => m("span", null, "|", -1)), g_ = { __name: "JobItem", props: { item: { type: Object } }, setup(e) { return (t, s) => (O(), K("a", { href: e.item.link, target: "_blank", class: "job-item" }, [m("div", d_, Me(e.item.title), 1), m("div", h_, [(O(!0), K(ce, null, ss(e.item.tags, (n, o) => (O(), K("div", { class: "job-item__tag", key: o }, Me(n), 1))), 128))]), m("div", p_, [(O(!0), K(ce, null, ss(e.item.skils, (n, o) => (O(), K(ce, { key: o }, [Xe(Me(n), 1), __], 64))), 128))])], 8, f_)) } }, m_ = ue(g_, [["__scopeId", "data-v-f26c6372"]]); const hc = e => (Je("data-v-49735cd3"), e = e(), Ke(), e), v_ = { class: "section-work" }, A_ = hc(() => m("div", { class: "--anchor", id: "section-work" }, null, -1)), b_ = { class: "container" }, y_ = hc(() => m("div", { class: "section-work__header" }, "У нас можно работать", -1)), k_ = { class: "section-work__grid" }, w_ = { __name: "SectionWork", setup(e) { const t = [{ title: "Python developer [middle]", tags: ["Москва", "Полный рабочий день", "Можно удаленно", "От 2 лет опыта"], skils: ["middle", "selenium", "PostgreSQL", "Git", "Docker", "Linux"], link: "https://talantix.ru/form/9gJJynh6vfKnOfVSDgVnvQ?utm_source=kupikod.com" }, { title: "SMM-менеджер [Junior / Middle]", tags: ["Москва", "Полный рабочий день", "Можно удаленно", "Опыт работы не менее года"], skils: ["Социальные сети", "Поиск", "ТЗ", "Копирайт", "Насмотренность"], link: "https://talantix.ru/form/AJW4tna7v04XnDBIoqEyMA?utm_source=kupikod.com" }, { title: "Project manager [Middle]", tags: ["Москва", "Полный рабочий день", "Можно удаленно", "От 2 лет опыта"], skils: ["Технический бекграунд", "Jira", "Scrum", "Agile"], link: "https://talantix.ru/form/UCGudXO8cDv8qCCnXjxPlg?utm_source=kupikod.com" }, { title: "Product designer [Middle / Senior]", tags: ["Москва", "Полный рабочий день", "Можно удаленно"], skils: ["Figma", "принципы UI/UX", "Adobe Photoshop", "Illustrator", "After Effects"], link: "https://talantix.ru/form/r8cZtT36E3NoNqGjE7iT2A?utm_source=kupikod.com" }, { title: "Разработчик PHP (Laravel) [Middle]", tags: ["Москва", "Полный рабочий день", "Можно удаленно"], skils: ["php", "laravel", "postgresql", "redis", "rabbitmq", "docker", "gitlab"], link: "https://talantix.ru/form/rM7LcHPaQcxN8xmWRbzv_A?utm_source=kupikod.com" }, { title: "Product Marketing Analyst [Middle / Senior]", tags: ["Москва", "Полный рабочий день", "Можно удаленно", "От 2 лет опыта"], skils: ["мат-статистика", "custdev", "Excel", "Y.Metrica", "Коммуникативные навыки"], link: "https://talantix.ru/form/1oEKRR2sW4QY65xr8Km5rw?utm_source=kupikod.com" }]; return (s, n) => { const o = m_; return O(), K("div", v_, [A_, m("div", b_, [y_, m("div", k_, [(O(), K(ce, null, ss(t, (r, i) => U(o, { key: i, item: r }, null, 8, ["item"])), 64))])])]) } } }, x_ = ue(w_, [["__scopeId", "data-v-49735cd3"]]), E_ = "data:image/webp;base64,UklGRm4FAABXRUJQVlA4WAoAAAAQAAAAFAEAGwAAQUxQSNECAAABkJftb9hGgmAIghAIgRAGMYOFQcygZuAx6BgYQiAYgiF4d9dK+inu/R0REAS4bdscknS3AEwv9QdD0EqKQpUs9Uh/JRlJZFQSjFUiWgesXiO/W2bJzj8vTXARSdNjDEv89XF1U66rbPRXpmywSTvcJEdtoZtw0ekANiGvnB3J1U4DmEmURX4yTcwoOPCEEF9ww6yAm4TYxY1eA03NKDDwhGzd4eiwC7hoBzhFd5locsaBAk2IX7jdlbGbeShVzU9HASeEm1MydqWzjXCJzjb6AMYKAk5I9UpWXRlVwXgQ/QiyC6HaJiT6RYuujGhgEQ8YF9MsRIuOJvADYpsQ29ueo6Lc5DcqXxEzqfMlmvoONA2wSRBoQlge82BKJoZRs4EmFxH1IJqI5mG1aGue7OYJ2eRzs0lZPPqpoCZlQjH8yf/Bp6EJyeJ5zUaQBruooCZFWP6TK30QEQSakG/xcPguuzEd7E0VO2nik+mDaAHjvOTNZi8iOxThQRKx6mKMPBeJTNjvnxSe0p3bfNhzQztBtSKF+PGkkSejb/cV4cFTBsgNnS1XA1rY5EhjX8Y4RQ7PIrIKahLq6VRZgfk1XNhtfjwDeTPOu4pQQU0aBhN5BNFTizqrXGBwopeVyImubL97ilABTbJhLzqU3Np1lbaIKUtbhiykwVYRkRdt0ZZwbilCo1bQpEYNhiUkpTE3sQpZhaKlZ1sb3H2LYD+TGvl1twYeyYtEk1HDizNlJeWeItjRpO7ZlFvU5cNFk5FtO+npu5Bz0Rt+JrVVeSC36wpb48lI1h3k8fYjTkUIuJlUFrLMueXSKk4NNBVdOZnFLubj18fTpQgcPY18P4HkljdTx+gH0RwYJ8R68kkNLCKp2XxMmheyoL/IqSFhAs2CPCEO/3E6wCIMeJgsLzps/RRJKWgbaku5qMopLnbfHgTJ5L+I+S2tyaAcmPEi7NkKaJIAAFZQOCB2AgAAkBEAnQEqFQEcAD6JQJdHpSSiISnYv1igEQlsANU9tP5L+FfYxU/5x+Of44dELrp3eygPlQ+6fbn7s/5B0gH6K9IDzAfyL/Vf4r+S+7v/M/7X/APJA+QD+Vf770ZvYA9AD+Af0D0ov16+Ab9sf259oL//gM8k4wVpMi5Z1wQLsipBniWhq+dhw6c9Cd0HEE/in9TcLIAA/utj8e1RdgKzxPZbaO0rV5wv5PdcD32/K+PgERpYgH8u+XVHvJJb5rEf9jOfqfHKwnN6NthRFmL1yIQ/7jlFDUeosrEv/4IRN0qSgbnTaGZAdqa1g7D4eiPAk5rJVh+4VvpeQ3oR1EqtIEdRLKjJrkov3c6lUFzkSK6zxDUj1LNn7ia87MhreP0RMi05kKvx6pcrM4wgBkCO7yT4RcpqfjKGmE0Rx7ZDUIyQgrJ4MYxO+vRJs0cvpjutcxTlP/QL/hxU+310JtAakVGVIug80KCQeMxvZdn0PypvkOjZlaWgUArnYgdoTZ8ea1+ZlclfO26WFGoQXYNsboggQ+hjzLG/vGQvwZPveQvE1JzwkrJqUQ6KmhNvYb3ZfxeUPdycUo9G9do32ZfupQC6H9uRwHtcY/vG3BPQy/W7rIhfzVkRfxz73zPakIVEKxjztFP3IgitGN40oYs72dzUYNddlyRc5a8C3IJApkyQRAIqjHHThMtTdlKqdI3EBcnTgTR6IPwBnEiwsSsF+LKdSeYKVwwFZI/Ttj2P8Xqzg0BF7bNTLfzoaPW1k9X4t7HEhbWWT4qX1cpuRRXcxXR8lylhnrVr5eHgGgraf8Pp+Y+kRHPNJBWtmDH1AMW24QCoAAAA", C_ = "data:image/webp;base64,UklGRmIBAABXRUJQVlA4WAoAAAAQAAAALwAALwAAQUxQSAIBAAABgFTbbtjoQxAEQTAEQwgEMxgziBk0DFwGhSAIgSAIgvAXSVt5dt1FxATg96h9nk7S7bHpOunGz191UXV+P3XFzlQveTuTo2Qp0z1r5nFLigUzif/OFxxJY0FJkkibyC6R5JKG4ikmyN4BfX4XHUBPih2A9vOTsE0AsZlkfOCq2zjmnEevAgDqbEmN9IavZQ9Sk2AkrX0me5AcyBYnSZ+tCgDduvE6kC9PJkYHJMkAVPsmhgA6kuJUADrsXby6ACh+JBldcVvq1raiuP0jW1IlOfXycTXSkT1IctZPpBvJ0DQMXsMevbXW58lrFCxszu9NsbadX1jF+tJfZ5D082iCHzxWUDggOgAAAHAEAJ0BKjAAMAA+cSiPR6SioSE8YJAOCWkAAKSw5M9SDEvVPCRiapZBOM0oAP7+hvY//8OkAAAAAAA=", br = "data:image/webp;base64,UklGRkQBAABXRUJQVlA4WAoAAAAQAAAALwAALwAAQUxQSOIAAAABgFTbbt3qQjAEQTCEQAiEQCgEMWgYKBDKwBAMQRAMQQNL/mT23igiJgD/R9OnNFvcyrUiq21VmsrNNrc8QWrbNY2JucrPnLA69h0i8xmYA9izY0R2ECS4B5LtGG0puhxC+EQC6gTU2RWJg5gjBjoGHInUEeYDYGaNlKVTFkcDspgBmxZWi5N37gF44PR4QEBzBBn4eM/AdvHKe35efU/19D3q2XvbikqYpDpkC2rCdKpblLCQ2o4TS485jRiL70i9GiiW16B4t6e0jtS7PWqdEjZm7Rp5yKVZIWylYq1k/AkCVlA4IDwAAACwAwCdASowADAAPoEylEelIyIhNUgAoBAJaQAAw59YP9e4JjzwAAD9Mf//0BXoyeS6T///5+hv/o7wAAA=", R_ = "data:image/webp;base64,UklGRnYBAABXRUJQVlA4WAoAAAAQAAAAHwAAHwAAQUxQSCkBAAABgE5rexjpQfgQPoQiBGEQglCDqcHUIGOwaxCEInwIH8L7Y9KkCBExAUxabVdK2Vs1Htxaarb5in20/J7z0IPhE1vq0fAbT61GpCSFDyw0n4cBJSSF/TTNxwbmwCHpA7gWC94z4g1dkkNb+MdjB792iqQT12LlbAAWRkhpdaXQyw9XoUuqfwsBf69BH7VrwWHvPx4Qkq6YOwCuv+J7vqiSlNQ+0RnuV/SCxY8A/8YgfTT0S3dgNdTPwr2Xd2qYA2CjvnxkTZPXHXiN908Jzbat3IFngY/mqymq33Ae3rVodCmb31UtNiiSFBTAw9uKA6ck7Vtvn9xdiweAhaSs9qrmsRAMPSWpH0fXYviILfVoOPceT4Qza+faaSz6dypP50Gv3yulvFo1JgEAVlA4ICYAAADQAgCdASogACAAPpFEnUqlo6KhqAgAsBIJaQAAPaOgAP74TQAAAA==", T_ = "data:image/webp;base64,UklGRvIAAABXRUJQVlA4WAoAAAAQAAAAHwAAHwAAQUxQSJQAAAABcE1tW2V9CCGEEEIIIfwIgzIGZbDHIIQQfoQQvou/0z7dR8QE4IeGMAvhhK+kJhOVVL+XaSOQaJ89HaiDDnSvDngJh3VPRs9rJHu4B9oGN06Kctov7LoktqjmrK2IjX4hdU4zUDjtcdZ4hm3GU/wdekpnPsk0AlHmbvYLheMMFI7l76W1cCKsoe5VbLrS1/rtdv44VlA4IDgAAABQAwCdASogACAAPpE6mEelo6KhMAgAsBIJaQAAcby+xpOvAAD+77j//th//7XY//7V4j/huAAAAA==", I_ = "data:image/webp;base64,UklGRgABAABXRUJQVlA4WAoAAAAQAAAAHwAAHwAAQUxQSKUAAAABZ2CQbeTkHcGGcAiP8BER0aeUm8JtbNuq8j6a/gyXmIgCKOYXgBXwMhpwJ6MBDd3tdPXfeRdpIKL/jNy2jcTuo9s8Q/10eGXJDdIJLZ5R6UREOlGW+h0RoddRlvodUq9rn9t/TxrWvgYAW/fgmyruZwPC1PMvU0qZowiTJk0yJXOyIQcCefv4c52UiPs2FRSNqynI6vQbLGMGYBO2yXfek5j611AAVlA4IDQAAADwAgCdASogACAAPn0wkkekoyGhN+gAkA+JaQAA2VKwAAD9Mf//0cOP+dJI/2u3//0XYAAA", P_ = "data:image/webp;base64,UklGRtgBAABXRUJQVlA4WAoAAAAQAAAALAAALAAAQUxQSGsBAAABcFXbbhVFQiVUQiUgoQ6og8FBcQAOwAESKgEJlYCErDUkN5nnd0Qwcts2jOMcm2qZt0fQ365QN1AZKi6IJ2rNjOpKiL1Dnq61M6YJWgvjcoqbUuUXpLZzMfMilPmpWYE5ReVGGzXuSl7hJZ/P7uKCl0WNeRPnuMc3KJQpyAmRXhCux90TvaAIlcR0mKxm6spKasJBmAMqXTdFxenqAWgQVLPJvKB09Qj3phaHfN4kZyCS0zMZwbwGMmpV3Nl41tjYeD4cmWKli5JYyx7IUbnNZrpGPd+hYSAzXVXMKK7emKvEUh02MSORS+JzEy8Hv8VmzcfpEZvBCVjvrbziw0iAOFBdGoUWMwEnP+1u5molYBIsnta2EjALe7pHcUAnoGRoT4N7riJfuM8D2k0Dv87Olo0vNMI7qjX/AF8o4MHjC36QkVGqAY+64+bfHDSRLB+KZmcuHhqyDGiG5KIx/DKNyfMijYen+Wn+ehEAVlA4IEYAAADQAwCdASotAC0APok4lkelI6IhMcgAoBEJaQAAiuDelsvJtxPHWgAA/vj0Qsf/OQdv+V2g+5un//5glH+trv7G///I2wAA", S_ = "data:image/webp;base64,UklGRi4BAABXRUJQVlA4WAoAAAAQAAAAIAAAHwAAQUxQSFwAAAABf2CQbaQ7gq/Bvz/nQ0RExt/OAdjU2rYEt4kIFGBj9i8LOYhEIyK4u/06MUb0fwIEXm0AAA9rOt8uRnZ+FiKq+Tp1VI+wUMMf1CJMVP5VSihn+/AFzDB9iziMAVZQOCCsAAAAMAUAnQEqIQAgAD6RPppIJaOioSq4DACwEglpAMzRi+HKMPX4eGOsYAyk0d6yTgISDAAA/v6gI/8Ing7TynbleexaGP76r+Ja1qEPy895Ogs7Sl3LF9nS/PC7qnQqBi676fs2LJS+K2S8//wD9WHDf3fF/VJBSpec3o2eE1bBWmRrlboVyI3zTu79kJiE5j1+sU6mzeJ61xBvDDxGx/Y4waGzCqYCLSA9iZgAAA=="; const pc = e => (Je("data-v-57a3a290"), e = e(), Ke(), e), M_ = { class: "widget" }, B_ = { class: "widget_container" }, H_ = { class: "widget_logo" }, L_ = pc(() => m("img", { src: E_, alt: "logo" }, null, -1)), O_ = pc(() => m("div", { class: "widget_title" }, "Пополнение сервисов", -1)), U_ = ["href"], N_ = { class: "widget-item_img" }, j_ = { class: "widget-item_img-box" }, $_ = ["src", "alt"], Q_ = { class: "widget-item_img-sub" }, F_ = ["src"], D_ = { class: "widget-item_text" }, J_ = { class: "widget-item_name" }, K_ = { class: "widget-item_description" }, W_ = { class: "widget-item_img" }, V_ = { class: "widget-item_img-box" }, q_ = ["src", "alt"], Y_ = { class: "widget-item_img-sub" }, Z_ = ["src"], X_ = { class: "widget-item_text" }, z_ = { class: "widget-item_name" }, G_ = { class: "widget-item_description" }, eg = { class: "widget_items" }, tg = ["href"], sg = { class: "widget-item_img" }, ng = { class: "widget-item_img-box" }, og = ["src", "alt"], rg = { class: "widget-item_img-sub" }, ig = ["src"], cg = { class: "widget-item_text" }, ag = { class: "widget-item_name" }, lg = { class: "widget-item_img" }, ug = { class: "widget-item_img-box" }, fg = ["src", "alt"], dg = { class: "widget-item_img-sub" }, hg = ["src"], pg = { class: "widget-item_text" }, _g = { class: "widget-item_name" }, gg = { __name: "TheWidget", setup(e) { const { $windowWidth: t } = le(), s = be(!0), n = Ms(() => "codes"); let o = 0; const r = [{ name: "Пополняй Steam", description: "Комиссия от 0%", link: "https://steam.kupikod.com?utm_source=kupikod.com", externalLink: !0, image: C_, subImg: R_, path: ["https://steam.kupikod.com?utm_source=kupikod.com"], class: "balance" }, { name: "Мобильные игры", description: "Пополняй валюту", link: "https://kupikod.com/gold/", externalLink: !1, image: P_, subImg: S_, path: ["https://kupikod.com/gold/"], class: "mobile" }, { name: "Покупай гифты", description: "недоступные в РФ", link: "https://steam.kupikod.com/ru-ru/games/top?utm_source=kupikod.com", externalLink: !1, image: br, subImg: T_, path: ["https://steam.kupikod.com/ru-ru/games/top?utm_source=kupikod.com"], class: "gifts" }, { name: "Покупай ключи", description: "и подписки", link: "/shop?utm_source=kupikod.com", externalLink: !0, image: br, subImg: I_, path: ["/shop?utm_source=kupikod.com"], class: "codes" }]; function i() { var c = window.scrollY || document.documentElement.scrollTop; c > o ? s.value = !1 : c < o && (s.value = !0), o = c <= 0 ? 0 : c } return Xs(() => { window.innerWidth < 1111 && window.addEventListener("scroll", i, !1) }), (c, l) => { const u = nc; return O(), He(il, { to: "body" }, [m("div", M_, [m("div", B_, [m("div", H_, [U(u, { to: "/" }, { default: Ye(() => [L_, O_]), _: 1 })]), ne(t) > 767 ? (O(), K("div", { key: 0, class: _e(["widget_items", { show: s.value }]) }, [(O(), K(ce, null, ss(r, a => (O(), K(ce, { key: a.name }, [a.externalLink ? (O(), K("a", { key: 0, target: "_blank", class: _e(["widget_item widget-item", "widget_" + a.class]), href: a.link }, [m("div", N_, [m("div", j_, [m("img", { class: "img", src: a.image, alt: a.name }, null, 8, $_), m("div", Q_, [m("img", { class: "img", src: a.subImg, alt: "sub image" }, null, 8, F_)])])]), m("div", D_, [m("div", J_, Me(a.name), 1), m("div", K_, Me(a.description), 1)])], 10, U_)) : (O(), He(u, { key: 1, class: _e(["widget_item widget-item", { "--active": a.class === n.value }]), to: a.link }, { default: Ye(() => [m("div", W_, [m("div", V_, [m("img", { class: "img", src: a.image, alt: a.name }, null, 8, q_), m("div", Y_, [m("img", { class: "img", src: a.subImg, alt: "sub image" }, null, 8, Z_)])])]), m("div", X_, [m("div", z_, Me(a.name), 1), m("div", G_, Me(a.description), 1)])]), _: 2 }, 1032, ["class", "to"]))], 64))), 64))], 2)) : rs("", !0)]), ne(t) < 768 ? (O(), K("div", { key: 0, class: _e(["widget_scroll", { show: s.value }]) }, [m("div", eg, [(O(), K(ce, null, ss(r, a => (O(), K(ce, { key: a.name }, [a.externalLink ? (O(), K("a", { key: 0, class: _e(["widget_" + a.class, "widget_item widget-item"]), href: a.link, target: "_blank" }, [m("div", sg, [m("div", ng, [m("img", { class: "img", src: a.image, alt: a.name }, null, 8, og), m("div", rg, [m("img", { class: "img", src: a.subImg, alt: "sub image" }, null, 8, ig)])])]), m("div", cg, [m("div", ag, Me(a.name), 1)])], 10, tg)) : (O(), He(u, { key: 1, class: _e([{ "--active": a.class === n.value }, "widget_item widget-item"]), to: a.link }, { default: Ye(() => [m("div", lg, [m("div", ug, [m("img", { class: "img", src: a.image, alt: a.name }, null, 8, fg), m("div", dg, [m("img", { class: "img", src: a.subImg, alt: "sub image" }, null, 8, hg)])])]), m("div", pg, [m("div", _g, Me(a.name), 1)])]), _: 2 }, 1032, ["class", "to"]))], 64))), 64))])], 2)) : rs("", !0)])]) } } }, mg = ue(gg, [["__scopeId", "data-v-57a3a290"]]), vg = Ys({ name: "ClientOnly", inheritAttrs: !1, props: ["fallback", "placeholder", "placeholderTag", "fallbackTag"], setup(e, { slots: t, attrs: s }) { const n = be(!1); return Xs(() => { n.value = !0 }), o => { var l; if (n.value) return (l = t.default) == null ? void 0 : l.call(t); const r = t.fallback || t.placeholder; if (r) return r(); const i = o.fallback || o.placeholder || "", c = o.fallbackTag || o.placeholderTag || "span"; return K(c, s, i) } } }), $s = "data:image/webp;base64,UklGRh4BAABXRUJQVlA4WAoAAAAQAAAAHwAAHwAAQUxQSMYAAAABgCxJtmmrr+37bNu2NbJt23797xvnehwRE4AM3hQfZ/PB50Yc8sY/SNIfI2v5wT/FL1NMnKOPVJ4hhqXzH9TcMuSoO6B0u/BDmDLgHH2m9K3TuUqxS6tk9oPy/aBrj9JSlan0gMqPXvgvKA+pDqg+DCF4Rfk7lPZlxfeQGcEHKg9UQLB1+Z48KAIiD1Qv6YjZfgDBB2oOGZHOUbcmJnkPOvkxQXBB9WeLDdD2ILtCzIMLkr3YAZ2PJPvigeDC51EwLoAJGTNWUDggMgAAANACAJ0BKiAAIAA+kTSkUiWiI6OUALASCWkAAEuuigAA+Ff//Gk0/27f5X//+9aAAAAA", Ag = "" + new URL("footer-person.90988a07.webp", import.meta.url).href; const Ne = e => (Je("data-v-ff8c1214"), e = e(), Ke(), e), bg = { class: "footer" }, yg = Ne(() => m("div", { class: "--anchor", id: "section-contacts" }, null, -1)), kg = { class: "container" }, wg = { class: "footer__container" }, xg = we('<div class="footer__col footer__col--1" data-v-ff8c1214><svg class="footer__logo" width="233" height="23" viewBox="0 0 233 23" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-ff8c1214><g opacity="0.5" data-v-ff8c1214><path d="M0 0H8.62706V11.7683L22.5603 0H32.7395L19.2394 11.3748L33.0283 23H22.8491L14.1498 15.6672L5.45057 23H0V0Z" fill="white" data-v-ff8c1214></path><path d="M36.425 0H45.0521V11.5179C45.0521 12.7818 45.4852 13.8548 46.3516 14.7372C47.2419 15.5956 48.3369 16.0249 49.6363 16.0249H59.8516C61.1271 16.0249 62.1979 15.5956 63.0642 14.7372C63.9546 13.8548 64.3998 12.7818 64.3998 11.5179V0H73.0269V11.5179C73.0269 14.761 71.9079 17.4914 69.6699 19.7092C67.456 21.9031 64.7126 23 61.4399 23H48.0481C44.7513 23 41.9839 21.9031 39.7459 19.7092C37.532 17.4914 36.425 14.761 36.425 11.5179V0Z" fill="white" data-v-ff8c1214></path><path d="M76.4456 0H102.868C105.154 0 107.067 0.775013 108.608 2.32504C110.148 3.85122 110.918 5.74702 110.918 8.01244C110.918 10.254 110.148 12.1498 108.608 13.6998C107.067 15.226 105.154 15.9891 102.868 15.9891H85.0727V23H76.4456V0ZM85.0727 6.97512V9.014H101.28C101.569 9.014 101.809 8.91861 102.002 8.72784C102.194 8.53707 102.291 8.2986 102.291 8.01244C102.291 7.72628 102.194 7.48782 102.002 7.29705C101.809 7.08243 101.569 6.97512 101.28 6.97512H85.0727Z" fill="white" data-v-ff8c1214></path><path d="M114.351 0H122.978V23H114.351V0Z" fill="white" data-v-ff8c1214></path><path d="M126.418 0H135.045V11.7683L148.978 0H159.158L145.658 11.3748L159.446 23H149.267L140.568 15.6672L131.869 23H126.418V0Z" fill="white" data-v-ff8c1214></path><path d="M170.13 0H183.522C186.795 0 189.538 1.10886 191.752 3.32659C193.99 5.52048 195.109 8.25091 195.109 11.5179C195.109 14.761 193.99 17.4914 191.752 19.7092C189.538 21.9031 186.795 23 183.522 23H170.13C166.834 23 164.066 21.9031 161.828 19.7092C159.614 17.4914 158.507 14.761 158.507 11.5179C158.507 8.25091 159.614 5.52048 161.828 3.32659C164.066 1.10886 166.834 0 170.13 0ZM171.719 6.97512C170.419 6.97512 169.324 7.41628 168.434 8.2986C167.568 9.15708 167.134 10.2302 167.134 11.5179C167.134 12.7818 167.568 13.8548 168.434 14.7372C169.324 15.5956 170.419 16.0249 171.719 16.0249H181.934C183.209 16.0249 184.28 15.5956 185.146 14.7372C186.037 13.8548 186.482 12.7818 186.482 11.5179C186.482 10.2302 186.037 9.15708 185.146 8.2986C184.28 7.41628 183.209 6.97512 181.934 6.97512H171.719Z" fill="white" data-v-ff8c1214></path><path d="M198.528 0H221.413C224.686 0 227.429 1.10886 229.643 3.32659C231.881 5.52048 233 8.25091 233 11.5179C233 14.761 231.881 17.4914 229.643 19.7092C227.429 21.9031 224.686 23 221.413 23H198.528V0ZM207.155 6.97512V16.0249H219.825C221.1 16.0249 222.171 15.5956 223.037 14.7372C223.928 13.8548 224.373 12.7818 224.373 11.5179C224.373 10.2302 223.928 9.15708 223.037 8.2986C222.171 7.41628 221.1 6.97512 219.825 6.97512H207.155Z" fill="white" data-v-ff8c1214></path></g></svg><div class="footer__copyright" data-v-ff8c1214>(c) KUPIKOD, 2024</div></div><div class="footer__col footer__col--2" data-v-ff8c1214><div class="footer__col-head" data-v-ff8c1214>Продукты</div><a class="footer__link" target="_blank" href="https://steam.kupikod.com/?utm_source=kupikod.com" data-v-ff8c1214>Пополнить Стим</a><a class="footer__link" target="_blank" href="https://steam.kupikod.com/ru-ru/games?utm_source=kupikod.com" data-v-ff8c1214>Купить игру в Стим гифтом</a><a class="footer__link" target="_blank" href="https://kupikod.com/gold/" data-v-ff8c1214>Донат в мобильные игры</a><a class="footer__link" target="_blank" href="https://kupikod.com/shop/?utm_source=kupikod.com" data-v-ff8c1214>Купить игру ключом</a><a class="footer__link" target="_blank" href="https://kupikod.com/activator/?utm_source=kupikod.com " data-v-ff8c1214>Активатор</a></div>', 2), Eg = { class: "footer__col footer__col--3" }, Cg = we('<div class="footer__col-head" data-v-ff8c1214>Связаться с нами</div><a class="footer__link footer__link--underline" href="https://t.me/kupikod_bot" target="_blank" data-v-ff8c1214><img src="' + $s + '" alt="" data-v-ff8c1214> Поддержка клиентов </a><a class="footer__link footer__link--underline" href="https://t.me/kupikod_b2b?utm_source=kupikod.com" target="_blank" data-v-ff8c1214><img src="' + $s + '" alt="" data-v-ff8c1214> B2B сотрудничество </a>', 3), Rg = Ne(() => m("img", { src: $s, alt: "" }, null, -1)), Tg = Ne(() => m("a", { class: "footer__link footer__link--underline footer__link--contacts", href: "mailto:admin@kupikod.com", target: "_blank" }, [m("img", { src: $s, alt: "" }), Xe(" Правообладателям ")], -1)), Ig = { class: "footer__col footer__col--4" }, Pg = Ne(() => m("div", { class: "footer__col-head" }, "Наши медиа с полезным контентом:", -1)), Sg = Ne(() => m("div", { class: "footer__widget widget" }, [m("div", { class: "widget__title" }, " Добавь виджет на свой сайт и зарабатывай вместе с kupikod "), m("a", { href: "https://t.me/kupikod_b2b?utm_source=kupikod.com", target: "_blank", class: "widget__button" }, "Подробнее")], -1)), Mg = we('<div class="footer__bottom" data-v-ff8c1214><div class="footer__address-list" data-v-ff8c1214><div class="footer__address" data-v-ff8c1214></div><div class="footer__address-2" data-v-ff8c1214></div></div><div class="footer__terms" data-v-ff8c1214><a href="" class="footer__term" data-v-ff8c1214>Политика конфиденциальности</a><a href="" class="footer__term" data-v-ff8c1214>Пользовательское соглашение</a></div></div>', 1), Bg = Ne(() => m("div", { class: "footer__br" }, null, -1)), Hg = Ne(() => m("img", { class: "footer__img", src: Ag, alt: "" }, null, -1)), Lg = { key: 0, class: "modal" }, Og = { class: "modal-content contacts-modal" }, Ug = Ne(() => m("h2", { class: "mb-5" }, "Контакты", -1)), Ng = Ne(() => m("div", { class: "terms-none" }, null, -1)), jg = Ne(() => m("div", { class: "terms-none2" }, null, -1)), $g = Ne(() => m("div", { class: "terms-none3" }, null, -1)), Qg = { __name: "Footer", setup(e) { const t = be(!1), s = { mounted(o, r) { o.clickOutsideEvent = function (i) { o === i.target || o.contains(i.target) || r.value(i, o) }, setTimeout(() => document.body.addEventListener("click", o.clickOutsideEvent), 10) }, unmounted(o) { document.body.removeEventListener("click", o.clickOutsideEvent) } }, n = () => { t.value = !1 }; return (o, r) => { const i = lc, c = nc, l = vg; return O(), K(ce, null, [m("div", bg, [yg, m("div", kg, [m("div", wg, [xg, m("div", Eg, [Cg, m("a", { class: "footer__link footer__link--underline footer__link--contacts", onClick: r[0] || (r[0] = u => t.value = !0), target: "_blank" }, [Rg, Xe(" Контакты ")]), Tg]), m("div", Ig, [Pg, U(i, { noBadges: "", class: "footer__nav" }), Sg])]), Mg]), Bg, Hg]), U(l, null, { default: Ye(() => [ne(t) ? (O(), K("div", Lg, [Ia((O(), K("div", Og, [m("span", { onClick: r[1] || (r[1] = u => t.value = !1), class: "close" }, "×"), Ug, U(c, { href: "https://t.me/kupikod_bot", target: "_blank", class: "mb-4" }, { default: Ye(() => [Xe(" Поддержка ")]), _: 1 }), Ng, jg, $g])), [[s, n]])])) : rs("", !0)]), _: 1 })], 64) } } }, Fg = ue(Qg, [["__scopeId", "data-v-ff8c1214"]]); const Dg = {}, Jg = { class: "layout" }; function Kg(e, t) { const s = mg, n = Fg; return O(), K("div", Jg, [U(s), ja(e.$slots, "default"), U(n)]) } const Wg = ue(Dg, [["render", Kg]]); const Vg = { class: "main" }, qg = { __name: "MainPage", setup(e) { return Vi({ title: "Kupikod – покупка, пополнение игр и сервисов", htmlAttrs: { lang: "ru" }, meta: [{ name: "description", content: "KupiKod - сайт для покупки, пополнения игр, множества сервисов и приложений. У нас вы найдете множество отзывов, поддержку пользователей, большой выбор и низкие цены!" }, { property: "og:type", content: "website" }, { property: "og:title", content: "Kupikod – оплата и пополнение зарубежных сервисов" }, { property: "og:description", content: "Пополняйте зарубежные сервисы, оплачивайте подписки, покупайте игры недоступные в России вместе с Kupikod по самым выгодным ценам. Поддержка по любым вопросам, сотни отзывов и множество акций" }, { property: "og:url", content: "https://kupikod.com" }, { property: "og:image", content: "https://kupikod.com/kupikod_1.jpg" }, { property: "og:site_name", content: "Kupikod.com" }, { property: "og:locale", content: "ru_RU" }], script: [{ type: "application/ld+json", async: !0, children: JSON.stringify({ "@context": "https://schema.org/", "@type": "AggregateRating", itemReviewed: { "@type": "Organization", name: "Kupikod – покупка, пополнение игр и сервисов", url: "https://kupikod.com", email: "support@kupikod.com", sameAs: ["https://vk.com/kupikod_com"], logo: "Здесь нужна ссылка на логотип, я не нашёл", image: "Здесь нужна ссылка на изображение, я не нашёл", alternateName: "Kupikod – оплата и пополнение зарубежных сервисов", description: "KupiKod - сайт для покупки, пополнения игр, множества сервисов и приложений. У нас вы найдете множество отзывов, поддержку пользователей, большой выбор и низкие цены!", address: { "@type": "PostalAddress", streetAddress: "Азовская ул., 24, корп. 3", addressLocality: "Москва", postalCode: "117452" }, telephone: "" }, ratingValue: "4,4", bestRating: "5", ratingCount: "27" }) }] }), (t, s) => { const n = Kh, o = n_, r = l_, i = x_, c = Wg; return O(), K("div", Vg, [U(c, null, { default: Ye(() => [U(n), U(o), U(r), U(i)]), _: 1 })]) } } }, Yg = ue(qg, [["__scopeId", "data-v-34e305b7"]]), Zg = e => Object.fromEntries(Object.entries(e).filter(([, t]) => t !== void 0)), Xg = (e, t) => (s, n) => (Vi(() => e({ ...Zg(s), ...n.attrs }, n)), () => { var o, r; return t ? (r = (o = n.slots).default) == null ? void 0 : r.call(o) : null }), zg = { accesskey: String, autocapitalize: String, autofocus: { type: Boolean, default: void 0 }, class: [String, Object, Array], contenteditable: { type: Boolean, default: void 0 }, contextmenu: String, dir: String, draggable: { type: Boolean, default: void 0 }, enterkeyhint: String, exportparts: String, hidden: { type: Boolean, default: void 0 }, id: String, inputmode: String, is: String, itemid: String, itemprop: String, itemref: String, itemscope: String, itemtype: String, lang: String, nonce: String, part: String, slot: String, spellcheck: { type: Boolean, default: void 0 }, style: String, tabindex: String, title: String, translate: String }, Gg = Ys({ name: "NoScript", inheritAttrs: !1, props: { ...zg, title: String, body: Boolean, renderPriority: [String, Number] }, setup: Xg((e, { slots: t }) => { var o; const s = { ...e }, n = (((o = t.default) == null ? void 0 : o.call(t)) || []).filter(({ children: r }) => r).map(({ children: r }) => r).join(""); return n && (s.children = n), { noscript: [s] } }) }), em = {}; function tm(e, t) {
  const s = Yg, n = Gg; return O(), K(ce, null, [m("div", null, [U(s)]), U(n, null, {
    default: Ye(() => [Xe(`<div>
        <img
          src="https://mc.yandex.ru/watch/89954502"
          style="position: absolute; left: -9999px"
          alt=""
        /></div
    >`)]), _: 1
  })], 64)
} const sm = ue(em, [["render", tm]]), nm = {
  __name: "nuxt-error-page", props: { error: Object }, setup(e) {
    const s = e.error; (s.stack || "").split(`
  `).splice(1).map(f => ({ text: f.replace("webpack:/", "").replace(".vue", ".js").trim(), internal: f.includes("node_modules") && !f.includes(".cache") || f.includes("internal") || f.includes("new Promise") })).map(f => `<span class="stack${f.internal ? " internal" : ""}">${f.text}</span>`).join(`
  `); const n = Number(s.statusCode || 500), o = n === 404, r = s.statusMessage ?? (o ? "Page Not Found" : "Internal Server Error"), i = s.message || s.toString(), c = void 0, a = o ? Bo(() => cr(() => import("./error-404.5197eefa.js"), ["./error-404.5197eefa.js", "./error-404.7fc72018.css"], import.meta.url).then(f => f.default || f)) : Bo(() => cr(() => import("./error-500.db1d8608.js"), ["./error-500.db1d8608.js", "./error-500.c5df6088.css"], import.meta.url).then(f => f.default || f)); return (f, p) => (O(), He(ne(a), Ic(wi({ statusCode: ne(n), statusMessage: ne(r), description: ne(i), stack: ne(c) })), null, 16))
  }
}, om = nm, rm = { __name: "nuxt-root", setup(e) { const t = () => null, s = le(), n = s.deferHydration(), o = !1; fi(zi, Gi()), s.hooks.callHookWith(c => c.map(l => l()), "vue:setup"); const r = ho(); ri((c, l, u) => { if (s.hooks.callHook("vue:error", c, l, u).catch(a => console.error("[nuxt] Error in `vue:error` hook", a)), ed(c) && (c.fatal || c.unhandled)) return s.runWithContext(() => zf(c)), !1 }); const i = !1; return (c, l) => (O(), He(ya, { onResolve: ne(n) }, { default: Ye(() => [ne(r) ? (O(), He(ne(om), { key: 0, error: ne(r) }, null, 8, ["error"])) : ne(i) ? (O(), He(ne(t), { key: 1, context: ne(i) }, null, 8, ["context"])) : ne(o) ? (O(), He(Na(ne(o)), { key: 2 })) : (O(), He(ne(sm), { key: 3 }))]), _: 1 }, 8, ["onResolve"])) } }, yr = rm; globalThis.$fetch || (globalThis.$fetch = Su.create({ baseURL: Bu() })); let kr; { let e; kr = async function () { var r, i; if (e) return e; const n = !!((r = window.__NUXT__) != null && r.serverRendered || ((i = document.getElementById("__NUXT_DATA__")) == null ? void 0 : i.dataset.ssr) === "true") ? Fl(yr) : Ql(yr), o = Wu({ vueApp: n }); try { await qu(o, Id) } catch (c) { await o.callHook("app:error", c), o.payload.error = o.payload.error || c } try { await o.hooks.callHook("app:created", n), await o.hooks.callHook("app:beforeMount", n), n.mount(nd), await o.hooks.callHook("app:mounted", n), await Zn() } catch (c) { await o.callHook("app:error", c), o.payload.error = o.payload.error || c } return n }, e = kr().catch(t => { console.error("Error while mounting app:", t) }) } export { ue as _, m as a, U as b, K as c, Xe as d, nc as e, Ke as f, O as o, Je as p, Me as t, Vi as u, Ye as w };
